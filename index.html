<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Data Extraction App</title>
    <!-- Tailwind CSS -->
    <link
      href="https://unpkg.com/tailwindcss@^2.2/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <!-- Include SheetJS library for Excel file generation -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <!-- Existing scripts... -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <!-- Include FileSaver.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- Font Awesome for icons -->
    <script
      src="https://kit.fontawesome.com/a076d05399.js"
      crossorigin="anonymous"
    ></script>
    <style>
      .dragging {
        opacity: 0.3;
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.25),
          inset 0 0 15px rgba(0, 255, 255, 0.15);
        transition: opacity 0.2s ease-in-out, box-shadow 0.2s ease-in-out,
          transform 0.3s ease;
        border-radius: 12px; /* More pronounced rounding for 3D corners */
        transform: perspective(1000px) translateZ(20px) rotateX(2deg)
          rotateY(-1.5deg);
      }

      .dropzone {
        transition: all 0.3s ease-in-out;
        border: 2px dashed rgba(87, 249, 255, 0.4);
        border-radius: 16px;
        position: relative;
      }
      .dropzone:hover {
        background: rgba(87, 249, 255, 0.05);
        box-shadow: inset 0 0 10px rgba(87, 249, 255, 0.1),
          0 0 15px rgba(50, 255, 150, 0.2);
        transform: perspective(800px) translateZ(5px);
      }

      /*****************************************
   * CUSTOM SCROLLBARS (MORE ROUNDED / 3D)
   *****************************************/
      /* Chrome, Safari, Edge */
      ::-webkit-scrollbar {
        width: 12px;
      }
      ::-webkit-scrollbar-track {
        background: #242424;
        border-radius: 12px;
      }
      ::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, #4a4a4a 0%, #666 100%);
        border-radius: 12px;
        border: 2px solid #242424;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(180deg, #5e5e5e 0%, #777 100%);
      }

      /* Firefox */
      * {
        scrollbar-width: thin;
        scrollbar-color: #666 #242424;
      }
      .modern-scrollbar {
        scrollbar-width: thin;
        scrollbar-color: #666 #242424;
      }
      .modern-scrollbar::-webkit-scrollbar {
        width: 12px;
      }
      .modern-scrollbar::-webkit-scrollbar-track {
        background: #242424;
        border-radius: 12px;
      }
      .modern-scrollbar::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, #4a4a4a 0%, #666 100%);
        border-radius: 12px;
        border: 2px solid #242424;
      }
      .modern-scrollbar::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(180deg, #5e5e5e 0%, #777 100%);
      }

      /*****************************************
   * GLOBAL DARK MODE & BASE FONTS
   *****************************************/
      body {
        background: linear-gradient(135deg, #0c0c0c 0%, #1e1e1e 100%);
        font-family: "Inter", sans-serif;
        color: #e8e8e8;
        margin: 0;
        padding: 0;
        overflow-x: hidden;
      }

      /*****************************************
   * MAIN CONTAINER (FUTURISTIC 3D NEON BOX)
   *****************************************/
      #root > div {
        background: #1a1a1a;
        border: 1px solid #2e2e2e;
        border-radius: 20px; /* bigger rounding for a more 3D look */
        position: relative;
        padding: 24px;
        overflow: hidden;
        box-shadow: 0 0 25px rgba(0, 0, 0, 0.7),
          0 0 15px rgba(50, 255, 150, 0.35), inset 0 0 16px rgba(0, 0, 0, 0.6);
        transform: perspective(1400px) translateZ(0);
      }
      /* Subtle animated gradient overlay for a futuristic feel */
      #root > div::before {
        content: "";
        position: absolute;
        top: -40%;
        left: -40%;
        width: 180%;
        height: 180%;
        background: radial-gradient(
            circle at 30% 30%,
            rgba(87, 249, 255, 0.12),
            transparent 40%
          ),
          radial-gradient(
            circle at 70% 70%,
            rgba(50, 255, 150, 0.12),
            transparent 40%
          ),
          linear-gradient(135deg, rgba(32, 255, 200, 0.08) 0%, transparent 100%);
        pointer-events: none;
        z-index: 0;
        border-radius: 50%;
        animation: floatAround 10s infinite alternate ease-in-out;
      }
      @keyframes floatAround {
        0% {
          transform: translate(0, 0) rotate(0deg);
        }
        50% {
          transform: translate(6%, -6%) rotate(8deg);
        }
        100% {
          transform: translate(-4%, 5%) rotate(-8deg);
        }
      }

      /*****************************************
   * TITLES WITH UNDERLINE ONLY UNDER TEXT
   *****************************************/
      .parent-heading {
        text-align: center;
      }
      h1,
      h2,
      h3 {
        margin: 0;
        font-weight: 700;
        color: #ebebeb;
        text-shadow: 0 0 6px rgba(255, 255, 255, 0.04);
        display: inline-block; /* limit underline width to text only */
        position: relative;
        padding-bottom: 8px; /* spacing so the underline is right below */
      }
      /* NEON UNDERLINE DIRECTLY BELOW THE WORDS */
      h1::after,
      h2::after,
      h3::after {
        content: "";
        position: absolute;
        left: 0;
        bottom: 0; /* underline sits right at the bottom of the text container */
        width: 100%;
        height: 3px;
        background: linear-gradient(90deg, #32ff96, #57f9ff, #32ff96);
        border-radius: 2px;
        animation: neonFlow 2.5s linear infinite;
      }
      @keyframes neonFlow {
        0% {
          background-position: 0%;
        }
        100% {
          background-position: 200%;
        }
      }

      /*****************************************
   * MODAL BACKGROUND (BLUR + 3D)
   *****************************************/
      .modal-bg {
        backdrop-filter: blur(12px) brightness(0.85);
        border-radius: 14px;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.15);
        border: 1px solid rgba(50, 255, 150, 0.2);
        animation: popIn 0.4s ease;
      }
      @keyframes popIn {
        0% {
          transform: scale(0.8) translateY(10px);
          opacity: 0;
        }
        100% {
          transform: scale(1) translateY(0);
          opacity: 1;
        }
      }

      /*****************************************
   * FORM ELEMENTS (3D-EDGED INPUTS)
   *****************************************/
      input[type="number"],
      input[type="text"],
      textarea,
      select {
        background: #2e2e2e;
        border: 1px solid #454545;
        color: #e0e0e0;
        padding: 0.625rem 0.75rem;
        border-radius: 8px; /* more 3D rounding */
        transition: border-color 0.3s ease, box-shadow 0.3s ease,
          transform 0.3s ease;
      }
      input::placeholder,
      textarea::placeholder {
        color: #858585;
      }
      input:focus,
      textarea:focus,
      select:focus {
        border-color: #57f9ff;
        box-shadow: 0 0 8px rgba(87, 249, 255, 0.4),
          inset 0 0 4px rgba(87, 249, 255, 0.2);
        outline: none;
        transform: perspective(800px) translateZ(6px) rotateX(1deg);
      }

      /*****************************************
   * BUTTONS (TRANSPARENT 3D GLASS EFFECT)
   *****************************************/
      button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.75rem 1.25rem;
        border: 2px solid #57f9ff; /* Colored border for the glass effect */
        border-radius: 10px; /* more rounding for 3D */
        font-weight: 600;
        cursor: pointer;
        color: #e0e0e0;

        /* Transparent "glass" background with slight blur */
        background: rgba(255, 255, 255, 0.06);
        backdrop-filter: blur(6px);

        transition: transform 0.25s ease, box-shadow 0.35s ease,
          border 0.25s ease;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.6),
          inset 0 0 4px rgba(50, 255, 150, 0.15);
      }

      button:hover {
        transform: translateY(-3px) scale(1.04) perspective(1000px)
          rotateX(2deg);
        border-color: #32ff96; /* slight color change on hover */
        box-shadow: 0 5px 15px rgba(50, 255, 150, 0.3),
          0 0 5px rgba(87, 249, 255, 0.3), inset 0 0 8px rgba(50, 255, 150, 0.2);
      }

      button:active {
        transform: scale(0.98) translateY(2px);
        border-color: #57f9ff;
        box-shadow: 0 4px 10px rgba(50, 255, 150, 0.2),
          inset 0 0 6px rgba(50, 255, 150, 0.3);
      }

      /* If you have color classes for borders, you could do something like:
     .bg-blue-500 { border-color: #57f9ff; }
     .bg-purple-500 { border-color: #af32ff; }
     etc...
     Just remove the default background-color approach, since these are now glassy.
  */

      /*****************************************
   * SCROLLABLE AREAS / HISTORY
   *****************************************/
      .max-h-96 {
        max-height: 24rem;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: #57f9ff #2b2b2b;
        border-radius: 10px; /* Round the container for the scroll area */
        box-shadow: inset 0 0 6px rgba(87, 249, 255, 0.08);
        transition: box-shadow 0.3s ease;
      }
      .max-h-96:hover {
        box-shadow: inset 0 0 10px rgba(87, 249, 255, 0.15);
      }

      /*****************************************
   * TABLE & NEON HEADERS (3D-EFFECT)
   *****************************************/
      table {
        border-collapse: collapse;
        width: 100%;
        color: #eeeeee;
        background: #1f1f1f;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5),
          inset 0 0 10px rgba(0, 255, 255, 0.05);
        transform: translateZ(0);
      }
      th,
      td {
        border: 1px solid #444;
        text-align: center;
        padding: 0.75rem;
        transition: background 0.2s ease, box-shadow 0.2s ease;
      }
      th {
        background: #2c2c2c;
        position: relative;
        font-weight: 600;
        overflow: hidden;
      }
      th::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(45deg, #32ff96, #57f9ff);
        opacity: 0.08;
      }
      tr:hover td {
        box-shadow: inset 0 0 6px rgba(50, 255, 150, 0.08);
      }
      td:hover {
        background: #2b2b2b;
        box-shadow: inset 0 0 6px rgba(50, 255, 150, 0.1);
        transform: perspective(600px) translateZ(2px);
      }

      /*****************************************
   * TEXT & LABELS
   *****************************************/
      label,
      strong,
      p,
      span,
      h2,
      h3,
      input,
      option {
        color: #e0e0e0 !important;
      }
    </style>
  </head>
  <body
    class="bg-gray-900 text-gray-100 font-sans min-h-screen flex items-center justify-center"
  >
    <div id="root" class="w-full p-6"></div>

    <!-- React and ReactDOM -->
    <script
      src="https://unpkg.com/react@17/umd/react.development.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"
      crossorigin
    ></script>

    <!-- Babel for JSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useState, useEffect } = React;

      function App() {
        const [currentScreen, setCurrentScreen] = useState("home");
        const [groupType, setGroupType] = useState("intervention");
        const [studyIds, setStudyIds] = useState([]);
        const [selectedOption, setSelectedOption] = useState("baseline");
        const [baselineVariables, setBaselineVariables] = useState({});
        const [outcomesVariables, setOutcomesVariables] = useState({});
        const [inputValues, setInputValues] = useState({
          studyIdInput: "",
          variableLabel: "",
          variableType: "dichotomous",
          variableValue: {},
          selectedStudyId: "",
          variableArmType: "single",
        });

        // New state for group names
        const [groupNames, setGroupNames] = useState({
          interventionName: "Intervention",
          comparisonName: "Comparison",
        });

        // Load data from uploaded backup
        const [uploadedData, setUploadedData] = useState(null);

        const handleBackupDownload = () => {
          // 1) Determine naming for the file
          let groupPart;
          if (groupType === "intervention") {
            groupPart = groupNames.interventionName;
          } else if (groupType === "intervention_comparison") {
            groupPart = `${groupNames.interventionName}_x_${groupNames.comparisonName}`;
          } else {
            groupPart = "Data";
          }

          // 2) Build the backup data object
          const backupData = {
            groupType,
            studyIds,
            baselineVariables,
            outcomesVariables,
            inputValues,
            groupNames,
          };

          // (Optional) Also include Google Drive links from localStorage if needed
          const driveLinks =
            JSON.parse(localStorage.getItem("driveLinks")) || {};
          backupData.driveLinks = driveLinks;

          // 3) Save a copy in localStorage (so it persists even if the user doesn’t re-upload)
          try {
            localStorage.setItem(
              "allVariablesBackup",
              JSON.stringify(backupData)
            );
          } catch (err) {
            console.error("Error saving dataset backup to localStorage:", err);
          }

          // 4) Convert to JSON + trigger download
          const blob = new Blob([JSON.stringify(backupData)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;

          const timestamp = new Date();
          const formattedTimestamp = timestamp
            .toISOString()
            .slice(0, 19)
            .replace("T", "_")
            .replace(/:/g, "-");

          a.download = `dataset_backup_${groupPart}_${formattedTimestamp}.json`;
          a.click();
          URL.revokeObjectURL(url);

          // 5) (Optional) Open "Backup Files" links from Google Drive
          try {
            const storedData =
              JSON.parse(localStorage.getItem("driveLinks")) || {};
            const backupLinks = storedData["Backup Files"] || [];
            backupLinks.forEach((link) => {
              window.open(link, "_blank");
            });
          } catch (err) {
            console.error("Error opening Backup Files links:", err);
          }
        };

        // Auto-download backup on page unload
        useEffect(() => {
          const handleBeforeUnload = (e) => {
            handleBackupDownload();
            e.preventDefault();
            e.returnValue = "";
          };
          window.addEventListener("beforeunload", handleBeforeUnload);
          return () => {
            window.removeEventListener("beforeunload", handleBeforeUnload);
          };
        }, [
          groupType,
          studyIds,
          baselineVariables,
          outcomesVariables,
          inputValues,
          groupNames,
        ]);

        useEffect(() => {
          if (uploadedData) {
            setGroupType(uploadedData.groupType || "intervention");
            setStudyIds(uploadedData.studyIds || []);
            setBaselineVariables(uploadedData.baselineVariables || {});
            setOutcomesVariables(uploadedData.outcomesVariables || {});
            setInputValues((prevValues) => ({
              ...prevValues,
              ...uploadedData.inputValues,
            }));
            setGroupNames(
              uploadedData.groupNames || {
                interventionName: "Intervention",
                comparisonName: "Comparison",
              }
            );
            setCurrentScreen("variableInput");
          }
        }, [uploadedData]);

        return (
          <div className="max-w-7xl mx-auto px-4 md:px-6">
            {currentScreen === "home" && (
              <GroupSelectionScreen
                onSelectGroup={(type) => {
                  setGroupType(type);
                  setCurrentScreen("groupNaming");
                }}
                onUpload={() => {
                  setCurrentScreen("uploadDataset");
                }}
              />
            )}
            {currentScreen === "groupNaming" && (
              <GroupNamingScreen
                groupType={groupType}
                onSubmit={(names) => {
                  setGroupNames(names);
                  setCurrentScreen("studyIdInput");
                }}
                onBack={() => setCurrentScreen("home")}
              />
            )}
            {currentScreen === "uploadDataset" && (
              <UploadDatasetScreen
                onBack={() => setCurrentScreen("home")}
                onUpload={(data) => {
                  setUploadedData(data);
                }}
              />
            )}
            {currentScreen === "studyIdInput" && (
              <StudyIdInputScreen
                inputValues={inputValues}
                setInputValues={setInputValues}
                onSubmit={(ids) => {
                  setStudyIds(ids);
                  setCurrentScreen("variableInput");
                }}
                onBack={() => setCurrentScreen("groupNaming")}
                baselineVariables={baselineVariables}
                setBaselineVariables={setBaselineVariables}
                outcomesVariables={outcomesVariables}
                setOutcomesVariables={setOutcomesVariables}
                studyIds={studyIds}
                setStudyIds={setStudyIds}
              />
            )}

            {currentScreen === "variableInput" && (
              <VariableInputScreen
                studyIds={studyIds}
                baselineVariables={baselineVariables}
                setBaselineVariables={setBaselineVariables}
                outcomesVariables={outcomesVariables}
                setOutcomesVariables={setOutcomesVariables}
                groupType={groupType}
                groupNames={groupNames}
                selectedOption={selectedOption}
                setSelectedOption={setSelectedOption}
                onPreview={() => setCurrentScreen("preview")}
                onBack={() => setCurrentScreen("studyIdInput")}
                inputValues={inputValues}
                setInputValues={setInputValues}
              />
            )}
            {currentScreen === "preview" && (
              <PreviewScreen
                studyIds={studyIds}
                baselineVariables={baselineVariables}
                outcomesVariables={outcomesVariables}
                groupType={groupType}
                groupNames={groupNames}
                onBack={() => setCurrentScreen("variableInput")}
                onBackupDownload={handleBackupDownload}
              />
            )}
          </div>
        );
      }

      // GroupSelectionScreen Component
      function GroupSelectionScreen({ onSelectGroup, onUpload }) {
        return (
          <div>
            {/* Soft spotlight behind the headline */}
            <div className="absolute top-1/4 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[50vw] h-[50vh] bg-white/5 blur-3xl rounded-full opacity-10 pointer-events-none"></div>

            {/* Noise texture overlay */}
            <div className="pointer-events-none absolute inset-0 bg-noise-pattern opacity-5"></div>
            <div class="w-full text-center py-10">
              <h1 className="text-center text-4xl md:text-5xl font-extrabold tracking-tight mb-2 bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-400">
                Let’s Start the Data Extraction!
              </h1>
            </div>

            <p className="text-center text-gray-400 max-w-md mx-auto">
              Please select an option to start.
            </p>

            <div className="mt-10 w-full max-w-2xl mx-auto px-4">
              {/* Glassmorphism panel */}
              <div className="bg-white/5 backdrop-blur-md rounded-xl border border-white/10 p-6 shadow-lg">
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                  {/* Intervention (Magnifying Glass) */}
                  <button
                    onClick={() => onSelectGroup("intervention")}
                    className="relative w-full inline-flex items-center justify-center font-medium py-3 px-6 rounded border border-blue-400 text-gray-100 transition-transform transform hover:scale-105 hover:border-blue-300 focus:outline-none focus:ring-2 focus:ring-blue-500
                         hover:before:content-[''] hover:before:absolute hover:before:bottom-0 hover:before:left-0 hover:before:h-[2px] hover:before:w-full hover:before:bg-blue-400 hover:before:animate-underlineGlow"
                  >
                    <span className="mr-2 text-blue-300">
                      {/* Minimal line icon (magnifying glass) */}
                      <svg
                        width="16"
                        height="16"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="1.5"
                        className="inline-block align-middle"
                      >
                        <circle
                          cx="7"
                          cy="7"
                          r="5"
                          strokeLinecap="round"
                          strokeLinejoin="round"
                        />
                        <line
                          x1="11"
                          y1="11"
                          x2="15"
                          y2="15"
                          strokeLinecap="round"
                          strokeLinejoin="round"
                        />
                      </svg>
                    </span>
                    Intervention
                  </button>

                  {/* Intervention & Comparison (Crossed Swords) */}
                  <button
                    onClick={() => onSelectGroup("intervention_comparison")}
                    className="relative w-full inline-flex items-center justify-center font-medium py-3 px-6 rounded border border-green-400 text-gray-100 transition-transform transform hover:scale-105 hover:border-green-300 focus:outline-none focus:ring-2 focus:ring-green-500
                         hover:before:content-[''] hover:before:absolute hover:before:bottom-0 hover:before:left-0 hover:before:h-[2px] hover:before:w-full hover:before:bg-green-400 hover:before:animate-underlineGlow"
                  >
                    <span
                      className="mr-2 text-green-300 font-serif text-lg leading-none"
                      style={{ fontFamily: '"Times New Roman", serif' }}
                    >
                      {/* Use the Crossed Swords unicode character */}⚔
                    </span>
                    Intervention & Comparison
                  </button>

                  {/* Upload (Arrow) */}
                  <button
                    onClick={onUpload}
                    className="relative w-full inline-flex items-center justify-center font-medium py-3 px-6 rounded border border-purple-400 text-gray-100 transition-transform transform hover:scale-105 hover:border-purple-300 focus:outline-none focus:ring-2 focus:ring-purple-500
                         hover:before:content-[''] hover:before:absolute hover:before:bottom-0 hover:before:left-0 hover:before:h-[2px] hover:before:w-full hover:before:bg-purple-400 hover:before:animate-underlineGlow"
                  >
                    <span className="mr-2 text-purple-300">
                      {/* Minimal line icon (upload arrow) */}
                      <svg
                        width="16"
                        height="16"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="1.5"
                        className="inline-block align-middle"
                      >
                        <path
                          d="M8 2v10M5 5l3-3 3 3M2 14h12"
                          strokeLinecap="round"
                          strokeLinejoin="round"
                        />
                      </svg>
                    </span>
                    Upload a Dataset
                  </button>
                </div>
              </div>
              <div className="mt-6 flex justify-center">
                <button
                  onClick={() => {
                    if (
                      window.confirm(
                        "Are you sure you want to clear all data? This action cannot be undone."
                      )
                    ) {
                      localStorage.clear();
                      window.location.reload();
                    }
                  }}
                  className="relative inline-flex items-center justify-center font-medium py-3 px-6 rounded border border-red-400 text-gray-100 transition-transform transform hover:scale-105 hover:border-red-300 focus:outline-none focus:ring-2 focus:ring-red-500"
                >
                  <i className="fas fa-trash-alt mr-2"></i> Clear All Data
                </button>
              </div>
              <div className="mt-10 w-full max-w-2xl mx-auto px-4">
                <p>
                  <strong>Acknowledgements:</strong> This app was developed by
                  Marcos Antônio Dias Vilela (ORCID:{" "}
                  <a
                    href="https://orcid.org/0000-0001-9303-504X"
                    target="_blank"
                  >
                    0000-0001-9303-504X
                  </a>
                  , PubMed: Vilela MAD) at FAMERP (Faculdade de Medicina de São
                  José do Rio Preto). For inquiries, please contact{" "}
                  <a href="mailto:marcos.vilela@edu.famerp.br">
                    marcos.vilela@edu.famerp.br
                  </a>
                  .
                </p>
              </div>
            </div>

            <style jsx>{`
              .bg-noise-pattern {
                background-image: url('data:image/svg+xml,%3Csvg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg"%3E%3Crect width="1" height="1" fill="%23222222"/%3E%3C/svg%3E');
                background-size: 200px 200px;
              }

              @keyframes underlineGlow {
                0% {
                  transform: scaleX(0);
                }
                100% {
                  transform: scaleX(1);
                }
              }
              .hover\\:before\\:animate-underlineglow:hover:before {
                transform-origin: left center;
                animation: underlineGlow 0.3s ease forwards;
              }
            `}</style>
          </div>
        );
      }
      // GroupNamingScreen Component
      function GroupNamingScreen({ groupType, onSubmit, onBack }) {
        const [interventionName, setInterventionName] =
          useState("Intervention");
        const [comparisonName, setComparisonName] = useState("Comparison");

        const handleSubmit = () => {
          if (!interventionName.trim()) {
            alert("Please enter a name for the Intervention group.");
            return;
          }
          if (
            groupType === "intervention_comparison" &&
            !comparisonName.trim()
          ) {
            alert("Please enter a name for the Comparison group.");
            return;
          }
          onSubmit({
            interventionName: interventionName.trim(),
            comparisonName:
              groupType === "intervention_comparison"
                ? comparisonName.trim()
                : "",
          });
        };

        return (
          <div className="space-y-6">
            <h1 className="text-2xl font-bold">Name Your Groups</h1>
            <div className="space-y-4">
              <div>
                <label className="block font-semibold mb-2">
                  Intervention Group Name
                </label>
                <input
                  type="text"
                  value={interventionName}
                  onChange={(e) => setInterventionName(e.target.value)}
                  className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="Enter Intervention Group Name"
                />
              </div>
              {groupType === "intervention_comparison" && (
                <div>
                  <label className="block font-semibold mb-2">
                    Comparison Group Name
                  </label>
                  <input
                    type="text"
                    value={comparisonName}
                    onChange={(e) => setComparisonName(e.target.value)}
                    className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="Enter Comparison Group Name"
                  />
                </div>
              )}
            </div>
            <div className="flex flex-col md:flex-row justify-between mt-4 space-y-4 md:space-y-0">
              <button
                onClick={onBack}
                className="w-full md:w-auto bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
              >
                <i className="fas fa-arrow-left mr-2"></i> Back
              </button>
              <button
                onClick={handleSubmit}
                className="w-full md:w-auto bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
              >
                Next <i className="fas fa-arrow-right ml-2"></i>
              </button>
            </div>
          </div>
        );
      }

      // UploadDatasetScreen Component
      function UploadDatasetScreen({ onBack, onUpload }) {
        const [dragOver, setDragOver] = useState(false);

        const handleFileUpload = (file) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = JSON.parse(e.target.result);

              // NEW CODE: Restore the driveLinks from the backup file if present
              if (data.driveLinks) {
                localStorage.setItem(
                  "driveLinks",
                  JSON.stringify(data.driveLinks)
                );
              }

              // Then proceed with your existing onUpload
              onUpload(data);
            } catch (error) {
              alert("Invalid backup file.");
            }
          };
          reader.readAsText(file);
        };

        const handleDrop = (e) => {
          e.preventDefault();
          setDragOver(false);
          if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            const file = e.dataTransfer.files[0];
            handleFileUpload(file);
            e.dataTransfer.clearData();
          }
        };

        const handleDragOver = (e) => {
          e.preventDefault();
          setDragOver(true);
        };

        const handleDragLeave = (e) => {
          e.preventDefault();
          setDragOver(false);
        };

        const handleFileSelect = (e) => {
          if (e.target.files && e.target.files.length > 0) {
            const file = e.target.files[0];
            handleFileUpload(file);
          }
        };

        return (
          <div className="space-y-6">
            <h1 className="text-2xl font-bold">Upload Dataset Backup</h1>
            <div
              className={`border-4 ${
                dragOver ? "border-blue-500" : "border-gray-700"
              } border-dashed rounded-lg p-6 text-center cursor-pointer`}
              onDrop={handleDrop}
              onDragOver={handleDragOver}
              onDragLeave={handleDragLeave}
              onClick={() => document.getElementById("fileInput").click()}
            >
              <input
                type="file"
                id="fileInput"
                accept=".json"
                style={{ display: "none" }}
                onChange={handleFileSelect}
              />
              <p className="text-xl">
                {dragOver
                  ? "Drop the file here..."
                  : "Drag and drop a backup file here, or click to select a file"}
              </p>
            </div>
            <div className="flex justify-between mt-4">
              <button
                onClick={onBack}
                className="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
              >
                <i className="fas fa-arrow-left mr-2"></i> Back
              </button>
            </div>
          </div>
        );
      }

      // StudyIdInputScreen Component
      function StudyIdInputScreen({
        inputValues,
        setInputValues,
        onSubmit,
        onBack,
        baselineVariables,
        setBaselineVariables,
        outcomesVariables,
        setOutcomesVariables,
        studyIds,
        setStudyIds,
      }) {
        const [localStudyIds, setLocalStudyIds] = useState(studyIds);
        const [mode, setMode] = useState("paste"); // 'paste' or 'edit'
        const [studyIdFormatOption, setStudyIdFormatOption] =
          useState("Surname, Year");

        useEffect(() => {
          if (mode === "paste") {
            setInputValues((prevValues) => ({
              ...prevValues,
              studyIdInput: localStudyIds.join("\n"),
            }));
          } else {
            setLocalStudyIds(
              inputValues.studyIdInput
                .split("\n")
                .map((id) => id.trim())
                .filter((id) => id !== "")
            );
          }
        }, [mode]);

        const handleAddStudyId = () => {
          setLocalStudyIds([...localStudyIds, ""]);
        };

        const handleStudyIdChange = (index, value) => {
          const updatedStudyIds = [...localStudyIds];
          updatedStudyIds[index] = value;
          setLocalStudyIds(updatedStudyIds);
        };

        const handleRemoveStudyId = (index) => {
          const updatedStudyIds = [...localStudyIds];
          updatedStudyIds.splice(index, 1);
          setLocalStudyIds(updatedStudyIds);
        };

        const handleSubmit = () => {
          let trimmedIds = [];
          if (mode === "paste") {
            trimmedIds = inputValues.studyIdInput
              .split("\n")
              .map((id) => id.trim())
              .filter((id) => id !== "");
          } else {
            trimmedIds = localStudyIds
              .map((id) => id.trim())
              .filter((id) => id !== "");
          }

          if (trimmedIds.length > 0) {
            // Build a mapping from old IDs to new IDs
            const oldIds = studyIds;
            const updatedBaselineVariables = {};
            const updatedOutcomesVariables = {};

            // Create a mapping of old IDs to new IDs based on their positions
            const idMapping = {};
            oldIds.forEach((oldId, index) => {
              const newId = trimmedIds[index];
              if (newId && oldId !== newId) {
                // ID has changed at this position
                idMapping[oldId] = newId;
              } else if (newId === oldId) {
                // ID remains the same
                idMapping[oldId] = oldId;
              }
            });

            // Transfer variables based on idMapping
            Object.keys(baselineVariables).forEach((oldId) => {
              const newId = idMapping[oldId];
              if (newId) {
                updatedBaselineVariables[newId] = baselineVariables[oldId];
              }
            });

            Object.keys(outcomesVariables).forEach((oldId) => {
              const newId = idMapping[oldId];
              if (newId) {
                updatedOutcomesVariables[newId] = outcomesVariables[oldId];
              }
            });

            setBaselineVariables(updatedBaselineVariables);
            setOutcomesVariables(updatedOutcomesVariables);
            setStudyIds(trimmedIds);
            setInputValues((prevValues) => ({
              ...prevValues,
              studyIdInput: trimmedIds.join("\n"),
              selectedStudyId: trimmedIds.includes(prevValues.selectedStudyId)
                ? prevValues.selectedStudyId
                : trimmedIds[0],
            }));
            onSubmit(trimmedIds);
          } else {
            alert("Please enter at least one study ID.");
          }
        };

        const switchMode = () => {
          setMode(mode === "paste" ? "edit" : "paste");
        };

        const handleConvertToStudyIds = () => {
          // 1) Split the entire textarea content into lines.
          const lines = inputValues.studyIdInput.split("\n");
          const convertedIds = [];

          for (const originalLine of lines) {
            const line = originalLine.trim();
            // Skip empty lines
            if (!line) continue;

            // Process the line to build a single "Study ID"
            const newStudyId = processInputLine(line, studyIdFormatOption);
            // If processInputLine returned a non-empty ID, add it:
            if (newStudyId) {
              convertedIds.push(newStudyId);
            }
          }

          // Update the textarea with our newly converted IDs
          setInputValues({
            ...inputValues,
            studyIdInput: convertedIds.join("\n"),
          });
        };

        const processInputLine = (line, formatOption) => {
          /**
           * 1) Splits the line into columns (tab or 2+ spaces).
           * 2) Skips lines that look like "Author Year", "Authors Date", etc. (header lines).
           * 3) Detects a 4-digit year (19xx or 20xx) anywhere in the line.
           * 4) Splits authors on "and" or ";" to handle multiple authors.
           * 5) The first author is used to form the "baseName," appending "et al." if multiple authors exist.
           * 6) If there's a comma in the first author, treat as "Surname, GivenName."
           *    Otherwise treat it as "GivenName Surname."
           * 7) SPECIAL CASE for 'Surname, Year': if the parsed surname is an abbreviation (like "A." or "G."),
           *    we return "GivenName Surname, Year" instead of "Surname, Year."
           */

          // Split on tab or 2+ spaces and trim each piece
          const columns = line.split(/\t| {2,}/).map((col) => col.trim());
          if (columns.length < 2) {
            // Not enough columns => just skip
            return "";
          }

          // Convert columns to lowercase for easier comparisons
          const col0Lower = columns[0].toLowerCase();
          const col1Lower = columns[1].toLowerCase();

          // A set of keywords we consider "header-like"
          const headerKeywords = new Set(["year", "date", "author", "authors"]);

          // Skip if BOTH columns are among the header keywords (e.g. "authors year")
          if (headerKeywords.has(col0Lower) && headerKeywords.has(col1Lower)) {
            return "";
          }

          // Find a 4-digit year (19xx or 20xx) anywhere in the line
          let yearPart = "";
          const yearMatch = line.match(/\b(19|20)\d{2}\b/);
          if (yearMatch) {
            yearPart = yearMatch[0];
          }

          // Identify which column is authors vs. year (if one is exactly a 4-digit year, the other is authors)
          let authorsRaw = "";
          if (/^\d{4}$/.test(columns[0])) {
            // Column0 is the year, so Column1 is the authors
            authorsRaw = columns[1];
          } else if (/^\d{4}$/.test(columns[1])) {
            // Column1 is the year, so Column0 is the authors
            authorsRaw = columns[0];
          } else {
            // If neither column is purely a year, default to using the second column as authors
            // or whichever doesn't contain the found year
            if (yearPart && columns[1].includes(yearPart)) {
              authorsRaw = columns[0];
            } else {
              authorsRaw = columns[1];
            }
          }

          // Split authors on "and" or ";" to capture multiple authors
          const authorsList = authorsRaw
            .split(/\s+and\s+|;/)
            .map((a) => a.trim())
            .filter(Boolean);

          if (authorsList.length === 0) {
            // Couldn’t parse any author => skip
            return "";
          }

          // Focus on the first author
          const firstAuthor = authorsList[0];
          const hasMultipleAuthors = authorsList.length > 1;

          // Distinguish "Surname, GivenName" vs. "GivenName Surname"
          let surname = "";
          let givenName = "";
          if (firstAuthor.includes(",")) {
            // e.g. "Mantziaris, G."
            const parts = firstAuthor.split(",");
            surname = parts[0].trim();
            givenName = parts.slice(1).join(",").trim();
          } else {
            // e.g. "Pikis S"
            const nameParts = firstAuthor.split(" ").filter(Boolean);
            if (nameParts.length >= 2) {
              surname = nameParts[nameParts.length - 1];
              givenName = nameParts.slice(0, -1).join(" ");
            } else {
              // Single token => treat entire token as the surname
              surname = firstAuthor;
            }
          }

          // Helper to detect a "too short" or "abbreviated" surname (e.g. "A.", "G.")
          const isAbbreviatedSurname = (str) => {
            // Remove spaces to handle e.g. "A. B." (though typically we wouldn't see that as a 'surname')
            const cleaned = str.replace(/\s+/g, "");
            // Matches 1 or 2 letters, each optionally followed by a period => e.g. "A", "A.", "AB.", "A.B."
            return /^[A-Za-z](\.?[A-Za-z]\.?)?$/.test(cleaned);
          };

          // Build our "baseName" depending on the chosen format
          switch (formatOption) {
            case "Name Surname et al., Year": {
              const fullName = (givenName + " " + surname).trim();
              const baseName = hasMultipleAuthors
                ? `${fullName} et al.`
                : fullName;
              if (yearPart && formatOption !== "Surname, Year") {
                return `${baseName}, ${yearPart}`;
              }
              return baseName;
            }

            case "Surname, Name et al., Year": {
              const fullName = surname
                ? surname + (givenName ? ", " + givenName : "")
                : givenName;
              const baseName = hasMultipleAuthors
                ? `${fullName} et al.`
                : fullName;
              if (yearPart && formatOption !== "Surname, Year") {
                return `${baseName}, ${yearPart}`;
              }
              return baseName;
            }

            case "Surname, Year": {
              // SPECIAL CASE: If "surname" is too short or looks like an abbreviation,
              // use "GivenName Surname" instead of just "Surname".
              if (isAbbreviatedSurname(surname) && givenName) {
                // e.g. "John A." => "John A., 2023"
                const combined = `${givenName} ${surname}`.trim();
                if (yearPart) {
                  return `${combined}, ${yearPart}`;
                } else {
                  return combined;
                }
              } else {
                // Normal scenario: "Smith, 2023" or "Smith"
                if (yearPart) {
                  return `${surname}, ${yearPart}`;
                } else {
                  return surname;
                }
              }
            }

            default: {
              // Default to "Surname, Name et al., Year"
              const fullName = surname
                ? surname + (givenName ? ", " + givenName : "")
                : givenName;
              const baseName = hasMultipleAuthors
                ? `${fullName} et al.`
                : fullName;
              if (yearPart) {
                return `${baseName}, ${yearPart}`;
              }
              return baseName;
            }
          }
        };

        return (
          <div className="space-y-6">
            <h1 className="text-2xl font-bold">Enter Study IDs</h1>
            <div className="flex justify-between items-center">
              <p className="text-gray-400">
                {mode === "paste"
                  ? "Enter your data below."
                  : "Edit your study IDs below."}
              </p>
              <button
                onClick={switchMode}
                className="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
              >
                Switch to {mode === "paste" ? "Edit Mode" : "Paste Mode"}
              </button>
            </div>

            {mode === "paste" ? (
              <div>
                <textarea
                  value={inputValues.studyIdInput}
                  onChange={(e) =>
                    setInputValues({
                      ...inputValues,
                      studyIdInput: e.target.value,
                    })
                  }
                  rows="8"
                  className="w-full p-4 bg-gray-800 border border-gray-700 rounded-lg text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="Paste your data here..."
                ></textarea>
                <div className="mt-4 flex items-center">
                  <label className="mr-2 font-semibold">Study ID Format:</label>
                  <select
                    value={studyIdFormatOption}
                    onChange={(e) => setStudyIdFormatOption(e.target.value)}
                    className="p-2 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    <option value="Surname, Year">Surname, Year</option>
                    <option value="Name Surname et al., Year">
                      Name Surname et al., Year
                    </option>
                    <option value="Surname, Name et al., Year">
                      Surname, Name et al., Year
                    </option>
                  </select>
                  <button
                    onClick={handleConvertToStudyIds}
                    className="ml-4 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
                  >
                    Convert to Study IDs
                  </button>
                </div>
              </div>
            ) : (
              <div className="space-y-4">
                {localStudyIds.map((id, index) => (
                  <div key={index} className="flex items-center space-x-2">
                    <input
                      type="text"
                      value={id}
                      onChange={(e) =>
                        handleStudyIdChange(index, e.target.value)
                      }
                      className="flex-grow p-2 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                      placeholder={`Study ID ${index + 1}`}
                    />
                    <button
                      onClick={() => handleRemoveStudyId(index)}
                      className="text-red-500 hover:text-red-700"
                    >
                      <i className="fas fa-trash-alt"></i>
                    </button>
                  </div>
                ))}
                <button
                  onClick={handleAddStudyId}
                  className="mt-2 bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
                >
                  <i className="fas fa-plus mr-2"></i> Add Study ID
                </button>
              </div>
            )}

            <div className="flex flex-col md:flex-row justify-between mt-4 space-y-4 md:space-y-0">
              <button
                onClick={onBack}
                className="w-full md:w-auto bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
              >
                <i className="fas fa-arrow-left mr-2"></i> Back
              </button>
              <button
                onClick={handleSubmit}
                className="w-full md:w-auto bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
              >
                Next <i className="fas fa-arrow-right ml-2"></i>
              </button>
            </div>
          </div>
        );
      }
      function CalculadoraEstimativas() {
        const [metodo, setMetodo] = useState("Cenario1");
        const [inputs, setInputs] = useState({});
        const [resultado, setResultado] = useState({ meanOur: 0, sdOur: 0 });
        const [historico, setHistorico] = useState([]);
        const [isModalOpen, setIsModalOpen] = useState(false);
        const [isFormattingModalOpen, setIsFormattingModalOpen] =
          useState(false);
        const [isRevManModalOpen, setIsRevManModalOpen] = useState(false);
        const [mean, setMean] = useState("");
        const [sd, setSd] = useState("");
        const [formattedResult, setFormattedResult] = useState("");
        const [referenciaCopiada, setReferenciaCopiada] = useState(false);
        const [intervencao, setIntervencao] = useState([""]);
        const [controle, setControle] = useState([""]);
        const [planilhaOrganizada, setPlanilhaOrganizada] = useState(null);
        const [intervencaoTotal, setIntervencaoTotal] = useState([]);
        const [controleTotal, setControleTotal] = useState([]);
        const [autores, setAutores] = useState([""]);
        const [botaoCopiado, setBotaoCopiado] = useState(false);

        const handleInputChange = (e) => {
          const { name, value } = e.target;
          setInputs({ ...inputs, [name]: value });
        };

        const handlePaste = (e) => {
          const paste = e.clipboardData.getData("text").trim();

          // Regex to match the format of "median min max" (e.g., "20 10 30")
          const regex = /(\d+\.?\d*)[^0-9]*(\d+\.?\d*)[^0-9]*(\d+\.?\d*)/;
          const match = paste.match(regex);

          // If the pattern matches (i.e., three valid numbers)
          if (match) {
            const [_, median, min, max] = match.map(Number);

            // Handle the logic based on the selected 'metodo'
            if (metodo === "Cenario1") {
              setInputs({
                ...inputs,
                min: String(min),
                median: String(median),
                max: String(max),
              });
            } else if (metodo === "Cenario3") {
              setInputs({
                ...inputs,
                q1: String(min),
                median: String(median),
                q3: String(max),
              });
            }
            e.preventDefault(); // Prevent default paste action if match is found
          } else {
            // Handle pasting a single value and updating only the "min" field
            const singleValueRegex = /^(\d+\.?\d*)$/; // Regex to match a single numeric value
            const singleValueMatch = paste.match(singleValueRegex);

            if (singleValueMatch) {
              const value = singleValueMatch[1];

              // Check if we're pasting into the "min" field and update it
              if (e.target.name === "min") {
                setInputs({
                  ...inputs,
                  min: value, // Only update "min" field with the pasted value
                });
              }

              // Check if we're pasting into the "median" field and update it
              if (e.target.name === "median") {
                setInputs({
                  ...inputs,
                  median: value, // Only update "median" field with the pasted value
                });
              }

              // Check if we're pasting into the "max" field and update it
              if (e.target.name === "max") {
                setInputs({
                  ...inputs,
                  max: value, // Only update "max" field with the pasted value
                });
              }

              e.preventDefault(); // Prevent default paste action for single values
            } else {
              // If the paste doesn't match the expected pattern, ignore it
              console.log("Invalid or unsupported paste value:", paste);
              e.preventDefault(); // Prevent default paste action for invalid inputs
            }
          }
        };

        const calcular = () => {
          const val = (key) => parseFloat(inputs[key]);
          let meanOur = 0;
          let sdOur = 0;

          // Keep the calculation exactly the same as original!
          switch (metodo) {
            case "Cenario1":
              meanOur = (val("min") + 2 * val("median") + val("max")) / 4;
              sdOur =
                (val("max") - val("min")) /
                (2 * normInv((val("n") - 0.375) / (val("n") + 0.25)));
              console.log("sdOur antes do arredondamento:", sdOur);
              break;
            case "Cenario2":
              meanOur =
                (val("min") +
                  2 * val("q1") +
                  2 * val("median") +
                  2 * val("q3") +
                  val("max")) /
                8;
              sdOur =
                (val("max") - val("min")) /
                  (4 * normInv((val("n") - 0.375) / (val("n") + 0.25))) +
                (val("q3") - val("q1")) /
                  (4 * normInv((0.75 * val("n") - 0.125) / (val("n") + 0.25)));
              break;
            case "Cenario3":
              meanOur = (val("q1") + val("median") + val("q3")) / 3;
              sdOur =
                (val("q3") - val("q1")) /
                (2 * normInv((0.75 * val("n") - 0.125) / (val("n") + 0.25)));
              break;
            default:
              break;
          }

          // Truncate to four decimals
          const truncateToFourDecimals = (num) =>
            Math.floor(num * 10000) / 10000;
          setResultado({
            meanOur: truncateToFourDecimals(meanOur),
            sdOur: truncateToFourDecimals(sdOur),
          });
          setHistorico([
            ...historico,
            {
              meanOur: truncateToFourDecimals(meanOur),
              sdOur: truncateToFourDecimals(sdOur),
              label: "",
              formatted: false,
            },
          ]);
        };

        const normInv = (p) => {
          return Math.sqrt(2) * erfInv(2 * p - 1);
        };
        const erfInv = (x) => {
          const a = 0.147;
          const ln = Math.log(1 - x * x);
          const tt1 = 2 / (Math.PI * a) + ln / 2;
          const tt2 = (1 / a) * ln;
          const sqrt1 = Math.sqrt(tt1 * tt1 - tt2);
          return Math.sign(x) * Math.sqrt(sqrt1 - tt1);
        };

        const copiarReferencia = () => {
          const referencia =
            "Wan, X., Wang, W., Liu, J. et al. Estimating the sample mean and standard deviation from the sample size, median, range and/or interquartile range. BMC Med Res Methodol 14, 135 (2014). https://doi.org/10.1186/1471-2288-14-135";
          const tempInput = document.createElement("textarea");
          tempInput.value = referencia;
          document.body.appendChild(tempInput);
          tempInput.select();
          document.execCommand("copy");
          document.body.removeChild(tempInput);
          setReferenciaCopiada(true);
          setTimeout(() => setReferenciaCopiada(false), 2000);
        };

        const handleLabelChange = (index, label) => {
          const novoHistorico = [...historico];
          novoHistorico[index].label = label;
          setHistorico(novoHistorico);
        };

        const handleFormattingPaste = (e) => {
          const paste = e.clipboardData.getData("text");
          let meanValue = "";
          let sdValue = "";

          if (paste.includes("(") && paste.includes(")")) {
            const [meanStr, sdStr] = paste.split(" ");
            meanValue = parseFloat(meanStr.replace(",", "."));
            sdValue = parseFloat(sdStr.slice(1, -1).replace(",", "."));
          } else if (paste.includes(" ")) {
            const [meanStr, sdStr] = paste.split(" ");
            meanValue = parseFloat(meanStr.replace(",", "."));
            sdValue = parseFloat(sdStr.replace(",", "."));
          } else if (paste.includes("\t")) {
            const [meanStr, sdStr] = paste.split("\t");
            meanValue = parseFloat(meanStr.replace(",", "."));
            sdValue = parseFloat(sdStr.replace(",", "."));
          }

          if (meanValue && sdValue) {
            setMean(meanValue);
            setSd(sdValue);
            e.preventDefault();
          }
        };

        const formatar = () => {
          if (mean && sd) {
            // Format with 4 decimals
            const formatted = `${parseFloat(mean).toFixed(4)} ± ${parseFloat(
              sd
            ).toFixed(4)} [mean]`;
            setFormattedResult(formatted);

            setHistorico([
              ...historico,
              {
                meanOur: parseFloat(mean.toString()),
                sdOur: parseFloat(sd.toString()),
                label: "",
                formatted: true,
                result: formatted,
              },
            ]);
          }
        };

        const handleRevManPaste = (e) => {
          const paste = e.clipboardData.getData("text");
          const linhas = paste
            .split("\n")
            .map((l) => l.trim())
            .filter((l) => l !== "");
          let intervencaoData = [];
          let controleData = [];

          if (linhas.length > 0) {
            if (linhas[0].includes("\t")) {
              linhas.forEach((linha) => {
                const [interData, contData] = linha.split("\t");
                intervencaoData.push(interData);
                controleData.push(contData);
              });
            } else {
              intervencaoData = linhas.slice(0, Math.floor(linhas.length / 2));
              controleData = linhas.slice(Math.floor(linhas.length / 2));
            }
          }

          setIntervencao(intervencaoData);
          setControle(controleData);
          e.preventDefault();
        };

        const organizarPlanilha = () => {
          const organizarColunas = (dados, totais) => {
            const regexList = [
              /^(\d+\.?\d*)\s*±\s*(\d+\.?\d*)\s*\[mean\]$/,
              /^(\d+\.?\d*)\s*±\s*(\d+\.?\d*)$/,
              /^(\d+\.?\d*)\s*\(\s*±\s*(\d+\.?\d*)\)$/,
              /^(\d+\.?\d*)\s*\(\s*(\d+\.?\d*)\)$/,
              /^(\d+\.?\d*)\s*±\s*(\d+\.?\d*)\;$/,
              /^(\d+\.?\d*)\s+(\d+\.?\d*)$/,
              /^(\d+\.?\d*)\s*\/\s*(\d+\.?\d*)$/,
              /^(\d+\.?\d*)\s*\(\+\-\s*(\d+\.?\d*)\)$/,
              /^(\d+\.?\d*)\s*\(\s*(\d+\.?\d*)\s*SD\)$/,
              /^(\d+\.?\d*)±(\d+\.?\d*)$/,
            ];

            return dados.map((dado, index) => {
              let mean = null;
              let sd = null;
              for (let regex of regexList) {
                const match = dado.match(regex);
                if (match) {
                  mean = parseFloat(match[1]);
                  sd = parseFloat(match[2]);
                  break;
                }
              }
              if (mean !== null && sd !== null) {
                return {
                  mean,
                  sd,
                  total: totais[index] ? parseFloat(totais[index]) : "",
                };
              } else {
                return { mean: "", sd: "", total: "" };
              }
            });
          };

          const intervencaoOrganizada = organizarColunas(
            intervencao,
            intervencaoTotal
          );
          const controleOrganizada = organizarColunas(controle, controleTotal);

          const calcularMediaPonderada = (dados) => {
            const totalPopulacao = dados.reduce(
              (sum, row) => sum + (row.total || 0),
              0
            );
            const mediaPonderada =
              dados.reduce((sum, row) => sum + (row.mean * row.total || 0), 0) /
              totalPopulacao;
            return totalPopulacao > 0 ? mediaPonderada : "";
          };

          const mediaPonderadaIntervencao = calcularMediaPonderada(
            intervencaoOrganizada
          );
          const mediaPonderadaControle =
            calcularMediaPonderada(controleOrganizada);

          let organizada = intervencaoOrganizada.map((inter, idx) => {
            const controle = controleOrganizada[idx] || {};
            const linhaValida =
              inter.mean ||
              inter.sd ||
              inter.total ||
              controle.mean ||
              controle.sd ||
              controle.total;
            return linhaValida
              ? [
                  autores[idx] || "",
                  inter.mean,
                  inter.sd,
                  inter.total,
                  controle.mean || "",
                  controle.sd || "",
                  controle.total || "",
                ]
              : [
                  "",
                  inter.mean,
                  inter.sd,
                  inter.total,
                  controle.mean || "",
                  controle.sd || "",
                  controle.total || "",
                ];
          });

          organizada.push([
            "Weighted Mean",
            mediaPonderadaIntervencao
              ? mediaPonderadaIntervencao.toFixed(2)
              : "",
            "",
            "",
            mediaPonderadaControle ? mediaPonderadaControle.toFixed(2) : "",
          ]);

          setPlanilhaOrganizada(organizada);
          setIsRevManModalOpen(false);
        };

        const copiarPlanilha = () => {
          if (planilhaOrganizada) {
            const planilhaSemMediasPonderadas = planilhaOrganizada.slice(0, -1);
            const planilhaSemLinhasVazias = planilhaSemMediasPonderadas.filter(
              (row) => row.slice(1).some((cell) => cell !== "")
            );

            let textoParaCopiar = planilhaSemLinhasVazias
              .map((row) => row.slice(1).join("\t"))
              .join("\n");

            const tempTextArea = document.createElement("textarea");
            tempTextArea.value = textoParaCopiar;
            document.body.appendChild(tempTextArea);

            tempTextArea.select();
            try {
              document.execCommand("copy");
              setBotaoCopiado(true);
              setTimeout(() => setBotaoCopiado(false), 2000);
            } catch (err) {
              alert("Falha ao copiar os dados.");
            }

            document.body.removeChild(tempTextArea);
          }
        };

        useEffect(() => {
          const copyButton = document.querySelector(".copy-button");
          if (copyButton) {
            copyButton.addEventListener("click", copiarPlanilha);
          }
        }, [planilhaOrganizada]);

        return (
          <div className="w-full max-w-md relative z-10">
            <div className="mb-4">
              <label className="block text-sm font-bold mb-2">
                Select Method:
              </label>
              <select
                value={metodo}
                onChange={(e) => setMetodo(e.target.value)}
                className="block w-full p-2 rounded"
              >
                <option value="Cenario1">
                  Scenario 1 (minimum, median, maximum)
                </option>
                <option value="Cenario2">
                  Scenario 2 (minimum, 1st quartile, median, 3rd quartile,
                  maximum)
                </option>
                <option value="Cenario3">
                  Scenario 3 (1st quartile, median, 3rd quartile)
                </option>
              </select>
            </div>

            {metodo === "Cenario1" && (
              <div>
                <input
                  type="number"
                  step="any"
                  name="min"
                  placeholder="Minimum"
                  onChange={handleInputChange}
                  onPaste={handlePaste}
                  value={inputs.min || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="median"
                  placeholder="Median"
                  onChange={handleInputChange}
                  value={inputs.median || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="max"
                  placeholder="Maximum"
                  onChange={handleInputChange}
                  value={inputs.max || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="n"
                  placeholder="Sample Size"
                  onChange={handleInputChange}
                  value={inputs.n || ""}
                  className="block w-full p-2 rounded mb-2"
                />
              </div>
            )}

            {metodo === "Cenario2" && (
              <div>
                <input
                  type="number"
                  step="any"
                  name="min"
                  placeholder="Minimum"
                  onChange={handleInputChange}
                  value={inputs.min || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="q1"
                  placeholder="1st quartile"
                  onChange={handleInputChange}
                  value={inputs.q1 || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="median"
                  placeholder="Median"
                  onChange={handleInputChange}
                  value={inputs.median || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="q3"
                  placeholder="3rd quartile"
                  onChange={handleInputChange}
                  value={inputs.q3 || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="max"
                  placeholder="Maximum"
                  onChange={handleInputChange}
                  value={inputs.max || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="n"
                  placeholder="Sample Size"
                  onChange={handleInputChange}
                  value={inputs.n || ""}
                  className="block w-full p-2 rounded mb-2"
                />
              </div>
            )}

            {metodo === "Cenario3" && (
              <div>
                <input
                  type="number"
                  step="any"
                  name="q1"
                  placeholder="1st quartile"
                  onChange={handleInputChange}
                  onPaste={handlePaste}
                  value={inputs.q1 || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="median"
                  placeholder="Median"
                  onChange={handleInputChange}
                  value={inputs.median || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="q3"
                  placeholder="3rd quartile"
                  onChange={handleInputChange}
                  value={inputs.q3 || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="n"
                  placeholder="Sample Size"
                  onChange={handleInputChange}
                  value={inputs.n || ""}
                  className="block w-full p-2 rounded mb-2"
                />
              </div>
            )}

            <div className="flex space-x-4 mt-4">
              <button
                onClick={calcular}
                className="bg-blue-500 text-white p-2 rounded"
              >
                Calculate
              </button>
              <button
                onClick={() => setIsFormattingModalOpen(true)}
                className="bg-yellow-500 text-white p-2 rounded"
              >
                Formatting
              </button>
              <button
                onClick={() => setIsRevManModalOpen(true)}
                className="bg-purple-500 text-white p-2 rounded"
              >
                RevMan
              </button>
            </div>
            <div className="mt-4">
              <p>
                <strong>Result:</strong>
                <br />
                {resultado.meanOur.toFixed(4)} ± {resultado.sdOur.toFixed(4)}
              </p>
            </div>

            <div className="flex space-x-4 mt-4">
              <button
                onClick={copiarReferencia}
                className="bg-green-500 text-white p-2 rounded"
              >
                {referenciaCopiada ? "Reference Copied!" : "Copy Reference"}
              </button>
              <button
                onClick={() => setIsModalOpen(true)}
                className="bg-purple-500 text-white p-2 rounded"
              >
                View History
              </button>
            </div>

            {isModalOpen && (
              <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 modal-bg">
                <div className="bg-gray-800 p-6 rounded-lg w-1/3">
                  <h2 className="text-lg font-bold mb-4">
                    Calculation History
                  </h2>
                  <ul className="max-h-96 overflow-y-auto">
                    {historico.map((item, index) => (
                      <li
                        key={index}
                        className="mb-2 flex items-center space-x-2"
                      >
                        <input
                          type="text"
                          placeholder="Name Result"
                          value={item.label}
                          onChange={(e) =>
                            handleLabelChange(index, e.target.value)
                          }
                          className="p-2 rounded flex-grow"
                        />
                        <span>
                          {item.formatted
                            ? item.result
                            : `${item.meanOur.toFixed(
                                4
                              )} ± ${item.sdOur.toFixed(4)}`}
                        </span>
                      </li>
                    ))}
                  </ul>
                  <button
                    onClick={() => setIsModalOpen(false)}
                    className="bg-red-500 text-white p-2 rounded mt-4 w-full"
                  >
                    Close
                  </button>
                </div>
              </div>
            )}

            {isFormattingModalOpen && (
              <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 modal-bg">
                <div className="bg-gray-800 p-6 rounded-lg w-1/3">
                  <h2 className="text-lg font-bold mb-4">Results Formatting</h2>
                  <div className="mb-4">
                    <label className="block text-sm font-bold mb-2">
                      Mean:
                    </label>
                    <input
                      type="number"
                      step="any"
                      value={mean}
                      onChange={(e) => setMean(e.target.value)}
                      onPaste={handleFormattingPaste}
                      className="block w-full p-2 rounded"
                    />
                  </div>
                  <div className="mb-4">
                    <label className="block text-sm font-bold mb-2">
                      Standard Deviation:
                    </label>
                    <input
                      type="number"
                      step="any"
                      value={sd}
                      onChange={(e) => setSd(e.target.value)}
                      onPaste={handleFormattingPaste}
                      className="block w-full p-2 rounded"
                    />
                  </div>
                  <button
                    onClick={formatar}
                    className="bg-blue-500 text-white p-2 rounded w-full mb-4"
                  >
                    Format
                  </button>
                  {formattedResult && (
                    <div className="bg-gray-700 p-4 rounded">
                      <p>
                        <strong>Format:</strong> {formattedResult}
                      </p>
                    </div>
                  )}
                  <button
                    onClick={() => setIsFormattingModalOpen(false)}
                    className="bg-red-500 text-white p-2 rounded w-full"
                  >
                    Close
                  </button>
                </div>
              </div>
            )}

            {isRevManModalOpen && (
              <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 modal-bg">
                <div className="bg-gray-800 p-6 rounded-lg w-3/4">
                  <h2 className="text-lg font-bold mb-4">RevMan</h2>
                  <div className="flex space-x-4">
                    <div className="w-1/2">
                      <h3 className="text-sm font-bold mb-2">
                        Intervention Group
                      </h3>
                      <textarea
                        value={intervencao.join("\n")}
                        onPaste={(e) => {
                          e.preventDefault();
                          const pasteData = e.clipboardData
                            .getData("text")
                            .split("\n")
                            .map((v) => v.trim());
                          setIntervencao(pasteData);
                        }}
                        onChange={(e) =>
                          setIntervencao(
                            e.target.value.split("\n").map((v) => v.trim())
                          )
                        }
                        placeholder="Paste the mean ± standard deviation values for the Intervention group."
                        className="w-full p-2 rounded mb-4 h-32"
                      />
                      <textarea
                        placeholder="Paste the total number of patients for Intervention."
                        value={intervencaoTotal.join("\n")}
                        onChange={(e) =>
                          setIntervencaoTotal(
                            e.target.value.split("\n").map((v) => v.trim())
                          )
                        }
                        className="w-full p-2 rounded mb-4 h-16"
                      />
                      <label className="block text-sm font-bold mb-2">
                        Study IDs
                      </label>
                      <textarea
                        placeholder="Author et al., Year"
                        value={autores.join("\n")}
                        onPaste={(e) => {
                          e.preventDefault();
                          const pasteData = e.clipboardData
                            .getData("text")
                            .split("\n")
                            .map((v) => v.trim());
                          setAutores(pasteData);
                        }}
                        onChange={(e) =>
                          setAutores(
                            e.target.value.split("\n").map((v) => v.trim())
                          )
                        }
                        className="w-full p-2 rounded mb-4 h-32"
                      />
                    </div>
                    <div className="w-1/2">
                      <h3 className="text-sm font-bold mb-2">Control Group</h3>
                      <textarea
                        value={controle.join("\n")}
                        onPaste={(e) => {
                          e.preventDefault();
                          const pasteData = e.clipboardData
                            .getData("text")
                            .split("\n")
                            .map((v) => v.trim());
                          setControle(pasteData);
                        }}
                        onChange={(e) =>
                          setControle(
                            e.target.value.split("\n").map((v) => v.trim())
                          )
                        }
                        placeholder="Paste the mean ± standard deviation values for the Control group."
                        className="w-full p-2 rounded mb-4 h-32"
                      />
                      <textarea
                        placeholder="Paste the total number of patients for Control."
                        value={controleTotal.join("\n")}
                        onChange={(e) =>
                          setControleTotal(
                            e.target.value.split("\n").map((v) => v.trim())
                          )
                        }
                        className="w-full p-2 rounded mb-4 h-16"
                      />
                    </div>
                  </div>
                  <button
                    onClick={organizarPlanilha}
                    className="bg-blue-500 text-white p-2 rounded w-full mb-4"
                  >
                    Organize
                  </button>
                  <button
                    onClick={() => setIsRevManModalOpen(false)}
                    className="bg-red-500 text-white p-2 rounded w-full"
                  >
                    Close
                  </button>
                </div>
              </div>
            )}

            {planilhaOrganizada && (
              <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 modal-bg z-50">
                <div className="bg-gray-800 p-6 rounded-lg w-3/4 max-h-full overflow-auto">
                  <div className="flex justify-between items-center mb-4">
                    <h2 className="text-lg font-bold">
                      RevMan Continuous Variables Spreadsheet
                    </h2>
                    <button
                      onClick={copiarPlanilha}
                      className="bg-green-500 text-white p-2 rounded copy-button"
                    >
                      {botaoCopiado ? "Copied!" : "Copy"}
                    </button>
                  </div>
                  <table className="w-full">
                    <thead>
                      <tr>
                        {autores.length > 0 && (
                          <th className="p-2">Study ID</th>
                        )}
                        <th className="p-2">Mean (Intervention)</th>
                        <th className="p-2">
                          Standard Deviation (Intervention)
                        </th>
                        <th className="p-2">Total (Intervention)</th>
                        <th className="p-2">Mean (Control)</th>
                        <th className="p-2">Standard Deviation (Control)</th>
                        <th className="p-2">Total (Control)</th>
                      </tr>
                    </thead>
                    <tbody>
                      {planilhaOrganizada.map((row, index) => (
                        <tr key={index}>
                          {row.map((cell, cellIndex) => (
                            <td key={cellIndex} className="p-2">
                              {cell}
                            </td>
                          ))}
                        </tr>
                      ))}
                    </tbody>
                  </table>
                  <button
                    onClick={() => setPlanilhaOrganizada(null)}
                    className="bg-red-500 text-white p-2 rounded mt-4 w-full"
                  >
                    Close
                  </button>
                </div>
              </div>
            )}
          </div>
        );
      }
      // VariableInputScreen Component
      function VariableInputScreen({
        studyIds,
        baselineVariables,
        setBaselineVariables,
        outcomesVariables,
        setOutcomesVariables,
        groupType,
        groupNames,
        selectedOption,
        setSelectedOption,
        onPreview,
        onBack,
        inputValues,
        setInputValues,
      }) {
        const [showAlert, setShowAlert] = useState(false);
        const [editVariableId, setEditVariableId] = useState(null);

        // New state for Import Data modal
        const [isImportModalOpen, setIsImportModalOpen] = useState(false);
        const [importVariableType, setImportVariableType] =
          useState("dichotomous");
        const [importArmType, setImportArmType] = useState(
          groupType === "intervention_comparison" ? "double" : "single"
        );
        const [importDataText, setImportDataText] = useState("");
        // New state variables for Spreadsheet Mode
        const [isSpreadsheetMode, setIsSpreadsheetMode] = useState(false);
        const [spreadsheetData, setSpreadsheetData] = useState([]);
        // New state for delete confirmation modal
        const [variableToDelete, setVariableToDelete] = useState(null);
        const [showDeleteModal, setShowDeleteModal] = useState(false);
        const [focusedCell, setFocusedCell] = useState(null);
        const [hoveredRowIndex, setHoveredRowIndex] = useState(null);
        const [hoveredColIndex, setHoveredColIndex] = useState(null);

        const variables =
          selectedOption === "baseline" ? baselineVariables : outcomesVariables;
        const setVariables =
          selectedOption === "baseline"
            ? setBaselineVariables
            : setOutcomesVariables;

        // Add these near your existing state declarations:
        const [isCalculadoraModalOpen, setIsCalculadoraModalOpen] =
          useState(false);
        const [interventionPopSize, setInterventionPopSize] = useState("");
        const [comparisonPopSize, setComparisonPopSize] = useState("");
        // --- SNIPPET 1: Add these near the top of VariableInputScreen ---
        const [isMultipleVarModalOpen, setIsMultipleVarModalOpen] =
          useState(false);
        const [multiVarChoice, setMultiVarChoice] = useState({
          dataOption: "baseline", // or 'outcomes'
          variableType: "dichotomous", // or 'continuous' / 'text'
          armType:
            groupType === "intervention_comparison" ? "double" : "single",
        });
        const [multiVarText, setMultiVarText] = useState("");
        const [allVariableSuggestions, setAllVariableSuggestions] = useState(
          []
        );

        // Handler to open/close the modal
        const openMultiVarModal = () => setIsMultipleVarModalOpen(true);
        const closeMultiVarModal = () => setIsMultipleVarModalOpen(false);

        // Function to handle dropdown changes (data option, variable type, arm type)
        const handleMultiVarChange = (field, value) => {
          setMultiVarChoice((prev) => ({ ...prev, [field]: value }));
        };

        // ...
        // This function parses the user's multiVarText and adds multiple variables at once
        const handleAddMultipleVariables = () => {
          if (!multiVarText.trim()) {
            alert("Please enter some variable names to add.");
            return;
          }

          // 1) Split on commas, tabs, or newlines
          const names = multiVarText
            .split(/[\n\t,]+/)
            .map((nm) => nm.trim())
            .filter(Boolean);

          // 2) Merge these new names into our 'allVariableSuggestions' array
          setAllVariableSuggestions((prev) => {
            const merged = [...prev, ...names];
            // Deduplicate
            return [...new Set(merged)];
          });

          // 3) Also store them in localStorage
          //    (for example, under the key 'multipleVarSuggestions')
          try {
            // Retrieve any existing suggestions from localStorage
            const oldData =
              JSON.parse(localStorage.getItem("multipleVarSuggestions")) || [];
            const mergedData = [...oldData, ...names];
            // Deduplicate
            const uniqueData = [...new Set(mergedData)];
            localStorage.setItem(
              "multipleVarSuggestions",
              JSON.stringify(uniqueData)
            );
          } catch (err) {
            console.error(
              "Failed to store multipleVarSuggestions in localStorage",
              err
            );
          }

          // 4) Clear the text and close
          setMultiVarText("");
          closeMultiVarModal();
        };

        useEffect(() => {
          // Retrieve suggestions from localStorage at startup
          const storedSuggestions =
            JSON.parse(localStorage.getItem("multipleVarSuggestions")) || [];
          if (storedSuggestions.length > 0) {
            setAllVariableSuggestions((prev) => {
              // Merge with any hardcoded or previously set suggestions
              const merged = [...prev, ...storedSuggestions];
              return [...new Set(merged)];
            });
          }
        }, []);

        // Functions to open/close the calculator modal
        const openCalculadoraModal = () => {
          setIsCalculadoraModalOpen(true);
        };
        const closeCalculadoraModal = () => {
          setIsCalculadoraModalOpen(false);
        };

        // New suggestions for single-arm or double-arm baseline data
        const additionalBaselineSuggestions = [
          "Population Size", // dichotomous
          "Male", // dichotomous
          "Female", // dichotomous
          "Age", // continuous
          "Follow-Up", // continuous
        ];

        const existingVariableLabelsSet = new Set();
        Object.values(variables).forEach((studyVars) => {
          studyVars.forEach((variable) => {
            existingVariableLabelsSet.add(variable.label);
          });
        });
        const existingVariableLabels = Array.from(existingVariableLabelsSet);

        // Merge user-supplied variable suggestions too
        let allLabels = [...existingVariableLabels, ...allVariableSuggestions];

        if (selectedOption === "baseline") {
          // Also merge the baseline suggestions
          allLabels = [
            ...allLabels,
            ...suggestedBaselineLabels,
            ...additionalBaselineSuggestions,
          ];
        }

        // Now remove duplicates
        allLabels = [...new Set(allLabels)];

        const allVariableLabels = allLabels;

        /***********************************************
         * HANDLE CHANGES IN THE VARIABLE LABEL FIELD
         ***********************************************/
        const handleVariableLabelChange = (e) => {
          const newLabel = e.target.value;
          const newLabelLower = newLabel.toLowerCase();

          // Update our inputValues with the new label text
          setInputValues((prevValues) => ({
            ...prevValues,
            variableLabel: newLabel,
          }));

          // Check if the user’s typed label matches any existing variable
          let matchedVariable = null;
          outerLoop: for (let studyVars of Object.values(variables)) {
            for (let variable of studyVars) {
              if (variable.label.toLowerCase() === newLabelLower) {
                matchedVariable = variable;
                break outerLoop;
              }
            }
          }

          if (matchedVariable) {
            // If it matches an existing variable, use the same type & arm
            setInputValues((prevValues) => ({
              ...prevValues,
              variableLabel: matchedVariable.label,
              variableType: matchedVariable.type,
              variableValue: {},
              variableArmType: matchedVariable.armType || "single",
            }));
          }
          // If user typed one of the built-in baseline labels (e.g. “Country”), treat as text
          else if (
            suggestedBaselineLabels
              .map((lbl) => lbl.toLowerCase())
              .includes(newLabelLower) &&
            selectedOption === "baseline"
          ) {
            const originalSuggestedLabel = suggestedBaselineLabels.find(
              (lbl) => lbl.toLowerCase() === newLabelLower
            );
            setInputValues((prevValues) => ({
              ...prevValues,
              variableLabel: originalSuggestedLabel,
              variableType: "text",
              variableValue: {},
              variableArmType: "single",
            }));
          }
          // If user typed something like “Population Size,” “Age,” or “Follow-Up”
          else if (
            selectedOption === "baseline" &&
            additionalBaselineSuggestions
              .map((lbl) => lbl.toLowerCase())
              .includes(newLabelLower)
          ) {
            let determinedType = "dichotomous";

            // For “Population Size,” we handle it as “population_size”
            if (newLabelLower === "population size") {
              determinedType = "population_size";
            }
            // For “Age” or “Follow-Up,” treat as continuous
            else if (newLabelLower === "age" || newLabelLower === "follow-up") {
              determinedType = "continuous";
            }

            // If we have two arms, treat as double; otherwise single
            const armType =
              groupType === "intervention_comparison" ? "double" : "single";

            setInputValues((prevValues) => ({
              ...prevValues,
              variableLabel: newLabel,
              variableType: determinedType,
              variableValue: {},
              variableArmType: armType,
            }));
          }
          // Otherwise default to a typical dichotomous variable
          else {
            const armType =
              groupType === "intervention_comparison" ? "double" : "single";

            setInputValues((prevValues) => ({
              ...prevValues,
              variableLabel: newLabel,
              variableType: "dichotomous",
              variableValue: {},
              variableArmType: armType,
            }));
          }
        };

        const isSinglePlaceholder =
          selectedOption === "baseline" &&
          suggestedBaselineLabels.includes(inputValues.variableLabel);

        // Ensure selectedStudyId is set to the first study ID if it's empty
        useEffect(() => {
          if (!inputValues.selectedStudyId && studyIds.length > 0) {
            setInputValues((prevValues) => ({
              ...prevValues,
              selectedStudyId: studyIds[0],
            }));
          }
        }, [inputValues.selectedStudyId, studyIds]);

        // Reset edit mode when selectedStudyId changes
        useEffect(() => {
          setEditVariableId(null);
        }, [inputValues.selectedStudyId]);

        // State variables for drag-and-drop
        const [draggedVariableId, setDraggedVariableId] = useState(null);
        const [variablesOrder, setVariablesOrder] = useState({});

        // Initialize variablesOrder when variables change
        useEffect(() => {
          const newOrder = {};
          studyIds.forEach((studyId) => {
            newOrder[studyId] = (variables[studyId] || []).map((v) => v.id);
          });
          setVariablesOrder(newOrder);
        }, [variables, studyIds]);

        const generateUniqueId = () => {
          return Date.now() + Math.random();
        };

        const handleAddVariable = () => {
          if (!inputValues.variableLabel) {
            alert("Please enter a label for the variable.");
            return;
          }

          const selectedStudyId = inputValues.selectedStudyId || studyIds[0];
          const studyVars = variables[selectedStudyId]
            ? [...variables[selectedStudyId]]
            : [];

          let value = {};

          // --- If "single placeholder" baseline (like "Country") ---
          if (isSinglePlaceholder) {
            // just store as text
            value = inputValues.variableValue.singleValue || "";
          }

          // --- Otherwise handle groupType logic ---
          else if (groupType === "intervention_comparison") {
            if (inputValues.variableArmType === "double") {
              // For double-arm dichotomous, continuous, text, etc.
              if (inputValues.variableType === "dichotomous") {
                // 1) If there's a population var, auto-fill only if user left it blank
                const populationVar = findPopulationVar(selectedStudyId);
                const populationInterv =
                  populationVar?.value?.interventionPop ?? "";
                const populationCompar =
                  populationVar?.value?.comparisonPop ?? "";

                // Force inputValues if blank
                if (
                  !inputValues.variableValue.interventionTotal?.trim() &&
                  populationInterv
                ) {
                  inputValues.variableValue.interventionTotal =
                    populationInterv;
                }
                if (
                  !inputValues.variableValue.comparisonTotal?.trim() &&
                  populationCompar
                ) {
                  inputValues.variableValue.comparisonTotal = populationCompar;
                }

                value = {
                  intervention:
                    inputValues.variableValue.interventionEvents || "",
                  comparison: inputValues.variableValue.comparisonEvents || "",
                  interventionTotal:
                    inputValues.variableValue.interventionTotal || "",
                  comparisonTotal:
                    inputValues.variableValue.comparisonTotal || "",
                };
              } else if (inputValues.variableType === "continuous") {
                const populationVar = findPopulationVar(selectedStudyId);
                const populationInterv =
                  populationVar?.value?.interventionPop ?? "";
                const populationCompar =
                  populationVar?.value?.comparisonPop ?? "";

                // Force inputValues if blank
                if (
                  !inputValues.variableValue.interventionTotal?.trim() &&
                  populationInterv
                ) {
                  inputValues.variableValue.interventionTotal =
                    populationInterv;
                }
                if (
                  !inputValues.variableValue.comparisonTotal?.trim() &&
                  populationCompar
                ) {
                  inputValues.variableValue.comparisonTotal = populationCompar;
                }

                value = {
                  intervention: {
                    mean: inputValues.variableValue.interventionMean || "",
                    sd: inputValues.variableValue.interventionSd || "",
                  },
                  comparison: {
                    mean: inputValues.variableValue.comparisonMean || "",
                    sd: inputValues.variableValue.comparisonSd || "",
                  },
                  interventionTotal:
                    inputValues.variableValue.interventionTotal || "",
                  comparisonTotal:
                    inputValues.variableValue.comparisonTotal || "",
                };
              } else if (inputValues.variableType === "text") {
                const populationVar = findPopulationVar(selectedStudyId);
                const populationInterv =
                  populationVar?.value?.interventionPop ?? "";
                const populationCompar =
                  populationVar?.value?.comparisonPop ?? "";

                // Force inputValues if blank
                if (
                  !inputValues.variableValue.interventionTotal?.trim() &&
                  populationInterv
                ) {
                  inputValues.variableValue.interventionTotal =
                    populationInterv;
                }
                if (
                  !inputValues.variableValue.comparisonTotal?.trim() &&
                  populationCompar
                ) {
                  inputValues.variableValue.comparisonTotal = populationCompar;
                }

                value = {
                  intervention:
                    inputValues.variableValue.interventionText || "",
                  comparison: inputValues.variableValue.comparisonText || "",
                  interventionTotal:
                    inputValues.variableValue.interventionTotal || "",
                  comparisonTotal:
                    inputValues.variableValue.comparisonTotal || "",
                };
              } else if (inputValues.variableType === "population_size") {
                // Consistent handling for population_size across all group types
                if (groupType === "intervention_comparison") {
                  if (inputValues.variableArmType === "double") {
                    value = {
                      interventionPop:
                        inputValues.variableValue.interventionPop || "",
                      comparisonPop:
                        inputValues.variableValue.comparisonPop || "",
                    };
                  } else {
                    // Single-arm in intervention_comparison
                    value = {
                      population: inputValues.variableValue.population || "",
                    };
                  }
                } else {
                  // Single-arm intervention only
                  value = {
                    population: inputValues.variableValue.population || "",
                  };
                }
              }
            } else {
              // Single-arm data in an intervention+comparison environment
              if (inputValues.variableType === "dichotomous") {
                // If there's a population, only auto-fill if blank
                const populationVar = findPopulationVar(selectedStudyId);
                const singlePop = populationVar?.value?.population ?? "";

                if (!inputValues.variableValue.total?.trim() && singlePop) {
                  inputValues.variableValue.total = singlePop;
                }

                value = {
                  events: inputValues.variableValue.events || "",
                  total: inputValues.variableValue.total || "",
                };
              } else if (inputValues.variableType === "continuous") {
                const populationVar = findPopulationVar(selectedStudyId);
                const singlePop = populationVar?.value?.population ?? "";

                if (!inputValues.variableValue.total?.trim() && singlePop) {
                  inputValues.variableValue.total = singlePop;
                }

                value = {
                  mean: inputValues.variableValue.mean || "",
                  sd: inputValues.variableValue.sd || "",
                  total: inputValues.variableValue.total || "",
                };
              } else if (inputValues.variableType === "text") {
                const populationVar = findPopulationVar(selectedStudyId);
                const singlePop = populationVar?.value?.population ?? "";

                if (!inputValues.variableValue.total?.trim() && singlePop) {
                  inputValues.variableValue.total = singlePop;
                }

                value = {
                  text: inputValues.variableValue.text || "",
                  total: inputValues.variableValue.total || "",
                };
              } else if (inputValues.variableType === "population_size") {
                // Consistent handling for population_size
                if (groupType === "intervention_comparison") {
                  value = inputValues.variableValue.population || "";
                } else {
                  // Single-arm intervention only
                  value = {
                    population: inputValues.variableValue.population || "",
                  };
                }
              }
            }
          } else {
            // Single-arm (no comparison group)
            if (inputValues.variableType === "dichotomous") {
              const populationVar = findPopulationVar(selectedStudyId);
              const singlePop = populationVar?.value?.population ?? "";

              if (!inputValues.variableValue.total?.trim() && singlePop) {
                inputValues.variableValue.total = singlePop;
              }

              value = {
                events: inputValues.variableValue.events || "",
                total: inputValues.variableValue.total || "",
              };
            } else if (inputValues.variableType === "continuous") {
              const populationVar = findPopulationVar(selectedStudyId);
              const singlePop = populationVar?.value?.population ?? "";

              if (!inputValues.variableValue.total?.trim() && singlePop) {
                inputValues.variableValue.total = singlePop;
              }

              value = {
                mean: inputValues.variableValue.mean || "",
                sd: inputValues.variableValue.sd || "",
                total: inputValues.variableValue.total || "",
              };
            } else if (inputValues.variableType === "text") {
              const populationVar = findPopulationVar(selectedStudyId);
              const singlePop = populationVar?.value?.population ?? "";

              if (!inputValues.variableValue.total?.trim() && singlePop) {
                inputValues.variableValue.total = singlePop;
              }

              value = {
                text: inputValues.variableValue.text || "",
                total: inputValues.variableValue.total || "",
              };
            } else if (inputValues.variableType === "population_size") {
              // Consistent handling for population_size
              if (groupType === "intervention_comparison") {
                value = inputValues.variableValue.population || "";
              } else {
                // Single-arm intervention only
                value = {
                  population: inputValues.variableValue.population || "",
                };
              }
            }
          }

          // Build the new variable object
          const newVariable = {
            id:
              editVariableId !== null
                ? editVariableId
                : Date.now() + Math.random(),
            label: inputValues.variableLabel,
            type: inputValues.variableType,
            value: value,
            isSinglePlaceholder: isSinglePlaceholder,
            armType: inputValues.variableArmType,
          };

          // Insert or update
          const index = studyVars.findIndex((v) => v.id === editVariableId);
          if (editVariableId !== null && index !== -1) {
            studyVars[index] = newVariable;
          } else {
            studyVars.push(newVariable);
          }

          setVariables({ ...variables, [selectedStudyId]: studyVars });

          // Optionally re-sync your variablesOrder
          setVariablesOrder((prev) => {
            const newOrder = { ...prev };
            newOrder[selectedStudyId] = studyVars.map((v) => v.id);
            return newOrder;
          });

          // Reset
          setInputValues((prev) => ({
            ...prev,
            variableLabel: "",
            variableValue: {},
            variableType: "dichotomous",
            variableArmType:
              groupType === "intervention_comparison" ? "double" : "single",
          }));

          setEditVariableId(null);
          setShowAlert(true);
          setTimeout(() => setShowAlert(false), 2000);
        };

        const handleVariableValueChange = (field, val) => {
          setInputValues({
            ...inputValues,
            variableValue: {
              ...inputValues.variableValue,
              [field]: val,
            },
          });
        };
        const fieldOrderMap = {
          dichotomous_single: ["events"],
          dichotomous_double: ["interventionEvents", "comparisonEvents"],
          continuous_single: ["mean", "sd"],
          continuous_double: [
            "interventionMean",
            "interventionSd",
            "comparisonMean",
            "comparisonSd",
          ],
          text_single: ["text"],
          text_double: ["interventionText", "comparisonText"],
        };

        function findPopulationVar(studyId) {
          const allVars = [
            ...(baselineVariables[studyId] || []),
            ...(outcomesVariables[studyId] || []),
          ];
          return allVars.find((v) => v.type === "population_size");
        }

        function handlePaste(
          e,
          variableType,
          variableArmType,
          setInputValues,
          fieldName,
          variableLabel,
          suggestedBaselineLabels
        ) {
          // If this variable label is one of the suggested baseline text variables, don't interfere
          if (suggestedBaselineLabels.includes(variableLabel)) {
            return; // Do not preventDefault, let normal paste happen
          }

          e.preventDefault();
          const pastedText = (e.clipboardData || window.clipboardData).getData(
            "text"
          );

          // Split by tabs or multiple spaces
          let columns = pastedText
            .trim()
            .split(/\t| {2,}/)
            .filter(Boolean);

          // Helper to parse continuous column:
          function parseContinuousColumn(colText) {
            // Extract all numeric values from the text
            const numbers = colText.match(/[-+]?\d*\.?\d+/g);

            if (!numbers) {
              return { mean: "", sd: "" };
            }

            if (numbers.length >= 2) {
              // First is mean, second is sd
              return { mean: numbers[0], sd: numbers[1] };
            } else if (numbers.length === 1) {
              // Only mean is available
              return { mean: numbers[0], sd: "" };
            } else {
              return { mean: "", sd: "" };
            }
          }

          const fieldOrderMap = {
            dichotomous_single: ["events"],
            dichotomous_double: ["interventionEvents", "comparisonEvents"],
            continuous_single: ["mean", "sd"],
            continuous_double: [
              "interventionMean",
              "interventionSd",
              "comparisonMean",
              "comparisonSd",
            ],
            text_single: ["text"],
            text_double: ["interventionText", "comparisonText"],
          };

          const key = `${variableType}_${variableArmType}`;
          const fieldOrder = fieldOrderMap[key];
          if (!fieldOrder) return; // Unknown configuration

          let parsedValues = [];
          if (variableType === "dichotomous" || variableType === "text") {
            // Each column is just a single value (number or text)
            parsedValues = columns;
          } else if (variableType === "continuous") {
            // Each column can represent "mean ± sd" or variants thereof
            parsedValues = columns.map(parseContinuousColumn);
          }

          // Find the index of the field that triggered the paste
          const startIndex = fieldOrder.indexOf(fieldName);
          if (startIndex === -1) return; // Field not found

          let newValues = {};

          if (variableType === "dichotomous" || variableType === "text") {
            // Place each column into subsequent fields if they are empty
            for (
              let i = 0;
              i < parsedValues.length && startIndex + i < fieldOrder.length;
              i++
            ) {
              const targetField = fieldOrder[startIndex + i];
              newValues[targetField] = parsedValues[i];
            }
          } else if (variableType === "continuous") {
            // Flatten continuous data (mean, sd pairs)
            let flatValues = [];
            for (const col of parsedValues) {
              flatValues.push(col.mean);
              if (col.sd !== undefined) {
                flatValues.push(col.sd);
              }
            }

            // Assign flattened values to fields starting from startIndex
            for (
              let i = 0;
              i < flatValues.length && startIndex + i < fieldOrder.length;
              i++
            ) {
              const targetField = fieldOrder[startIndex + i];
              newValues[targetField] = flatValues[i];
            }
          }

          // Update state, but do not overwrite fields that already have values
          setInputValues((prev) => {
            const updatedValues = { ...prev.variableValue };
            for (const [field, val] of Object.entries(newValues)) {
              // Only set if the field is currently empty
              if (!updatedValues[field]) {
                updatedValues[field] = val;
              }
            }
            return {
              ...prev,
              variableValue: updatedValues,
            };
          });
        }

        // Function to add a row at a specific index
        const addRow = (index) => {
          const newRow = Array(spreadsheetData[0]?.length || 1).fill("");
          const newSpreadsheetData = [...spreadsheetData];
          newSpreadsheetData.splice(index, 0, newRow);
          setSpreadsheetData(newSpreadsheetData);
        };

        // Function to remove a row at a specific index
        const removeRow = (index) => {
          if (spreadsheetData.length <= 1) return; // Prevent removing all rows
          const newSpreadsheetData = [...spreadsheetData];
          newSpreadsheetData.splice(index, 1);
          setSpreadsheetData(newSpreadsheetData);
        };

        // Function to add a column at a specific index
        const addColumn = (index) => {
          const newSpreadsheetData = spreadsheetData.map((row) => {
            const newRow = [...row];
            newRow.splice(index, 0, "");
            return newRow;
          });
          setSpreadsheetData(newSpreadsheetData);
        };

        // Function to remove a column at a specific index
        const removeColumn = (index) => {
          if (spreadsheetData[0]?.length <= 1) return; // Prevent removing all columns
          const newSpreadsheetData = spreadsheetData.map((row) => {
            const newRow = [...row];
            newRow.splice(index, 1);
            return newRow;
          });
          setSpreadsheetData(newSpreadsheetData);
        };

        const handleEditVariable = (variableId) => {
          const selectedStudyId = inputValues.selectedStudyId || studyIds[0];
          const studyVars = variables[selectedStudyId] || [];

          const index = studyVars.findIndex((v) => v.id === variableId);
          if (index === -1) return;

          const variable = studyVars[index];

          // Set inputValues to the variable's data
          setInputValues({
            ...inputValues,
            variableLabel: variable.label,
            variableType: variable.type,
            variableValue: {}, // We will populate this next
            variableArmType:
              variable.armType ||
              (groupType === "intervention_comparison" ? "double" : "single"),
          });

          let variableValue = {};

          if (variable.isSinglePlaceholder) {
            variableValue.singleValue = variable.value || "";
          } else if (groupType === "intervention_comparison") {
            if (variable.armType === "double") {
              if (variable.type === "dichotomous") {
                variableValue.interventionEvents =
                  variable.value.intervention || "";
                variableValue.comparisonEvents =
                  variable.value.comparison || "";
              } else if (variable.type === "continuous") {
                variableValue.interventionMean =
                  variable.value.intervention.mean || "";
                variableValue.interventionSd =
                  variable.value.intervention.sd || "";
                variableValue.comparisonMean =
                  variable.value.comparison.mean || "";
                variableValue.comparisonSd = variable.value.comparison.sd || "";
              } else if (variable.type === "text") {
                variableValue.interventionText =
                  variable.value.intervention || "";
                variableValue.comparisonText = variable.value.comparison || "";
              }
            } else {
              // Single arm data in intervention_comparison mode
              if (variable.type === "dichotomous") {
                variableValue.events = variable.value || "";
              } else if (variable.type === "continuous") {
                variableValue.mean = variable.value.mean || "";
                variableValue.sd = variable.value.sd || "";
              } else if (variable.type === "text") {
                variableValue.text = variable.value || "";
              }
            }
          } else {
            if (variable.type === "dichotomous") {
              variableValue.events = variable.value || "";
            } else if (variable.type === "continuous") {
              variableValue.mean = variable.value.mean || "";
              variableValue.sd = variable.value.sd || "";
            } else if (variable.type === "text") {
              variableValue.text = variable.value || "";
            }
          }

          setInputValues((prevValues) => ({
            ...prevValues,
            variableValue: variableValue,
          }));

          // Set editVariableId
          setEditVariableId(variable.id);
        };

        const handleCancelEdit = () => {
          setInputValues({
            ...inputValues,
            variableLabel: "",
            variableValue: {},
            variableType: "dichotomous",
            variableArmType:
              groupType === "intervention_comparison" ? "double" : "single",
          });
          setEditVariableId(null);
        };

        const handleDeleteVariable = (variableId) => {
          setVariableToDelete(variableId);
          setShowDeleteModal(true);
        };

        // Function to get displayed variables in the current order
        const getDisplayedVariables = () => {
          const selectedStudyId = inputValues.selectedStudyId || studyIds[0];
          const studyVars = variables[selectedStudyId] || [];
          const order = variablesOrder[selectedStudyId] || [];
          // Sort studyVars based on the current order
          const orderedVars = order
            .map((id) => studyVars.find((v) => v.id === id))
            .filter(Boolean);
          return orderedVars;
        };

        // Drag event handlers
        const handleDragStart = (e, variableId) => {
          setDraggedVariableId(variableId);
          e.dataTransfer.effectAllowed = "move";
          e.currentTarget.classList.add("dragging");
        };

        const handleDragOver = (e, overVariableId) => {
          e.preventDefault();
          if (
            draggedVariableId === null ||
            overVariableId === draggedVariableId
          )
            return;

          const selectedStudyId = inputValues.selectedStudyId || studyIds[0];
          const order = variablesOrder[selectedStudyId] || [];
          const draggedIndex = order.indexOf(draggedVariableId);
          const overIndex = order.indexOf(overVariableId);

          if (draggedIndex === -1 || overIndex === -1) return;

          const newOrder = [...order];
          newOrder.splice(draggedIndex, 1);
          newOrder.splice(overIndex, 0, draggedVariableId);

          setVariablesOrder({
            ...variablesOrder,
            [selectedStudyId]: newOrder,
          });
        };

        const handleDrop = (e) => {
          e.preventDefault();
          if (draggedVariableId === null) return;

          const selectedStudyId = inputValues.selectedStudyId || studyIds[0];
          const order = variablesOrder[selectedStudyId] || [];
          const studyVars = variables[selectedStudyId] || [];

          // Reorder the variables based on the current order
          const orderedVars = order
            .map((id) => studyVars.find((v) => v.id === id))
            .filter(Boolean);

          setVariables({
            ...variables,
            [selectedStudyId]: orderedVars,
          });

          setDraggedVariableId(null);
          e.currentTarget.classList.remove("dragging");
        };

        const handleDragEnd = (e) => {
          e.currentTarget.classList.remove("dragging");
          setDraggedVariableId(null);
        };

        // Handle Import Data functionality
        const openImportModal = () => {
          setImportVariableType("dichotomous");
          setImportArmType(
            groupType === "intervention_comparison" ? "double" : "single"
          );
          setImportDataText("");
          setIsImportModalOpen(true);
        };

        const closeImportModal = () => {
          setIsImportModalOpen(false);
        };

        const handleImportVariableTypeChange = (e) => {
          setImportVariableType(e.target.value);
        };

        const handleImportArmTypeChange = (e) => {
          setImportArmType(e.target.value);
        };

        const handleAddDataset = () => {
          let dataLines = [];

          if (isSpreadsheetMode) {
            dataLines = spreadsheetData;
          } else {
            if (!importDataText.trim()) {
              alert("Please enter data into the textarea.");
              return;
            }
            dataLines = importDataText
              .trim()
              .split("\n")
              .map((line) => line.split("\t").map((cell) => cell.trim()));
          }

          const selectedStudyId = inputValues.selectedStudyId || studyIds[0];
          const studyVars = variables[selectedStudyId]
            ? [...variables[selectedStudyId]]
            : [];

          dataLines.forEach((cells) => {
            const label = cells[0];
            if (!label) return;

            let value = {};

            if (
              importVariableType === "dichotomous" &&
              importArmType === "double" &&
              cells.length === 3
            ) {
              cells.splice(
                2,
                0,
                interventionPopSize || "",
                comparisonPopSize || ""
              );
            } else if (
              importVariableType === "continuous" &&
              importArmType === "double" &&
              cells.length === 5
            ) {
              cells.splice(3, 0, interventionPopSize || "");
              cells.push(comparisonPopSize || "");
            } else if (
              importVariableType === "continuous" &&
              importArmType === "double" &&
              cells.length === 3
            ) {
              cells.splice(2, 0, "");
              cells.splice(3, 0, interventionPopSize || "");
              cells.splice(5, 0, "");
              cells.splice(6, 0, comparisonPopSize || "");
            }

            if (
              importVariableType === "dichotomous" &&
              importArmType === "single" &&
              cells.length === 2
            ) {
              cells.push(interventionPopSize || "");
            } else if (
              importVariableType === "continuous" &&
              importArmType === "single" &&
              cells.length === 3
            ) {
              cells.push(interventionPopSize || "");
            }

            if (importVariableType === "dichotomous") {
              if (importArmType === "double") {
                value = {
                  intervention: cells[1] || "",
                  interventionTotal: cells[2] || "",
                  comparisonTotal: cells[3] || "",
                  comparison: cells[4] || "",
                };
              } else {
                const events = cells[1] || "";
                const total = cells[2] || "";
                value = { events, total };
              }
            } else if (importVariableType === "continuous") {
              if (importArmType === "double") {
                value = {
                  intervention: {
                    mean: cells[1] || "",
                    sd: cells[2] || "",
                  },
                  comparison: {
                    mean: cells[4] || "",
                    sd: cells[5] || "",
                  },
                  interventionTotal: cells[3] || "",
                  comparisonTotal: cells[6] || "",
                };
              } else {
                value = {
                  mean: cells[1] || "",
                  sd: cells[2] || "",
                  total: cells[3] || "",
                };
              }
            } else if (importVariableType === "text") {
              if (importArmType === "double") {
                value = {
                  intervention: cells[1] || "",
                  interventionTotal: cells[2] || "",
                  comparisonTotal: cells[3] || "",
                  comparison: cells[4] || "",
                };
              } else {
                value = cells[1] || "";
              }
            } else if (importVariableType === "population_size") {
              if (importArmType === "double") {
                value = {
                  interventionPop: interventionPopSize.trim() || "",
                  comparisonPop: comparisonPopSize.trim() || "",
                };
              } else {
                value = {
                  population: interventionPopSize.trim() || "",
                };
              }
            }

            const existingIndex = studyVars.findIndex((v) => v.label === label);
            const newVariable = {
              id: generateUniqueId(),
              label,
              type: importVariableType,
              value,
              isSinglePlaceholder: false,
              armType: importArmType,
            };

            if (existingIndex !== -1) {
              studyVars[existingIndex] = newVariable;
            } else {
              studyVars.push(newVariable);
            }
          });

          setVariables({
            ...variables,
            [selectedStudyId]: studyVars,
          });

          setVariablesOrder((prevOrder) => {
            const newOrder = { ...prevOrder };
            newOrder[selectedStudyId] = studyVars.map((v) => v.id);
            return newOrder;
          });

          closeImportModal();
        };

        function getPopulationForArm(studyId, arm, baselineVars, outcomesVars) {
          // we can search in baselineVars[studyId] or outcomesVars[studyId]
          // combine them for convenience:
          const combined = [
            ...(baselineVars[studyId] || []),
            ...(outcomesVars[studyId] || []),
          ];

          // find a variable with type === 'population_size'
          for (let variable of combined) {
            if (variable.type === "population_size") {
              // check if double or single
              if (variable.armType === "double") {
                if (arm === "intervention")
                  return variable.value.interventionPop || "";
                if (arm === "comparison")
                  return variable.value.comparisonPop || "";
              } else {
                // single or 'single'
                return variable.value.population || "";
              }
            }
          }

          return ""; // no population data found
        }

        // New version of swapInterventionComparisonValues
        const swapInterventionComparisonValues = () => {
          // Make a shallow copy to avoid mutating state directly.
          const variableValue = { ...inputValues.variableValue };

          if (inputValues.variableType === "dichotomous") {
            // Swap events & totals
            const tempEvents = variableValue.interventionEvents;
            variableValue.interventionEvents = variableValue.comparisonEvents;
            variableValue.comparisonEvents = tempEvents;

            const tempTotal = variableValue.interventionTotal;
            variableValue.interventionTotal = variableValue.comparisonTotal;
            variableValue.comparisonTotal = tempTotal;
          } else if (inputValues.variableType === "continuous") {
            // Swap mean, sd & totals
            const tempMean = variableValue.interventionMean;
            variableValue.interventionMean = variableValue.comparisonMean;
            variableValue.comparisonMean = tempMean;

            const tempSd = variableValue.interventionSd;
            variableValue.interventionSd = variableValue.comparisonSd;
            variableValue.comparisonSd = tempSd;

            const tempTotal = variableValue.interventionTotal;
            variableValue.interventionTotal = variableValue.comparisonTotal;
            variableValue.comparisonTotal = tempTotal;
          } else if (inputValues.variableType === "text") {
            // Swap text (and any totals if you’ve stored them)
            const tempText = variableValue.interventionText;
            variableValue.interventionText = variableValue.comparisonText;
            variableValue.comparisonText = tempText;

            const tempTotal = variableValue.interventionTotal;
            variableValue.interventionTotal = variableValue.comparisonTotal;
            variableValue.comparisonTotal = tempTotal;
          } else if (inputValues.variableType === "population_size") {
            if (groupType === "intervention_comparison") {
              // Swap interventionPop & comparisonPop (only for intervention_comparison)
              const tempPop = variableValue.interventionPop;
              variableValue.interventionPop = variableValue.comparisonPop;
              variableValue.comparisonPop = tempPop;
            } // No else needed, as this function is only relevant for intervention_comparison
          }

          // Update state with the swapped values
          setInputValues({
            ...inputValues,
            variableValue,
          });
        };

        return (
          <div className="space-y-6">
            <h1 className="text-2xl font-bold">Add Variables</h1>
            <div className="flex flex-col md:flex-row justify-between items-center">
              <div className="flex space-x-4 mb-4 md:mb-0">
                <button
                  onClick={() => setSelectedOption("baseline")}
                  className={`font-semibold py-2 px-4 rounded-lg transition duration-300 ${
                    selectedOption === "baseline"
                      ? "bg-blue-600"
                      : "bg-gray-700 hover:bg-gray-600"
                  }`}
                >
                  Baseline
                </button>
                <button
                  onClick={() => setSelectedOption("outcomes")}
                  className={`font-semibold py-2 px-4 rounded-lg transition duration-300 ${
                    selectedOption === "outcomes"
                      ? "bg-blue-600"
                      : "bg-gray-700 hover:bg-gray-600"
                  }`}
                >
                  Outcomes
                </button>
                {/* NEW BUTTON: "Add Multiple Variables" */}
                <button
                  onClick={openMultiVarModal}
                  className="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4
               rounded-lg transition duration-300 flex items-center ml-4"
                >
                  {/* Example plus sign icon (Font Awesome or inline SVG) */}
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 448 512"
                    className="w-4 h-4 fill-current"
                  >
                    <path d="M256 80c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 144L48 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l144 0 0 144c0 17.7 14.3 32 32 32s32-14.3 32-32l0-144 144 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-144 0 0-144z" />
                  </svg>
                </button>
              </div>
              <div className="text-sm text-gray-400">
                Selected Study ID:{" "}
                <span className="font-semibold text-gray-200">
                  {inputValues.selectedStudyId || studyIds[0]}
                </span>
              </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              <div>
                <label className="block font-semibold mb-2">
                  Select Study ID
                </label>
                <select
                  value={inputValues.selectedStudyId || studyIds[0]}
                  onChange={(e) =>
                    setInputValues({
                      ...inputValues,
                      selectedStudyId: e.target.value,
                    })
                  }
                  className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  {studyIds.map((id) => (
                    <option key={id} value={id}>
                      {id}
                    </option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block font-semibold mb-2">
                  Variable Label
                </label>
                <input
                  type="text"
                  value={inputValues.variableLabel}
                  onChange={handleVariableLabelChange}
                  list="variable-labels"
                  className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="e.g., Age, Gender"
                />
                <datalist id="variable-labels">
                  {allVariableLabels.map((label) => (
                    <option key={label} value={label} />
                  ))}
                </datalist>
              </div>
              {!isSinglePlaceholder && (
                <div>
                  <label className="block font-semibold mb-2">
                    Variable Type
                  </label>
                  <select
                    value={inputValues.variableType}
                    onChange={(e) =>
                      setInputValues({
                        ...inputValues,
                        variableType: e.target.value,
                      })
                    }
                    className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    <option value="dichotomous">Dichotomous</option>
                    <option value="continuous">Continuous</option>
                    <option value="text">Text</option>
                  </select>
                </div>
              )}
            </div>

            {groupType === "intervention_comparison" &&
              !isSinglePlaceholder && (
                <div className="mt-4">
                  <label className="block font-semibold mb-2">
                    Data Entry Mode
                  </label>
                  <select
                    value={inputValues.variableArmType}
                    onChange={(e) =>
                      setInputValues({
                        ...inputValues,
                        variableArmType: e.target.value,
                      })
                    }
                    className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    <option value="double">Double Arm Data</option>
                    <option value="single">Single Arm Data</option>
                  </select>
                </div>
              )}

            <div className="mt-6">
              {isSinglePlaceholder ? (
                // --- SINGLE-PLACEHOLDER BASELINE TEXT ---
                <div>
                  <label className="block font-semibold mb-2">Value</label>
                  <input
                    type="text"
                    value={inputValues.variableValue.singleValue || ""}
                    onChange={(e) =>
                      handleVariableValueChange("singleValue", e.target.value)
                    }
                    onPaste={(e) =>
                      handlePaste(
                        e,
                        "text",
                        "single",
                        setInputValues,
                        "singleValue",
                        inputValues.variableLabel,
                        suggestedBaselineLabels
                      )
                    }
                    className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="Enter value"
                  />
                </div>
              ) : groupType === "intervention_comparison" ? (
                inputValues.variableArmType === "double" ? (
                  <>
                    {/* ========== DOUBLE-ARM + DICHOTOMOUS ========== */}
                    {inputValues.variableType === "dichotomous" && (
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-8 items-start">
                        {/* Intervention Column */}
                        <div className="space-y-4">
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.interventionName} Events
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.interventionEvents ||
                                ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange(
                                  "interventionEvents",
                                  val
                                );
                              }}
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "dichotomous",
                                  "double",
                                  setInputValues,
                                  "interventionEvents",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`e.g., Events in ${groupNames.interventionName}`}
                            />
                          </div>
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.interventionName} Total
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.interventionTotal?.trim()
                                  ? inputValues.variableValue.interventionTotal
                                  : getPopulationForArm(
                                      inputValues.selectedStudyId ||
                                        studyIds[0],
                                      "intervention",
                                      baselineVariables,
                                      outcomesVariables
                                    ) || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange(
                                  "interventionTotal",
                                  val
                                );
                              }}
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`Total in ${groupNames.interventionName}`}
                            />
                          </div>
                        </div>

                        {/* Swap Button (centered) */}
                        <div className="flex flex-col items-center justify-center h-full">
                          <button
                            onClick={swapInterventionComparisonValues}
                            className="text-white text-2xl font-semibold transition duration-300 hover:text-blue-500"
                          >
                            ⇌
                          </button>
                        </div>

                        {/* Comparison Column */}
                        <div className="space-y-4">
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.comparisonName} Events
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.comparisonEvents || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange(
                                  "comparisonEvents",
                                  val
                                );
                              }}
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "dichotomous",
                                  "double",
                                  setInputValues,
                                  "comparisonEvents",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`e.g., Events in ${groupNames.comparisonName}`}
                            />
                          </div>
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.comparisonName} Total
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.comparisonTotal?.trim()
                                  ? inputValues.variableValue.comparisonTotal
                                  : getPopulationForArm(
                                      inputValues.selectedStudyId ||
                                        studyIds[0],
                                      "comparison",
                                      baselineVariables,
                                      outcomesVariables
                                    ) || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange(
                                  "comparisonTotal",
                                  val
                                );
                              }}
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`Total in ${groupNames.comparisonName}`}
                            />
                          </div>
                        </div>
                      </div>
                    )}

                    {/* ========== DOUBLE-ARM + CONTINUOUS ========== */}
                    {inputValues.variableType === "continuous" && (
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-8 items-start">
                        {/* Intervention Column */}
                        <div className="space-y-4">
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.interventionName} Mean
                            </label>
                            <input
                              type="text"
                              inputMode="decimal"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.interventionMean || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(
                                  /[^0-9.\-]/g,
                                  ""
                                );
                                handleVariableValueChange(
                                  "interventionMean",
                                  val
                                );
                              }}
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "continuous",
                                  "double",
                                  setInputValues,
                                  "interventionMean",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`Mean ${groupNames.interventionName}`}
                            />
                          </div>
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.interventionName} SD
                            </label>
                            <input
                              type="text"
                              inputMode="decimal"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.interventionSd || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(
                                  /[^0-9.\-]/g,
                                  ""
                                );
                                handleVariableValueChange(
                                  "interventionSd",
                                  val
                                );
                              }}
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "continuous",
                                  "double",
                                  setInputValues,
                                  "interventionSd",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`SD ${groupNames.interventionName}`}
                            />
                          </div>
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.interventionName} Total
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.interventionTotal?.trim()
                                  ? inputValues.variableValue.interventionTotal
                                  : getPopulationForArm(
                                      inputValues.selectedStudyId ||
                                        studyIds[0],
                                      "intervention",
                                      baselineVariables,
                                      outcomesVariables
                                    ) || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange(
                                  "interventionTotal",
                                  val
                                );
                              }}
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`Total in ${groupNames.interventionName}`}
                            />
                          </div>
                        </div>

                        {/* Swap Button (centered) */}
                        <div className="flex flex-col items-center justify-center h-full">
                          <button
                            onClick={swapInterventionComparisonValues}
                            className="text-white text-2xl font-semibold transition duration-300 hover:text-blue-500"
                          >
                            ⇌
                          </button>
                        </div>

                        {/* Comparison Column */}
                        <div className="space-y-4">
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.comparisonName} Mean
                            </label>
                            <input
                              type="text"
                              inputMode="decimal"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.comparisonMean || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(
                                  /[^0-9.\-]/g,
                                  ""
                                );
                                handleVariableValueChange(
                                  "comparisonMean",
                                  val
                                );
                              }}
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "continuous",
                                  "double",
                                  setInputValues,
                                  "comparisonMean",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`Mean ${groupNames.comparisonName}`}
                            />
                          </div>
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.comparisonName} SD
                            </label>
                            <input
                              type="text"
                              inputMode="decimal"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.comparisonSd || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(
                                  /[^0-9.\-]/g,
                                  ""
                                );
                                handleVariableValueChange("comparisonSd", val);
                              }}
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "continuous",
                                  "double",
                                  setInputValues,
                                  "comparisonSd",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`SD ${groupNames.comparisonName}`}
                            />
                          </div>
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.comparisonName} Total
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.comparisonTotal?.trim()
                                  ? inputValues.variableValue.comparisonTotal
                                  : getPopulationForArm(
                                      inputValues.selectedStudyId ||
                                        studyIds[0],
                                      "comparison",
                                      baselineVariables,
                                      outcomesVariables
                                    ) || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange(
                                  "comparisonTotal",
                                  val
                                );
                              }}
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`Total in ${groupNames.comparisonName}`}
                            />
                          </div>
                        </div>
                      </div>
                    )}

                    {/* ========== DOUBLE-ARM + TEXT (NO TOTAL) ========== */}
                    {inputValues.variableType === "text" && (
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-8 items-start">
                        {/* Intervention Column */}
                        <div className="space-y-4">
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.interventionName} Text
                            </label>
                            <input
                              type="text"
                              value={
                                inputValues.variableValue.interventionText || ""
                              }
                              onChange={(e) =>
                                handleVariableValueChange(
                                  "interventionText",
                                  e.target.value
                                )
                              }
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "text",
                                  "double",
                                  setInputValues,
                                  "interventionText",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`e.g., Text for ${groupNames.interventionName}`}
                            />
                          </div>
                          {/* NOTE: No "InterventionName Total" field for text */}
                        </div>

                        {/* Swap Button (centered) */}
                        <div className="flex flex-col items-center justify-center h-full">
                          <button
                            onClick={swapInterventionComparisonValues}
                            className="text-white text-2xl font-semibold transition duration-300 hover:text-blue-500"
                          >
                            ⇌
                          </button>
                        </div>

                        {/* Comparison Column */}
                        <div className="space-y-4">
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.comparisonName} Text
                            </label>
                            <input
                              type="text"
                              value={
                                inputValues.variableValue.comparisonText || ""
                              }
                              onChange={(e) =>
                                handleVariableValueChange(
                                  "comparisonText",
                                  e.target.value
                                )
                              }
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "text",
                                  "double",
                                  setInputValues,
                                  "comparisonText",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`e.g., Text for ${groupNames.comparisonName}`}
                            />
                          </div>
                          {/* NOTE: No "ComparisonName Total" field for text */}
                        </div>
                      </div>
                    )}

                    {/* ========== DOUBLE-ARM + POPULATION_SIZE ========== */}
                    {inputValues.variableType === "population_size" &&
                      inputValues.variableArmType === "double" && (
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-8 items-start">
                          {/* Intervention Column */}
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.interventionName} Population
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.interventionPop || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange(
                                  "interventionPop",
                                  val
                                );
                              }}
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`e.g., 100 in ${groupNames.interventionName}`}
                            />
                          </div>

                          {/* Swap Button (centered) */}
                          <div className="flex flex-col items-center justify-center h-full">
                            <button
                              onClick={swapInterventionComparisonValues}
                              className="text-white text-2xl font-semibold transition duration-300 hover:text-blue-500"
                            >
                              ⇌
                            </button>
                          </div>

                          {/* Comparison Column */}
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.comparisonName} Population
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.comparisonPop || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange("comparisonPop", val);
                              }}
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`e.g., 120 in ${groupNames.comparisonName}`}
                            />
                          </div>
                        </div>
                      )}
                  </>
                ) : (
                  // --- SINGLE-ARM DATA IN INTERVENTION_COMPARISON MODE ---
                  <>
                    {/* ========== SINGLE-ARM + DICHOTOMOUS ========== */}
                    {inputValues.variableType === "dichotomous" && (
                      <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                        <div>
                          <label className="block font-semibold mb-2">
                            Events
                          </label>
                          <input
                            type="text"
                            inputMode="numeric"
                            pattern="[0-9]*"
                            onWheel={(e) => e.preventDefault()}
                            value={inputValues.variableValue.events || ""}
                            onChange={(e) => {
                              const val = e.target.value.replace(/\D/g, "");
                              handleVariableValueChange("events", val);
                            }}
                            onPaste={(e) =>
                              handlePaste(
                                e,
                                "dichotomous",
                                "single",
                                setInputValues,
                                "events",
                                inputValues.variableLabel,
                                suggestedBaselineLabels
                              )
                            }
                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="e.g., 50"
                          />
                        </div>

                        <div>
                          <label className="block font-semibold mb-2">
                            Total
                          </label>
                          <input
                            type="text"
                            inputMode="numeric"
                            pattern="[0-9]*"
                            onWheel={(e) => e.preventDefault()}
                            value={
                              inputValues.variableValue.total?.trim()
                                ? inputValues.variableValue.total
                                : getPopulationForArm(
                                    inputValues.selectedStudyId || studyIds[0],
                                    "single",
                                    baselineVariables,
                                    outcomesVariables
                                  ) || ""
                            }
                            onChange={(e) => {
                              const val = e.target.value.replace(/\D/g, "");
                              handleVariableValueChange("total", val);
                            }}
                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="e.g., 60"
                          />
                        </div>
                      </div>
                    )}

                    {/* ========== SINGLE-ARM + CONTINUOUS ========== */}
                    {inputValues.variableType === "continuous" && (
                      <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                        <div>
                          <label className="block font-semibold mb-2">
                            Mean
                          </label>
                          <input
                            type="text"
                            inputMode="decimal"
                            onWheel={(e) => e.preventDefault()}
                            value={inputValues.variableValue.mean || ""}
                            onChange={(e) => {
                              const val = e.target.value.replace(
                                /[^0-9.\-]/g,
                                ""
                              );
                              handleVariableValueChange("mean", val);
                            }}
                            onPaste={(e) =>
                              handlePaste(
                                e,
                                "continuous",
                                "single",
                                setInputValues,
                                "mean",
                                inputValues.variableLabel,
                                suggestedBaselineLabels
                              )
                            }
                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="e.g., 5.6"
                          />
                        </div>

                        <div>
                          <label className="block font-semibold mb-2">SD</label>
                          <input
                            type="text"
                            inputMode="decimal"
                            onWheel={(e) => e.preventDefault()}
                            value={inputValues.variableValue.sd || ""}
                            onChange={(e) => {
                              const val = e.target.value.replace(
                                /[^0-9.\-]/g,
                                ""
                              );
                              handleVariableValueChange("sd", val);
                            }}
                            onPaste={(e) =>
                              handlePaste(
                                e,
                                "continuous",
                                "single",
                                setInputValues,
                                "sd",
                                inputValues.variableLabel,
                                suggestedBaselineLabels
                              )
                            }
                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="e.g., 1.2"
                          />
                        </div>

                        <div>
                          <label className="block font-semibold mb-2">
                            Total
                          </label>
                          <input
                            type="text"
                            inputMode="numeric"
                            pattern="[0-9]*"
                            onWheel={(e) => e.preventDefault()}
                            value={
                              inputValues.variableValue.total?.trim()
                                ? inputValues.variableValue.total
                                : getPopulationForArm(
                                    inputValues.selectedStudyId || studyIds[0],
                                    "single",
                                    baselineVariables,
                                    outcomesVariables
                                  ) || ""
                            }
                            onChange={(e) => {
                              const val = e.target.value.replace(/\D/g, "");
                              handleVariableValueChange("total", val);
                            }}
                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="e.g., 60"
                          />
                        </div>
                      </div>
                    )}

                    {/* ========== SINGLE-ARM + TEXT (NO TOTAL) ========== */}
                    {inputValues.variableType === "text" && (
                      <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                        <div>
                          <label className="block font-semibold mb-2">
                            Text Value
                          </label>
                          <input
                            type="text"
                            value={inputValues.variableValue.text || ""}
                            onChange={(e) =>
                              handleVariableValueChange("text", e.target.value)
                            }
                            onPaste={(e) =>
                              handlePaste(
                                e,
                                "text",
                                "single",
                                setInputValues,
                                "text",
                                inputValues.variableLabel,
                                suggestedBaselineLabels
                              )
                            }
                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="e.g., Yes"
                          />
                        </div>
                        {/* NOTE: No additional "Total" field for text here */}
                      </div>
                    )}

                    {/* ========== SINGLE-ARM + POPULATION_SIZE ========== */}
                    {inputValues.variableType === "population_size" && (
                      <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                        <div>
                          <label className="block font-semibold mb-2">
                            Population Size
                          </label>
                          <input
                            type="text"
                            inputMode="numeric"
                            pattern="[0-9]*"
                            onWheel={(e) => e.preventDefault()}
                            value={inputValues.variableValue.population || ""}
                            onChange={(e) => {
                              const val = e.target.value.replace(/\D/g, "");
                              handleVariableValueChange("population", val);
                            }}
                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="e.g., 1000"
                          />
                        </div>
                      </div>
                    )}
                  </>
                )
              ) : (
                // --- SINGLE-ARM INTERVENTION ONLY ---
                <>
                  {/* ========== SINGLE-ARM + DICHOTOMOUS ========== */}
                  {inputValues.variableType === "dichotomous" && (
                    <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                      <div>
                        <label className="block font-semibold mb-2">
                          Events
                        </label>
                        <input
                          type="text"
                          inputMode="numeric"
                          pattern="[0-9]*"
                          onWheel={(e) => e.preventDefault()}
                          value={inputValues.variableValue.events || ""}
                          onChange={(e) => {
                            const val = e.target.value.replace(/\D/g, "");
                            handleVariableValueChange("events", val);
                          }}
                          onPaste={(e) =>
                            handlePaste(
                              e,
                              "dichotomous",
                              "single",
                              setInputValues,
                              "events",
                              inputValues.variableLabel,
                              suggestedBaselineLabels
                            )
                          }
                          className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., 50"
                        />
                      </div>
                      <div>
                        <label className="block font-semibold mb-2">
                          Total
                        </label>
                        <input
                          type="text"
                          inputMode="numeric"
                          pattern="[0-9]*"
                          onWheel={(e) => e.preventDefault()}
                          value={
                            inputValues.variableValue.total?.trim()
                              ? inputValues.variableValue.total
                              : getPopulationForArm(
                                  inputValues.selectedStudyId || studyIds[0],
                                  "single",
                                  baselineVariables,
                                  outcomesVariables
                                ) || ""
                          }
                          onChange={(e) => {
                            const val = e.target.value.replace(/\D/g, "");
                            handleVariableValueChange("total", val);
                          }}
                          className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., 60"
                        />
                      </div>
                    </div>
                  )}

                  {/* ========== SINGLE-ARM + CONTINUOUS ========== */}
                  {inputValues.variableType === "continuous" && (
                    <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                      <div>
                        <label className="block font-semibold mb-2">Mean</label>
                        <input
                          type="text"
                          inputMode="decimal"
                          onWheel={(e) => e.preventDefault()}
                          value={inputValues.variableValue.mean || ""}
                          onChange={(e) => {
                            const val = e.target.value.replace(
                              /[^0-9.\-]/g,
                              ""
                            );
                            handleVariableValueChange("mean", val);
                          }}
                          onPaste={(e) =>
                            handlePaste(
                              e,
                              "continuous",
                              "single",
                              setInputValues,
                              "mean",
                              inputValues.variableLabel,
                              suggestedBaselineLabels
                            )
                          }
                          className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., 5.6"
                        />
                      </div>
                      <div>
                        <label className="block font-semibold mb-2">SD</label>
                        <input
                          type="text"
                          inputMode="decimal"
                          onWheel={(e) => e.preventDefault()}
                          value={inputValues.variableValue.sd || ""}
                          onChange={(e) => {
                            const val = e.target.value.replace(
                              /[^0-9.\-]/g,
                              ""
                            );
                            handleVariableValueChange("sd", val);
                          }}
                          onPaste={(e) =>
                            handlePaste(
                              e,
                              "continuous",
                              "single",
                              setInputValues,
                              "sd",
                              inputValues.variableLabel,
                              suggestedBaselineLabels
                            )
                          }
                          className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., 1.2"
                        />
                      </div>
                      <div>
                        <label className="block font-semibold mb-2">
                          Total
                        </label>
                        <input
                          type="text"
                          inputMode="numeric"
                          pattern="[0-9]*"
                          onWheel={(e) => e.preventDefault()}
                          value={
                            inputValues.variableValue.total?.trim()
                              ? inputValues.variableValue.total
                              : getPopulationForArm(
                                  inputValues.selectedStudyId || studyIds[0],
                                  "single",
                                  baselineVariables,
                                  outcomesVariables
                                ) || ""
                          }
                          onChange={(e) => {
                            const val = e.target.value.replace(/\D/g, "");
                            handleVariableValueChange("total", val);
                          }}
                          className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., 60"
                        />
                      </div>
                    </div>
                  )}

                  {/* ========== SINGLE-ARM + TEXT (NO TOTAL) ========== */}
                  {inputValues.variableType === "text" && (
                    <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                      <div>
                        <label className="block font-semibold mb-2">
                          Text Value
                        </label>
                        <input
                          type="text"
                          value={inputValues.variableValue.text || ""}
                          onChange={(e) =>
                            handleVariableValueChange("text", e.target.value)
                          }
                          onPaste={(e) =>
                            handlePaste(
                              e,
                              "text",
                              "single",
                              setInputValues,
                              "text",
                              inputValues.variableLabel,
                              suggestedBaselineLabels
                            )
                          }
                          className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., Yes"
                        />
                      </div>
                      {/* NOTE: No "Total" field for single-arm text */}
                    </div>
                  )}

                  {/* ========== SINGLE-ARM + POPULATION_SIZE ========== */}
                  {inputValues.variableType === "population_size" && (
                    <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                      <div>
                        <label className="block font-semibold mb-2">
                          Population Size
                        </label>
                        <input
                          type="text"
                          inputMode="numeric"
                          pattern="[0-9]*"
                          onWheel={(e) => e.preventDefault()}
                          value={inputValues.variableValue.population || ""}
                          onChange={(e) => {
                            const val = e.target.value.replace(/\D/g, "");
                            handleVariableValueChange("population", val);
                          }}
                          className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., 1000"
                        />
                      </div>
                    </div>
                  )}
                </>
              )}
            </div>

            <div className="mt-6 flex items-center">
              <button
                onClick={handleAddVariable}
                className="bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-300 flex items-center"
              >
                <i
                  className={`fas ${
                    editVariableId !== null ? "fa-save" : "fa-plus"
                  } mr-2`}
                ></i>
                {editVariableId !== null ? "Update Variable" : "Add Variable"}
              </button>
              {editVariableId !== null && (
                <>
                  <button
                    onClick={handleCancelEdit}
                    className="ml-4 bg-gray-600 hover:bg-gray-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-300 flex items-center"
                  >
                    <i className="fas fa-times mr-2"></i> Cancel
                  </button>
                  <button
                    onClick={() => handleDeleteVariable(editVariableId)}
                    className="ml-4 bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-300 flex items-center"
                  >
                    <i className="fas fa-trash-alt mr-2"></i> Delete
                  </button>
                </>
              )}
              <button
                onClick={openImportModal}
                className="ml-4 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-300 flex items-center"
              >
                <i className="fas fa-file-import mr-2"></i> Import Data
              </button>
              <button
                onClick={openCalculadoraModal}
                className="ml-4 bg-gray-600 hover:bg-gray-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-300 flex items-center"
              >
                {/* Here is your custom SVG icon */}
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 384 512"
                  className="w-5 h-5 fill-current"
                >
                  <path d="M64 0C28.7 0 0 28.7 0 64L0 448c0 35.3 28.7 64 64 64l256 0c35.3 0 64-28.7 64-64l0-384c0-35.3-28.7-64-64-64L64 0zM96 64l192 0c17.7 0 32 14.3 32 32l0 32c0 17.7-14.3 32-32 32L96 160c-17.7 0-32-14.3-32-32l0-32c0-17.7 14.3-32 32-32zm32 160a32 32 0 1 1 -64 0 32 32 0 1 1 64 0zM96 352a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM64 416c0-17.7 14.3-32 32-32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-96 0c-17.7 0-32-14.3-32-32zM192 256a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm32 64a32 32 0 1 1 -64 0 32 32 0 1 1 64 0zm64-64a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm32 64a32 32 0 1 1 -64 0 32 32 0 1 1 64 0zM288 448a32 32 0 1 1 0-64 32 32 0 1 1 0 64z" />
                </svg>
              </button>
            </div>

            {showAlert && (
              <div className="mt-4 bg-green-600 text-white py-2 px-4 rounded-lg flex items-center">
                <i className="fas fa-check-circle mr-2"></i> Variable{" "}
                {editVariableId !== null ? "updated" : "added"} successfully!
              </div>
            )}
            {/* Calculator Modal */}
            {isCalculadoraModalOpen && (
              <div className="fixed inset-0 flex items-center justify-center z-50">
                {/* Dim Background */}
                <div className="absolute inset-0 bg-black opacity-70"></div>

                {/* Modal Container */}
                <div
                  className="
    relative z-50
    w-11/12 md:w-1/2 lg:w-2/5
    max-h-[90vh]
    overflow-auto
    bg-gray-900
    shadow-2xl
    rounded-xl
    border border-gray-700
    p-4
      "
                >
                  <h2 className="text-2xl font-bold mb-4">
                    MEAN ± SD Calculator
                  </h2>
                  {/* Here is where you embed or call your calculator function */}
                  <CalculadoraEstimativas />

                  <div className="mt-6 flex justify-end">
                    <button
                      onClick={closeCalculadoraModal}
                      className="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
                    >
                      Close
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* Import Data Modal */}
            {isImportModalOpen && (
              <div className="fixed inset-0 flex items-center justify-center z-50">
                {/* Dim Background */}
                <div className="absolute inset-0 bg-black opacity-70"></div>

                {/* Modal Container */}
                <div
                  className="
        relative z-50
        w-11/12 md:w-2/3 lg:w-1/2
        max-h-screen
        overflow-auto
        bg-gradient-to-br from-gray-900 via-[#303030] to-gray-900
        shadow-2xl
        rounded-xl
        border border-[#303030]
        p-6
        neon-glow
      "
                  style={{ fontFamily: "Orbitron, sans-serif" }}
                >
                  <h2 className="text-2xl font-bold mb-4 text-[#303030] tracking-wider uppercase">
                    Import Data
                  </h2>

                  {/* Select Variable Type & Data Entry Mode */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                      <label className="block font-semibold mb-2 text-[#303030]">
                        Variable Type
                      </label>
                      <select
                        value={importVariableType}
                        onChange={handleImportVariableTypeChange}
                        className="
              w-full p-3 
              bg-black bg-opacity-50
              border border-[#303030]
              rounded-lg 
              focus:outline-none focus:ring-2 focus:ring-[#303030]
              text-[#303030]
              hover:bg-opacity-70
              transition duration-300
            "
                      >
                        <option value="dichotomous">Dichotomous</option>
                        <option value="continuous">Continuous</option>
                        <option value="text">Text</option>
                        {/* Optionally add population_size here if needed:
            <option value="population_size">Population Size</option> */}
                      </select>
                    </div>

                    {groupType === "intervention_comparison" && (
                      <div>
                        <label className="block font-semibold mb-2 text-[#303030]">
                          Data Entry Mode
                        </label>
                        <select
                          value={importArmType}
                          onChange={handleImportArmTypeChange}
                          className="
                w-full p-3
                bg-black bg-opacity-50
                border border-[#303030]
                rounded-lg 
                focus:outline-none focus:ring-2 focus:ring-[#303030] 
                text-[#303030]
                hover:bg-opacity-70
                transition duration-300
              "
                        >
                          <option value="double">Double Arm Data</option>
                          <option value="single">Single Arm Data</option>
                        </select>
                      </div>
                    )}
                  </div>

                  {/* 
        NEW FIELDS: 
        For double-arm, user can place population sizes 
        that we will treat as "Total" for Intervention or Comparison
      */}
                  {groupType === "intervention_comparison" &&
                    importArmType === "double" && (
                      <div className="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                          <label className="block font-semibold mb-2 text-[#303030]">
                            Intervention Population Size
                          </label>
                          <input
                            type="number"
                            value={interventionPopSize}
                            onChange={(e) =>
                              setInterventionPopSize(e.target.value)
                            }
                            className="
                w-full p-3
                bg-black bg-opacity-50
                border border-[#303030]
                rounded-lg
                focus:outline-none focus:ring-2 focus:ring-[#303030]
                text-[#303030]
                hover:bg-opacity-70
                transition duration-300
              "
                            placeholder="Enter intervention population size"
                          />
                        </div>
                        <div>
                          <label className="block font-semibold mb-2 text-[#303030]">
                            Comparison Population Size
                          </label>
                          <input
                            type="number"
                            value={comparisonPopSize}
                            onChange={(e) =>
                              setComparisonPopSize(e.target.value)
                            }
                            className="
                w-full p-3
                bg-black bg-opacity-50
                border border-[#303030]
                rounded-lg
                focus:outline-none focus:ring-2 focus:ring-[#303030]
                text-[#303030]
                hover:bg-opacity-70
                transition duration-300
              "
                            placeholder="Enter comparison population size"
                          />
                        </div>
                      </div>
                    )}
                  {groupType === "intervention_comparison" &&
                    importArmType === "single" && (
                      <div className="mt-6">
                        <label className="block font-semibold mb-2 text-[#303030]">
                          Total Population Size
                        </label>
                        <input
                          type="number"
                          value={interventionPopSize} // or rename to singlePopSize
                          onChange={(e) =>
                            setInterventionPopSize(e.target.value)
                          }
                          className="
        w-full p-3
        bg-black bg-opacity-50
        border border-[#303030]
        rounded-lg
        focus:outline-none focus:ring-2 focus:ring-[#303030]
        text-[#303030]
        hover:bg-opacity-70
        transition duration-300
      "
                          placeholder="Enter total population size"
                        />
                      </div>
                    )}

                  {/* Text/Paste area for the user’s tab-separated data */}
                  <div className="mt-4">
                    <div className="flex items-center">
                      <label className="block font-semibold text-[#303030]">
                        Enter Data (Tab-Separated)
                      </label>

                      {!isSpreadsheetMode ? (
                        <button
                          onClick={() => {
                            const rows = importDataText
                              .trim()
                              .split("\n")
                              .map((line) => line.split("\t"));
                            setSpreadsheetData(rows);
                            setIsSpreadsheetMode(true);
                          }}
                          className="
                ml-4 bg-[#303030] hover:bg-[#303030] text-white font-semibold 
                py-2 px-4 rounded-lg transition duration-300
                neon-button
                border border-white
              "
                        >
                          Turn into Spreadsheet
                        </button>
                      ) : (
                        <button
                          onClick={() => {
                            const textData = spreadsheetData
                              .map((row) => row.join("\t"))
                              .join("\n");
                            setImportDataText(textData);
                            setIsSpreadsheetMode(false);
                          }}
                          className="
                ml-4 bg-[#303030] hover:bg-[#303030] text-white font-semibold 
                py-2 px-4 rounded-lg transition duration-300
                neon-button
                border border-white
              "
                        >
                          Switch to Text
                        </button>
                      )}
                    </div>

                    {!isSpreadsheetMode ? (
                      <>
                        <textarea
                          value={importDataText}
                          onChange={(e) => setImportDataText(e.target.value)}
                          rows="5"
                          className="
                w-full mt-2 p-3 
                bg-black bg-opacity-50
                border border-[#303030]
                rounded-lg 
                focus:outline-none focus:ring-2 focus:ring-[#303030]
                text-[#303030]
                hover:bg-opacity-70
                transition duration-300
              "
                          placeholder="Enter your data here (e.g.: label, eventIntervention, eventComparison for dichotomous)..."
                        ></textarea>
                        <p className="text-[#303030] mt-2 text-sm">
                          Please enter your data with tab-separated values. Each
                          line represents a variable. For example, for a
                          dichotomous variable:
                          <br />
                          <code>MyOutcome&nbsp;&nbsp;25&nbsp;&nbsp;30</code>
                        </p>
                      </>
                    ) : (
                      /* If in Spreadsheet Mode, render a table-based editor */
                      <div className="overflow-auto mt-4 max-h-64 border border-[#303030] rounded-lg">
                        <table className="w-full border-collapse relative bg-black bg-opacity-40">
                          <thead className="sticky top-0 bg-[#303030]">
                            <tr>
                              <th className="border border-[#303030] p-1"></th>
                              {spreadsheetData[0] &&
                                spreadsheetData[0].map((_, colIndex) => (
                                  <th
                                    key={colIndex}
                                    className="
                          border border-[#303030] p-1 
                          text-[#303030] relative
                        "
                                    onMouseEnter={() =>
                                      setHoveredColIndex(colIndex)
                                    }
                                    onMouseLeave={() =>
                                      setHoveredColIndex(null)
                                    }
                                  >
                                    {hoveredColIndex === colIndex && (
                                      <div className="absolute inset-0 flex items-center justify-center z-10 space-x-1">
                                        <button
                                          onClick={() => addColumn(colIndex)}
                                          className="bg-green-700 text-white p-1 rounded hover:bg-green-800 pointer-events-auto text-base"
                                          title="Add Column Left"
                                        >
                                          +
                                        </button>
                                        <button
                                          onClick={() => removeColumn(colIndex)}
                                          className="bg-red-700 text-white p-1 rounded hover:bg-red-800 pointer-events-auto text-base"
                                          title="Remove Column"
                                        >
                                          &times;
                                        </button>
                                        <button
                                          onClick={() =>
                                            addColumn(colIndex + 1)
                                          }
                                          className="bg-green-700 text-white p-1 rounded hover:bg-green-800 pointer-events-auto text-base"
                                          title="Add Column Right"
                                        >
                                          +
                                        </button>
                                      </div>
                                    )}
                                  </th>
                                ))}
                            </tr>
                          </thead>
                          <tbody>
                            {spreadsheetData.map((row, rowIndex) => (
                              <tr key={rowIndex}>
                                <td
                                  className="border border-[#303030] p-1 bg-[#303030] relative text-[#303030]"
                                  onMouseEnter={() =>
                                    setHoveredRowIndex(rowIndex)
                                  }
                                  onMouseLeave={() => setHoveredRowIndex(null)}
                                >
                                  {hoveredRowIndex === rowIndex && (
                                    <div className="absolute inset-0 flex flex-col items-center justify-center z-10 space-y-1">
                                      <button
                                        onClick={() => addRow(rowIndex)}
                                        className="bg-green-700 text-white p-1 rounded hover:bg-green-800 pointer-events-auto text-base"
                                        title="Add Row Above"
                                      >
                                        +
                                      </button>
                                      <button
                                        onClick={() => removeRow(rowIndex)}
                                        className="bg-red-700 text-white p-1 rounded hover:bg-red-800 pointer-events-auto text-base"
                                        title="Remove Row"
                                      >
                                        &times;
                                      </button>
                                      <button
                                        onClick={() => addRow(rowIndex + 1)}
                                        className="bg-green-700 text-white p-1 rounded hover:bg-green-800 pointer-events-auto text-base"
                                        title="Add Row Below"
                                      >
                                        +
                                      </button>
                                    </div>
                                  )}
                                </td>
                                {row.map((cell, colIndex) => (
                                  <td
                                    key={colIndex}
                                    className="border border-[#303030] p-1 hover:bg-[#303030] transition duration-150"
                                  >
                                    <input
                                      type="text"
                                      value={cell}
                                      onClick={(e) => e.stopPropagation()}
                                      onFocus={() => {
                                        setFocusedCell({
                                          rowIndex,
                                          colIndex,
                                          value: cell,
                                        });
                                      }}
                                      readOnly
                                      className="
                            w-full bg-black bg-opacity-50 rounded-lg p-2 
                            text-[#303030]
                            focus:outline-none cursor-pointer
                            hover:bg-black hover:bg-opacity-60
                            transition duration-300
                          "
                                    />
                                  </td>
                                ))}
                              </tr>
                            ))}
                          </tbody>
                        </table>

                        {/* Cell Overlay Editor */}
                        {focusedCell && (
                          <div className="fixed inset-0 flex items-center justify-center z-50">
                            <div
                              className="absolute inset-0 bg-black opacity-80"
                              onClick={() => setFocusedCell(null)}
                            ></div>
                            <div
                              className="
                    bg-gradient-to-br from-gray-900 via-[#303030] to-gray-900
                    text-[#303030] p-6 rounded-xl z-50 w-11/12 md:w-2/3 lg:w-1/2
                    border border-[#303030] shadow-xl
                  "
                            >
                              <h2 className="text-2xl font-bold mb-4 text-[#303030] uppercase">
                                Edit Cell
                              </h2>
                              <textarea
                                value={focusedCell.value}
                                onChange={(e) => {
                                  const newValue = e.target.value;
                                  setFocusedCell({
                                    ...focusedCell,
                                    value: newValue,
                                  });
                                  const newSpreadsheetData = [
                                    ...spreadsheetData,
                                  ];
                                  newSpreadsheetData[focusedCell.rowIndex][
                                    focusedCell.colIndex
                                  ] = newValue;
                                  setSpreadsheetData(newSpreadsheetData);
                                }}
                                rows="6"
                                className="
                      w-full p-3 
                      bg-black bg-opacity-50
                      border border-[#303030]
                      rounded-lg 
                      focus:outline-none focus:ring-2 focus:ring-[#303030]
                      text-[#303030]
                      hover:bg-opacity-70
                      transition duration-300
                    "
                              ></textarea>
                              <div className="mt-6 flex justify-end space-x-4">
                                <button
                                  onClick={() => setFocusedCell(null)}
                                  className="
                        bg-[#303030] hover:bg-[#303030] text-white font-semibold 
                        py-2 px-4 rounded-lg transition duration-300
                        neon-button
                      "
                                >
                                  Close
                                </button>
                              </div>
                            </div>
                          </div>
                        )}
                      </div>
                    )}
                  </div>

                  {/* Footer Buttons: Close & Add Dataset */}
                  <div className="mt-6 flex justify-end space-x-4">
                    <button
                      onClick={closeImportModal}
                      className="
            bg-[#303030] hover:bg-[#303030] text-white font-semibold 
            py-2 px-4 rounded-lg transition duration-300
            neon-button
          "
                    >
                      Close
                    </button>
                    <button
                      onClick={handleAddDataset}
                      className="
            bg-green-700 hover:bg-green-800 text-white font-semibold 
            py-2 px-6 rounded-lg transition duration-300 flex items-center
            neon-button
          "
                    >
                      <i className="fas fa-plus mr-2"></i> Add Dataset
                    </button>
                  </div>
                </div>
              </div>
            )}
            {isMultipleVarModalOpen && (
              <div className="fixed inset-0 z-50 flex items-center justify-center">
                {/* Dim Overlay with slight blur */}
                <div
                  className="absolute inset-0 bg-black bg-opacity-50 backdrop-blur-sm"
                  onClick={closeMultiVarModal}
                />

                {/* Modal Container */}
                <div
                  className="
        relative max-w-3xl w-full mx-4 
        bg-gray-800 text-gray-100 
        rounded-xl shadow-2xl 
        p-6 sm:p-8 
        overflow-y-auto
        animate-fadeIn
      "
                  style={{ maxHeight: "90vh" }}
                >
                  {/* Close Button (Icon) */}
                  <button
                    className="absolute top-4 right-4 text-gray-400 hover:text-gray-200 transition-colors"
                    onClick={closeMultiVarModal}
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      className="h-6 w-6"
                      fill="none"
                      viewBox="0 0 24 24"
                      stroke="currentColor"
                      strokeWidth={2}
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        d="M6 18L18 6M6 6l12 12"
                      />
                    </svg>
                  </button>

                  {/* Title */}
                  <h2 className="text-2xl font-bold mb-4">
                    Add Multiple Variables
                  </h2>

                  {/* 
         If you need additional controls like 
         1) Baseline/Outcomes, 2) Variable Type, 
         3) Data Entry Mode, they can go here
         in a grid or flex layout.
      */}

                  {/* Textarea for variable names */}
                  <div className="mt-4">
                    <label className="block font-semibold mb-2">
                      Variable Names
                    </label>
                    <textarea
                      rows={8}
                      value={multiVarText}
                      onChange={(e) => setMultiVarText(e.target.value)}
                      placeholder="Enter variable names separated by comma, tab, or newline..."
                      className="
            w-full p-3 
            bg-gray-700 text-gray-100 
            border border-gray-600 
            rounded-lg
            focus:outline-none focus:ring-2 focus:ring-green-500
            placeholder-gray-400
          "
                    />
                  </div>

                  {/* Footer Buttons */}
                  <div className="mt-6 flex justify-end space-x-4">
                    <button
                      onClick={closeMultiVarModal}
                      className="
            py-2 px-4 rounded-lg 
            font-semibold
            bg-gray-600 hover:bg-gray-500 
            transition-colors
          "
                    >
                      Cancel
                    </button>
                    <button
                      onClick={handleAddMultipleVariables}
                      className="
            py-2 px-4 rounded-lg 
            font-semibold text-white
            bg-green-600 hover:bg-green-700 
            transition-colors
          "
                    >
                      Add
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* Delete Confirmation Modal */}
            {showDeleteModal && (
              <div className="fixed inset-0 flex items-center justify-center z-50">
                <div className="absolute inset-0 bg-black opacity-50"></div>
                <div className="bg-gray-900 text-gray-100 p-6 rounded-lg z-50 w-11/12 md:w-2/3 lg:w-1/2">
                  <h2 className="text-xl font-bold mb-4">Confirm Deletion</h2>
                  <p>Are you sure you want to delete this variable?</p>
                  <div className="mt-6 flex justify-end space-x-4">
                    <button
                      onClick={() => {
                        setShowDeleteModal(false);
                        setVariableToDelete(null);
                      }}
                      className="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
                    >
                      No
                    </button>
                    <button
                      onClick={() => {
                        // Proceed to delete the variable
                        const selectedStudyId =
                          inputValues.selectedStudyId || studyIds[0];
                        const studyVars = variables[selectedStudyId]
                          ? [...variables[selectedStudyId]]
                          : [];

                        const index = studyVars.findIndex(
                          (v) => v.id === variableToDelete
                        );
                        if (index === -1) return;

                        // Remove the variable
                        studyVars.splice(index, 1);

                        setVariables({
                          ...variables,
                          [selectedStudyId]: studyVars,
                        });

                        // Update variablesOrder
                        setVariablesOrder((prevOrder) => {
                          const newOrder = { ...prevOrder };
                          newOrder[selectedStudyId] = studyVars.map(
                            (v) => v.id
                          );
                          return newOrder;
                        });

                        // If currently editing this variable, cancel edit
                        if (editVariableId === variableToDelete) {
                          handleCancelEdit();
                        }

                        setShowDeleteModal(false);
                        setVariableToDelete(null);
                      }}
                      className="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
                    >
                      Yes
                    </button>
                  </div>
                </div>
              </div>
            )}

            <div className="mt-8">
              <h2 className="text-xl font-bold mb-4">
                Variables for {inputValues.selectedStudyId || studyIds[0]}
              </h2>
              {getDisplayedVariables().length > 0 ? (
                <div className="overflow-x-auto">
                  <table className="w-full table-auto border-collapse">
                    <thead>
                      <tr>
                        <th className="border-b-2 border-gray-700 px-4 py-2 text-left">
                          Label
                        </th>
                        <th className="border-b-2 border-gray-700 px-4 py-2 text-left">
                          Type
                        </th>
                        <th className="border-b-2 border-gray-700 px-4 py-2 text-left">
                          Value
                        </th>
                        <th className="border-b-2 border-gray-700 px-4 py-2 text-left"></th>
                      </tr>
                    </thead>
                    <tbody>
                      {getDisplayedVariables().map((variable, index) => (
                        <tr
                          key={variable.id}
                          className={`hover:bg-gray-800 ${
                            index % 2 === 0 ? "bg-gray-900" : "bg-gray-800"
                          } cursor-pointer`}
                          draggable="true"
                          onDragStart={(e) => handleDragStart(e, variable.id)}
                          onDragOver={(e) => handleDragOver(e, variable.id)}
                          onDrop={handleDrop}
                          onDragEnd={handleDragEnd}
                          onClick={() => handleEditVariable(variable.id)}
                        >
                          <td className="px-4 py-2">{variable.label}</td>
                          <td className="px-4 py-2 capitalize">
                            {variable.type || "Text"}
                          </td>
                          <td className="px-4 py-2 whitespace-pre-wrap break-all max-w-xs">
                            {(() => {
                              // SINGLE placeholder baseline variable
                              if (variable.isSinglePlaceholder) {
                                return (
                                  variable.value || (
                                    <span className="text-gray-500">
                                      Missing
                                    </span>
                                  )
                                );
                              }

                              // INTERVENTION + COMPARISON LOGIC
                              if (groupType === "intervention_comparison") {
                                if (variable.armType === "double") {
                                  // ---------- DOUBLE-ARM ----------
                                  if (variable.type === "dichotomous") {
                                    // Show "Intervention: events / total", "Comparison: events / total"
                                    const iEvents =
                                      variable.value.intervention || "";
                                    const iTotal =
                                      variable.value.interventionTotal || "";
                                    const cEvents =
                                      variable.value.comparison || "";
                                    const cTotal =
                                      variable.value.comparisonTotal || "";

                                    return (
                                      <>
                                        <span className="font-semibold">
                                          {groupNames.interventionName}:
                                        </span>{" "}
                                        {iEvents !== "" ? (
                                          iEvents
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {" / "}
                                        {iTotal !== "" ? (
                                          iTotal
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        ,{" "}
                                        <span className="font-semibold">
                                          {groupNames.comparisonName}:
                                        </span>{" "}
                                        {cEvents !== "" ? (
                                          cEvents
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {" / "}
                                        {cTotal !== "" ? (
                                          cTotal
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                      </>
                                    );
                                  } else if (variable.type === "continuous") {
                                    // Show "Intervention: mean / sd / total", "Comparison: mean / sd / total"
                                    const iMean =
                                      variable.value.intervention.mean || "";
                                    const iSd =
                                      variable.value.intervention.sd || "";
                                    const iTotal =
                                      variable.value.interventionTotal || "";
                                    const cMean =
                                      variable.value.comparison.mean || "";
                                    const cSd =
                                      variable.value.comparison.sd || "";
                                    const cTotal =
                                      variable.value.comparisonTotal || "";

                                    return (
                                      <>
                                        <span className="font-semibold">
                                          {groupNames.interventionName}:
                                        </span>{" "}
                                        {iMean !== "" ? (
                                          `Mean=${iMean}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {iSd !== "" ? (
                                          `SD=${iSd}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {iTotal !== "" ? (
                                          `Total=${iTotal}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        ;{" "}
                                        <span className="font-semibold">
                                          {groupNames.comparisonName}:
                                        </span>{" "}
                                        {cMean !== "" ? (
                                          `Mean=${cMean}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {cSd !== "" ? (
                                          `SD=${cSd}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {cTotal !== "" ? (
                                          `Total=${cTotal}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                      </>
                                    );
                                  } else if (variable.type === "text") {
                                    // Show "Intervention: text / total", "Comparison: text / total"
                                    const iText =
                                      variable.value.intervention || "";
                                    const iTotal =
                                      variable.value.interventionTotal || "";
                                    const cText =
                                      variable.value.comparison || "";
                                    const cTotal =
                                      variable.value.comparisonTotal || "";

                                    return (
                                      <>
                                        <span className="font-semibold">
                                          {groupNames.interventionName}:
                                        </span>{" "}
                                        {iText !== "" ? (
                                          iText
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {iTotal !== "" ? (
                                          `Total=${iTotal}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        ;{" "}
                                        <span className="font-semibold">
                                          {groupNames.comparisonName}:
                                        </span>{" "}
                                        {cText !== "" ? (
                                          cText
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {cTotal !== "" ? (
                                          `Total=${cTotal}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                      </>
                                    );
                                  } else if (
                                    variable.type === "population_size"
                                  ) {
                                    // Double-arm population => Intervention vs. Comparison
                                    const iPop =
                                      variable.value.interventionPop || "";
                                    const cPop =
                                      variable.value.comparisonPop || "";
                                    return (
                                      <>
                                        <span className="font-semibold">
                                          {groupNames.interventionName}:
                                        </span>{" "}
                                        {iPop !== "" ? (
                                          iPop
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        ,{" "}
                                        <span className="font-semibold">
                                          {groupNames.comparisonName}:
                                        </span>{" "}
                                        {cPop !== "" ? (
                                          cPop
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                      </>
                                    );
                                  }
                                } else {
                                  // ---------- SINGLE-ARM in an intervention+comparison environment ----------
                                  if (variable.type === "dichotomous") {
                                    // events / total
                                    const e = variable.value.events || "";
                                    const t = variable.value.total || "";
                                    return (
                                      <>
                                        {e !== "" ? (
                                          e
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {" / "}
                                        {t !== "" ? (
                                          t
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                      </>
                                    );
                                  } else if (variable.type === "continuous") {
                                    const m = variable.value.mean || "";
                                    const s = variable.value.sd || "";
                                    const t = variable.value.total || "";
                                    return (
                                      <>
                                        {m !== "" ? (
                                          `Mean=${m}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {s !== "" ? (
                                          `SD=${s}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {t !== "" ? (
                                          `Total=${t}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                      </>
                                    );
                                  } else if (variable.type === "text") {
                                    // text, total
                                    const txt = variable.value.text || "";
                                    const t = variable.value.total || "";
                                    return (
                                      <>
                                        {txt !== "" ? (
                                          txt
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {t !== "" ? `, Total=${t}` : null}
                                      </>
                                    );
                                  } else if (
                                    variable.type === "population_size"
                                  ) {
                                    // Single-arm population
                                    const pop = variable.value.population || "";
                                    return (
                                      <>
                                        <span className="font-semibold">
                                          Population:
                                        </span>{" "}
                                        {pop !== "" ? (
                                          pop
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                      </>
                                    );
                                  }
                                }
                              } else {
                                // ---------- SINGLE-ARM (Intervention only) ----------
                                if (variable.type === "dichotomous") {
                                  // events / total
                                  const e = variable.value.events || "";
                                  const t = variable.value.total || "";
                                  return (
                                    <>
                                      {e !== "" ? (
                                        e
                                      ) : (
                                        <span className="text-gray-500">
                                          Missing
                                        </span>
                                      )}
                                      {" / "}
                                      {t !== "" ? (
                                        t
                                      ) : (
                                        <span className="text-gray-500">
                                          Missing
                                        </span>
                                      )}
                                    </>
                                  );
                                } else if (variable.type === "continuous") {
                                  const m = variable.value.mean || "";
                                  const s = variable.value.sd || "";
                                  const t = variable.value.total || "";
                                  return (
                                    <>
                                      {m !== "" ? (
                                        `Mean=${m}`
                                      ) : (
                                        <span className="text-gray-500">
                                          Missing
                                        </span>
                                      )}
                                      {", "}
                                      {s !== "" ? (
                                        `SD=${s}`
                                      ) : (
                                        <span className="text-gray-500">
                                          Missing
                                        </span>
                                      )}
                                      {", "}
                                      {t !== "" ? (
                                        `Total=${t}`
                                      ) : (
                                        <span className="text-gray-500">
                                          Missing
                                        </span>
                                      )}
                                    </>
                                  );
                                } else if (variable.type === "text") {
                                  const txt = variable.value.text || "";
                                  const t = variable.value.total || "";
                                  return (
                                    <>
                                      {txt !== "" ? (
                                        txt
                                      ) : (
                                        <span className="text-gray-500">
                                          Missing
                                        </span>
                                      )}
                                      {t !== "" ? `, Total=${t}` : null}
                                    </>
                                  );
                                } else if (
                                  variable.type === "population_size"
                                ) {
                                  const pop = variable.value.population || "";
                                  return (
                                    <>
                                      <span className="font-semibold">
                                        Population:
                                      </span>{" "}
                                      {pop !== "" ? (
                                        pop
                                      ) : (
                                        <span className="text-gray-500">
                                          Missing
                                        </span>
                                      )}
                                    </>
                                  );
                                }
                              }

                              // fallback if nothing else matched
                              return (
                                <span className="text-gray-500">Missing</span>
                              );
                            })()}
                          </td>
                          <td className="px-4 py-2 text-center w-20 whitespace-nowrap">
                            {/* EDIT BUTTON (SVG) */}
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                handleEditVariable(variable.id);
                              }}
                              // Shrink margin and add a bit of padding if you want smaller clickable space
                              className="text-blue-500 hover:text-blue-700 mr-1 p-1"
                            >
                              <svg
                                xmlns="http://www.w3.org/2000/svg"
                                viewBox="0 0 512 512"
                                // Change from w-5 h-5 to w-4 h-4 (or even w-3 h-3 if you prefer)
                                className="w-4 h-4 fill-current"
                              >
                                <path d="M471.6 21.7c-21.9-21.9-57.3-21.9-79.2 0L362.3 51.7l97.9 97.9 30.1-30.1c21.9-21.9 21.9-57.3 0-79.2L471.6 21.7zm-299.2 220c-6.1 6.1-10.8 13.6-13.5 21.9l-29.6 88.8c-2.9 8.6-.6 18.1 5.8 24.6s15.9 8.7 24.6 5.8l88.8-29.6c8.2-2.7 15.7-7.4 21.9-13.5L437.7 172.3 339.7 74.3 172.4 241.7zM96 64C43 64 0 107 0 160L0 416c0 53 43 96 96 96l256 0c53 0 96-43 96-96l0-96c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7-14.3 32-32 32L96 448c-17.7 0-32-14.3-32-32l0-256c0-17.7 14.3-32 32-32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L96 64z" />
                              </svg>
                            </button>

                            {/* DELETE BUTTON (SVG) */}
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                handleDeleteVariable(variable.id);
                              }}
                              // Again, shrink spacing and/or padding as needed
                              className="text-red-500 hover:text-red-700 p-1"
                            >
                              <svg
                                xmlns="http://www.w3.org/2000/svg"
                                viewBox="0 0 448 512"
                                className="w-4 h-4 fill-current"
                              >
                                <path d="M135.2 17.7L128 32 32 32C14.3 32 0 46.3 0 64S14.3 96 32 96l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0-7.2-14.3C307.4 6.8 296.3 0 284.2 0L163.8 0c-12.1 0-23.2 6.8-28.6 17.7zM416 128L32 128 53.2 467c1.6 25.3 22.6 45 47.9 45l245.8 0c25.3 0 46.3-19.7 47.9-45L416 128z" />
                              </svg>
                            </button>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              ) : (
                <p className="text-gray-400">
                  No variables added for this study.
                </p>
              )}
            </div>

            <div className="flex flex-col md:flex-row justify-between mt-8 space-y-4 md:space-y-0">
              <button
                onClick={onBack}
                className="w-full md:w-auto bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
              >
                <i className="fas fa-arrow-left mr-2"></i> Back
              </button>
              <button
                onClick={onPreview}
                className="w-full md:w-auto bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
              >
                Preview <i className="fas fa-eye ml-2"></i>
              </button>
            </div>
          </div>
        );
      }

      // Existing suggestions
      const suggestedBaselineLabels = [
        "Population",
        "Intervention",
        "Control group",
        "All outcomes",
        "Primary Outcomes",
        "Secondary Outcomes",
        "Study design",
        "Outcome assessment dates",
        "Timing (Start to End Date)",
        "Setting (Ambulatory, Inpatient...)",
        "Institution",
        "Country",
      ];

      function PreviewScreen({
        studyIds,
        baselineVariables,
        outcomesVariables,
        groupType,
        groupNames,
        onBack,
        onBackupDownload,
      }) {
        const [previewOption, setPreviewOption] = useState("baseline");
        const [missingDataRepresentation, setMissingDataRepresentation] =
          useState("");
        const [customMissingValue, setCustomMissingValue] = useState("");
        const [weightVariable, setWeightVariable] = useState("");
        const [isWeightOpen, setIsWeightOpen] = useState(false);
        const [sortOrder, setSortOrder] = useState("addition");
        // NEW CODE START: State and logic for Google Drive modal
        const [isDriveModalOpen, setIsDriveModalOpen] = useState(false);
        const [driveLinks, setDriveLinks] = useState({
          "Backup Files": [],
          "Spreadsheet Files": [],
          "Variable Files": [],
        });
        const [selectedDriveCategory, setSelectedDriveCategory] =
          useState("Backup Files");
        const [newDriveLink, setNewDriveLink] = useState("");

        useEffect(() => {
          const handleClickOutside = (event) => {
            if (isWeightOpen && !event.target.closest(".relative")) {
              setIsWeightOpen(false);
            }
          };
          document.addEventListener("click", handleClickOutside);
          return () =>
            document.removeEventListener("click", handleClickOutside);
        }, [isWeightOpen]);

        // Load links from localStorage on mount
        useEffect(() => {
          const storedLinks = JSON.parse(
            localStorage.getItem("driveLinks")
          ) || {
            "Backup Files": [],
            "Spreadsheet Files": [],
            "Variable Files": [],
          };
          setDriveLinks(storedLinks);
        }, []);

        const openDriveModal = () => {
          setIsDriveModalOpen(true);
        };

        const closeDriveModal = () => {
          setIsDriveModalOpen(false);
        };

        const handleAddDriveLink = () => {
          if (!newDriveLink.trim()) return;
          const updatedLinks = { ...driveLinks };
          updatedLinks[selectedDriveCategory].push(newDriveLink.trim());
          setDriveLinks(updatedLinks);
          setNewDriveLink("");

          // Save to localStorage
          localStorage.setItem("driveLinks", JSON.stringify(updatedLinks));
        };

const handlePicoDownload = () => {
  // Combine suggested labels, ensuring no duplicates
  const allBaselineLabels = [...new Set([...suggestedBaselineLabels, ...additionalBaselineSuggestions])];

  // Special labels for outcomes parsing
  const specialOutcomeLabels = ["All outcomes", "Primary Outcomes", "Secondary Outcomes"];

  // Prepare worksheet data
  const ws_data = [];

  // Row 1: Study # and numbers 1 to n
  const row1 = ["Study #"];
  studyIds.forEach((_, idx) => row1.push(idx + 1));
  ws_data.push(row1);

  // Row 2: Study ID and the IDs
  const row2 = ["Study ID", ...studyIds];
  ws_data.push(row2);

  // Helper to check if a label has data in at least one study
  const hasDataForLabel = (label) => {
    return studyIds.some((studyId) => {
      const studyVars = baselineVariables[studyId] || [];
      const variable = studyVars.find((v) => v.label === label);
      if (!variable) return false;
      const formattedValue = formatVariableValue(variable);
      return formattedValue && formattedValue !== getMissingValue();
    });
  };

  // Filter normal labels (exclude special outcomes for now, and omit if no data)
  const normalLabels = allBaselineLabels
    .filter(label => !specialOutcomeLabels.includes(label))
    .filter(hasDataForLabel);

  // Add rows for normal baseline labels (length 1 + studyIds.length)
  normalLabels.forEach((label) => {
    const row = [label];
    studyIds.forEach((studyId) => {
      const studyVars = baselineVariables[studyId] || [];
      const variable = studyVars.find((v) => v.label === label);
      const formattedValue = variable ? formatVariableValue(variable) : getMissingValue();
      row.push(formattedValue);
    });
    ws_data.push(row);
  });

  // Now add the special outcome labels at the bottom, only if they have data
  specialOutcomeLabels.forEach((label, idx) => {
    // Check if this special label has data in at least one study
    const hasData = studyIds.some((studyId) => {
      const textValue = getTextValue(studyId, label, baselineVariables);
      return textValue && textValue.trim() !== "";
    });

    if (!hasData) return; // Omit if no data for this label

    // First, add the full text row for the label (length 1 + studyIds.length)
    const fullRow = [label];
    studyIds.forEach((studyId) => {
      const textValue = getTextValue(studyId, label, baselineVariables);
      fullRow.push(textValue || getMissingValue());
    });
    ws_data.push(fullRow);

    // Add the "COUNTING [LABEL] RECURRENCE:" header row in the last column
    const headerRow = Array(1 + studyIds.length).fill(""); // Empties for col1 and study columns
    headerRow.push(`COUNTING ${label.toUpperCase()} RECURRENCE:`); // Place in count column
    ws_data.push(headerRow);

    // Collect unique outcomes across all studies for this label
    const uniqueOutcomes = new Set();
    studyIds.forEach((studyId) => {
      const textValue = getTextValue(studyId, label, baselineVariables);
      if (textValue) {
        const outcomes = textValue.split(/,\s*/).map((o) => o.trim()).filter(Boolean);
        outcomes.forEach((o) => uniqueOutcomes.add(o));
      }
    });

    // Sort unique outcomes alphabetically
    const sortedUnique = Array.from(uniqueOutcomes).sort((a, b) => a.localeCompare(b));

    // For each unique outcome, add a row with TRUE/FALSE and count at end (length 1 + studyIds.length + 1)
    sortedUnique.forEach((outcome) => {
      const outcomeRow = [outcome];
      let trueCount = 0;
      studyIds.forEach((studyId) => {
        const textValue = getTextValue(studyId, label, baselineVariables);
        let hasOutcome = false;
        if (textValue) {
          const outcomes = textValue.split(/,\s*/).map((o) => o.trim());
          hasOutcome = outcomes.includes(outcome);
        }
        outcomeRow.push(hasOutcome ? "TRUE" : "FALSE");
        if (hasOutcome) trueCount++;
      });
      outcomeRow.push(trueCount); // Add count at end
      ws_data.push(outcomeRow);
    });

    // Add an empty row after this outcomes type block (except after the last one, but since user said after types, add after each)
    const emptyRow = Array(1 + studyIds.length + 1).fill(""); // Full empty row including count column
    ws_data.push(emptyRow);
  });

  // Create workbook and sheet
  const wb = XLSX.utils.book_new();
  const ws = XLSX.utils.aoa_to_sheet(ws_data);
  XLSX.utils.book_append_sheet(wb, ws, "PICO Table");

  // Generate filename with timestamp
  const timestamp = new Date().toISOString().slice(0, 19).replace("T", "_").replace(/:/g, "-");
  const filename = `PICO_Table_${timestamp}.xlsx`;

  // Download
  XLSX.writeFile(wb, filename);
};

const formatVariableValue = (variable) => {
  if (!variable) return getMissingValue();

  if (variable.isSinglePlaceholder || variable.type === "text") {
    return variable.value || getMissingValue();
  } else if (variable.type === "dichotomous") {
    if (groupType === "intervention_comparison" && variable.armType === "double") {
      return `${variable.value.intervention || getMissingValue()}/${variable.value.interventionTotal || getMissingValue()} / ${variable.value.comparison || getMissingValue()}/${variable.value.comparisonTotal || getMissingValue()}`;
    } else {
      return `${variable.value.events || getMissingValue()}/${variable.value.total || getMissingValue()}`;
    }
  } else if (variable.type === "continuous") {
    if (groupType === "intervention_comparison" && variable.armType === "double") {
      return `${variable.value.intervention.mean || getMissingValue()} ± ${variable.value.intervention.sd || getMissingValue()} / ${variable.value.comparison.mean || getMissingValue()} ± ${variable.value.comparison.sd || getMissingValue()}`;
    } else {
      return `${variable.value.mean || getMissingValue()} ± ${variable.value.sd || getMissingValue()}`;
    }
  } else if (variable.type === "population_size") {
    if (groupType === "intervention_comparison" && variable.armType === "double") {
      return `${variable.value.interventionPop || getMissingValue()} / ${variable.value.comparisonPop || getMissingValue()}`;
    } else {
      return variable.value.population || getMissingValue();
    }
  }
  return getMissingValue();
};

const getTextValue = (studyId, label, variablesToUse) => {
  const studyVars = variablesToUse[studyId] || [];
  const variable = studyVars.find((v) => v.label === label);
  return variable && variable.type === "text" ? variable.value : "";
};
        // New state variables for the modal and options
        const [isDownloadModalOpen, setIsDownloadModalOpen] = useState(false);
        const [selectedFormat, setSelectedFormat] = useState("RevMan");
        const [selectedPopulationVariable, setSelectedPopulationVariable] =
          useState("");
        const [onlyCompleteStudies, setOnlyCompleteStudies] = useState(false);

        function getMissingValue() {
          if (missingDataRepresentation === "custom") {
            return customMissingValue;
          }
          return missingDataRepresentation;
        }

        function getWeightVariableOptions() {
          const variableLabelsSet = new Set();

          const variablesList = [baselineVariables, outcomesVariables];

          variablesList.forEach((variablesToUse) => {
            Object.values(variablesToUse).forEach((studyVars) => {
              studyVars.forEach((variable) => {
                // Only consider numerical variables, *including population_size*
                if (
                  variable.type === "dichotomous" ||
                  variable.type === "continuous" ||
                  variable.type === "population_size" // ADDED population_size HERE
                ) {
                  variableLabelsSet.add(variable.label);
                }
              });
            });
          });

          return Array.from(variableLabelsSet);
        }

        const removeDriveLink = (category, linkIndex) => {
          const updatedLinks = { ...driveLinks };
          updatedLinks[category].splice(linkIndex, 1); // Remove the link at that index
          setDriveLinks(updatedLinks);
          localStorage.setItem("driveLinks", JSON.stringify(updatedLinks)); // Re-save to localStorage
        };

        function getPopulationVariableOptions() {
          const variableLabelsSet = new Set();

          // Collect the relevant datasets based on previewOption
          let datasets = [];
          if (previewOption === "baseline") {
            datasets.push(baselineVariables);
          } else if (previewOption === "outcomes") {
            datasets.push(outcomesVariables);
          } else if (
            previewOption === "both" ||
            previewOption === "recurrent"
          ) {
            datasets.push(baselineVariables, outcomesVariables);
          }

          // Gather variable labels for dichotomous, continuous, or population_size
          datasets.forEach((variablesToUse) => {
            Object.values(variablesToUse).forEach((studyVars) => {
              studyVars.forEach((variable) => {
                if (
                  variable.type === "dichotomous" ||
                  variable.type === "continuous" ||
                  variable.type === "population_size"
                ) {
                  variableLabelsSet.add(variable.label);
                }
              });
            });
          });

          // Convert to an array
          let allLabels = Array.from(variableLabelsSet);

          // If "Total Patients" already exists, remove it
          const indexTP = allLabels.indexOf("Total Patients");
          if (indexTP !== -1) {
            allLabels.splice(indexTP, 1);
          }

          // Insert "Total Patients" at the front
          allLabels.unshift("Total Patients");

          return allLabels;
        }

        function getAllVariableLabels() {
          const variableLabelsSet = new Set();

          // If user selected Baseline tab
          if (selectedOption === "baseline") {
            // Gather all baseline variables
            Object.values(baselineVariables).forEach((studyVars) => {
              studyVars.forEach((variable) => {
                variableLabelsSet.add(variable.label);
              });
            });

            // Include the built-in suggestions for baseline
            suggestedBaselineLabels.forEach((lbl) =>
              variableLabelsSet.add(lbl)
            );
            additionalBaselineSuggestions.forEach((lbl) =>
              variableLabelsSet.add(lbl)
            );
          } else if (selectedOption === "outcomes") {
            // Gather all outcomes variables
            Object.values(outcomesVariables).forEach((studyVars) => {
              studyVars.forEach((variable) => {
                variableLabelsSet.add(variable.label);
              });
            });
          }

          // Convert our Set to an array and return
          return Array.from(variableLabelsSet);
        }

        const openDownloadFolderModal = () => {
          setIsDownloadModalOpen(true);
          const options = getPopulationVariableOptions();
          if (options.length > 0) {
            setSelectedPopulationVariable(options[0]);
          } else {
            setSelectedPopulationVariable("");
          }
        };

        const closeDownloadFolderModal = () => {
          setIsDownloadModalOpen(false);
        };
        const additionalBaselineSuggestions = [
          "Population Size", // dichotomous
          "Male", // dichotomous
          "Female", // dichotomous
          "Age", // continuous
          "Follow-Up", // continuous
        ];
        // Snippet 2: Modify buildDataRows to support sorting
        function buildDataRows(
          variablesToUse,
          filterRecurrent = false,
          sortOrder = "addition",
          isBaseline = false
        ) {
          const variableLabelsOrdered = [];
          const addLabelIfNew = (label) => {
            if (!variableLabelsOrdered.includes(label)) {
              variableLabelsOrdered.push(label);
            }
          };
          const variableSubgroups = {};

          // Collect variable definitions and counts
          const variableDefinitions = {};
          const variableCounts = {};

          // Count occurrences of each variable label
          studyIds.forEach((studyId) => {
            const studyVars = variablesToUse[studyId] || [];
            const labelsInStudy = new Set();

            studyVars.forEach((variable) => {
              addLabelIfNew(variable.label);
              labelsInStudy.add(variable.label);

              if (!variableDefinitions[variable.label]) {
                variableDefinitions[variable.label] = {
                  types: new Set(),
                  armTypes: new Set(),
                  subgroups: new Set(),
                };
              }
              variableDefinitions[variable.label].types.add(variable.type);
              variableDefinitions[variable.label].armTypes.add(
                variable.armType
              );
            });

            labelsInStudy.forEach((label) => {
              variableCounts[label] = (variableCounts[label] || 0) + 1;
            });
          });

          // Filter variables if 'filterRecurrent' = true
          let filteredVariableLabels = variableLabelsOrdered;
          if (filterRecurrent) {
            filteredVariableLabels = filteredVariableLabels.filter(
              (label) => variableCounts[label] >= 2
            );
          }

          if (sortOrder === "alphabetical") {
            filteredVariableLabels.sort((a, b) => a.localeCompare(b));
          } else if (sortOrder === "fixed_alphabetical" && isBaseline) {
            const allFixed = [
              ...suggestedBaselineLabels,
              ...additionalBaselineSuggestions,
            ];
            const fixedLabels = allFixed.filter((label) =>
              filteredVariableLabels.includes(label)
            );
            const otherLabels = filteredVariableLabels
              .filter((label) => !allFixed.includes(label))
              .sort((a, b) => a.localeCompare(b));
            filteredVariableLabels = [...fixedLabels, ...otherLabels];
          } else if (sortOrder === "fixed_alphabetical" && !isBaseline) {
            filteredVariableLabels.sort((a, b) => a.localeCompare(b));
          }

          // Build subgroups for each label (the "column headings")
          filteredVariableLabels.forEach((label) => {
            const definition = variableDefinitions[label];
            const types = Array.from(definition.types);
            const armTypes = Array.from(definition.armTypes);
            const subgroups = new Set();

            types.forEach((type) => {
              if (type === "dichotomous") {
                if (groupType === "intervention_comparison") {
                  if (armTypes.includes("double")) {
                    // double-arm => events + total for both arms
                    subgroups.add(`${groupNames.interventionName} Events`);
                    subgroups.add(`${groupNames.interventionName} Total`);
                    subgroups.add(`${groupNames.comparisonName} Events`);
                    subgroups.add(`${groupNames.comparisonName} Total`);
                  }
                  if (armTypes.includes("single")) {
                    // single-arm => events + total
                    subgroups.add("Events");
                    subgroups.add("Total");
                  }
                } else {
                  // single-arm only (groupType === 'intervention'): events + total
                  subgroups.add("Events");
                  subgroups.add("Total");
                }
              } else if (type === "continuous") {
                if (groupType === "intervention_comparison") {
                  if (armTypes.includes("double")) {
                    // double-arm => mean / sd / total for both arms
                    subgroups.add(`${groupNames.interventionName} Mean`);
                    subgroups.add(`${groupNames.interventionName} SD`);
                    subgroups.add(`${groupNames.interventionName} Total`);
                    subgroups.add(`${groupNames.comparisonName} Mean`);
                    subgroups.add(`${groupNames.comparisonName} SD`);
                    subgroups.add(`${groupNames.comparisonName} Total`);
                  }
                  if (armTypes.includes("single")) {
                    // single-arm => mean / sd / total
                    subgroups.add("Mean");
                    subgroups.add("SD");
                    subgroups.add("Total");
                  }
                } else {
                  // single-arm only => mean / sd / total
                  subgroups.add("Mean");
                  subgroups.add("SD");
                  subgroups.add("Total");
                }
              } else if (type === "text") {
                // No "total" column for text
                if (suggestedBaselineLabels.includes(label)) {
                  // single column => label
                  subgroups.add("");
                } else {
                  if (groupType === "intervention_comparison") {
                    if (armTypes.includes("double")) {
                      subgroups.add(`${groupNames.interventionName} Text`);
                      subgroups.add(`${groupNames.comparisonName} Text`);
                    }
                    if (armTypes.includes("single")) {
                      // single-arm text => "Text Value"
                      subgroups.add("Text Value");
                    }
                  } else {
                    // single-arm only => single column => label
                    subgroups.add("");
                  }
                }
              } else if (type === "population_size") {
                // for sample sizes
                if (groupType === "intervention_comparison") {
                  if (armTypes.includes("double")) {
                    subgroups.add(`${groupNames.interventionName} Pop`);
                    subgroups.add(`${groupNames.comparisonName} Pop`);
                  }
                  if (armTypes.includes("single")) {
                    subgroups.add("Population");
                  }
                } else {
                  subgroups.add("Population");
                }
              }

              // ignore any other custom types not shown
            });

            variableSubgroups[label] = Array.from(subgroups);
          });

          const allVariableLabels = filteredVariableLabels;
          // ---------------------------------------------------
          // Build the data rows
          // ---------------------------------------------------
          const dataRows = studyIds.map((studyId) => {
            const studyVars = variablesToUse[studyId] || [];
            const varData = {};

            studyVars.forEach((variable) => {
              const label = variable.label;
              if (!filteredVariableLabels.includes(label)) return;

              const subs = variableSubgroups[label];

              // Handle single placeholder
              if (variable.isSinglePlaceholder) {
                varData[label] = variable.value || getMissingValue();
                return;
              }

              // If we are in an intervention_comparison setup:
              if (groupType === "intervention_comparison") {
                if (variable.armType === "double") {
                  // ---------- DOUBLE-ARM ----------
                  if (variable.type === "dichotomous") {
                    varData[`${label}_${groupNames.interventionName} Events`] =
                      variable.value.intervention || getMissingValue();
                    varData[`${label}_${groupNames.interventionName} Total`] =
                      variable.value.interventionTotal || getMissingValue();
                    varData[`${label}_${groupNames.comparisonName} Events`] =
                      variable.value.comparison || getMissingValue();
                    varData[`${label}_${groupNames.comparisonName} Total`] =
                      variable.value.comparisonTotal || getMissingValue();
                  } else if (variable.type === "continuous") {
                    varData[`${label}_${groupNames.interventionName} Mean`] =
                      variable.value.intervention.mean || getMissingValue();
                    varData[`${label}_${groupNames.interventionName} SD`] =
                      variable.value.intervention.sd || getMissingValue();
                    varData[`${label}_${groupNames.interventionName} Total`] =
                      variable.value.interventionTotal || getMissingValue();

                    varData[`${label}_${groupNames.comparisonName} Mean`] =
                      variable.value.comparison.mean || getMissingValue();
                    varData[`${label}_${groupNames.comparisonName} SD`] =
                      variable.value.comparison.sd || getMissingValue();
                    varData[`${label}_${groupNames.comparisonName} Total`] =
                      variable.value.comparisonTotal || getMissingValue();
                  } else if (variable.type === "text") {
                    varData[`${label}_${groupNames.interventionName} Text`] =
                      variable.value.intervention || getMissingValue();
                    varData[`${label}_${groupNames.comparisonName} Text`] =
                      variable.value.comparison || getMissingValue();
                  } else if (variable.type === "population_size") {
                    varData[`${label}_${groupNames.interventionName} Pop`] =
                      variable.value.interventionPop || getMissingValue();
                    varData[`${label}_${groupNames.comparisonName} Pop`] =
                      variable.value.comparisonPop || getMissingValue();
                  }
                } else {
                  // ---------- SINGLE-ARM in an intervention+comparison environment ----------
                  if (variable.type === "dichotomous") {
                    // we expect variable.value = { events, total }
                    varData[`${label}_Events`] =
                      variable.value.events || getMissingValue();
                    varData[`${label}_Total`] =
                      variable.value.total || getMissingValue();
                  } else if (variable.type === "continuous") {
                    varData[`${label}_Mean`] =
                      variable.value.mean || getMissingValue();
                    varData[`${label}_SD`] =
                      variable.value.sd || getMissingValue();
                    varData[`${label}_Total`] =
                      variable.value.total || getMissingValue();
                  } else if (variable.type === "text") {
                    // single-arm text => variable.value = { text } (or just a string)
                    varData[`${label}_Text Value`] =
                      variable.value.text ||
                      variable.value ||
                      getMissingValue();
                  } else if (variable.type === "population_size") {
                    // single-arm population => variable.value = { population }
                    varData[`${label}_Population`] =
                      variable.value.population || getMissingValue();
                  }
                }
              } else {
                // ---------- SINGLE-ARM, SINGLE GROUP (no comparison) ----------
                if (variable.type === "dichotomous") {
                  // variable.value = { events, total }
                  varData[`${label}_Events`] =
                    variable.value.events || getMissingValue();
                  varData[`${label}_Total`] =
                    variable.value.total || getMissingValue();
                } else if (variable.type === "continuous") {
                  // variable.value = { mean, sd, total }
                  varData[`${label}_Mean`] =
                    variable.value.mean || getMissingValue();
                  varData[`${label}_SD`] =
                    variable.value.sd || getMissingValue();
                  varData[`${label}_Total`] =
                    variable.value.total || getMissingValue();
                } else if (variable.type === "text") {
                  // variable.value = { text } or a string
                  varData[label] =
                    variable.value.text || variable.value || getMissingValue();
                } else if (variable.type === "population_size") {
                  // variable.value = { population }
                  varData[`${label}_Population`] =
                    variable.value.population || getMissingValue();
                }
              }
            });

            return { studyId, variables: varData };
          });

          // Flatten out all subgroups => create final column names
          const allVariableColumns = [];
          allVariableLabels.forEach((label) => {
            const subs = variableSubgroups[label];
            if (subs.length > 0) {
              subs.forEach((sub) => {
                allVariableColumns.push(sub ? `${label}_${sub}` : label);
              });
            } else {
              // if no subgroups, just label
              allVariableColumns.push(label);
            }
          });

          return {
            dataRows,
            allVariableLabels,
            allVariableColumns,
            variableSubgroups,
          };
        }
        function computeWeightedAverages(
          dataRows,
          variableSubgroups,
          weightVariable
        ) {
          const weightedAverages = {};

          // Early return if no weight variable
          if (!weightVariable) {
            return weightedAverages;
          }

          // Check if user specifically picked "Population Size" as the weight
          const isPopulationSizeWeight =
            weightVariable.toLowerCase() === "population size";

          // If not population-size weighting, fall back to your old subgroups approach
          const weightSubgroups =
            !isPopulationSizeWeight && variableSubgroups[weightVariable]
              ? variableSubgroups[weightVariable]
              : [""];

          // Build a fallback list of weight columns for the "old" approach
          const weightColumnNames = weightSubgroups.map((subgroup) => {
            return subgroup ? `${weightVariable}_${subgroup}` : weightVariable;
          });

          const columnSums = {};
          const columnWeightSums = {};

          dataRows.forEach((row) => {
            // If NOT population-size weighting, gather 'weights'
            let weights = {};
            if (!isPopulationSizeWeight) {
              weightColumnNames.forEach((weightColumn) => {
                const weightValue = parseFloat(row.variables[weightColumn]);
                weights[weightColumn] = isNaN(weightValue) ? null : weightValue;
              });
            }

            // Accumulate sums for each numeric column
            Object.keys(row.variables).forEach((columnName) => {
              const value = parseFloat(row.variables[columnName]);
              if (isNaN(value)) return; // Skip non-numerical

              let weight = null;

              if (isPopulationSizeWeight) {
                // "Population Size" weighting logic:
                // We try to look up the matching "..._Total" column
                const parts = columnName.split("_");
                const labelPart = parts[0];
                let subgroupPart = parts.slice(1).join("_");
                subgroupPart = subgroupPart.replace(
                  /(mean|sd|events|text)/i,
                  "Total"
                );
                const totalColumnName = subgroupPart.trim()
                  ? `${labelPart}_${subgroupPart}`
                  : `${labelPart}_Total`;
                const weightRaw = parseFloat(row.variables[totalColumnName]);
                if (!isNaN(weightRaw)) {
                  weight = weightRaw;
                }
              } else {
                // Subgroup-based weighting logic
                let subgroup = "";
                const labelParts = columnName.split("_");
                if (labelParts.length > 1) {
                  subgroup = labelParts.slice(1).join("_");
                }

                let weightColumn = "";
                if (weightSubgroups.includes(subgroup)) {
                  weightColumn = subgroup
                    ? `${weightVariable}_${subgroup}`
                    : weightVariable;
                } else if (weightSubgroups.includes("Total")) {
                  weightColumn = `${weightVariable}_Total`;
                } else {
                  weightColumn = weightColumnNames[0];
                }
                weight = weights[weightColumn];
              }

              if (weight !== null && !isNaN(weight)) {
                columnSums[columnName] =
                  (columnSums[columnName] || 0) + value * weight;
                columnWeightSums[columnName] =
                  (columnWeightSums[columnName] || 0) + weight;
              }
            });
          });

          // Now compute the actual weighted averages, skipping unwanted columns
          Object.keys(columnSums).forEach((columnName) => {
            // 1) Skip if it’s one of the weight columns themselves
            if (weightColumnNames.includes(columnName)) {
              weightedAverages[columnName] = getMissingValue();
              return;
            }

            // 2) Skip if the column name contains "Total"
            if (columnName.toLowerCase().includes("total")) {
              weightedAverages[columnName] = getMissingValue();
              return;
            }

            // 3) Skip if the column starts with the label of the weight variable
            //    (e.g. weightVariable="Population Size" => skip "Population Size_Intervention" columns)
            if (
              columnName.toLowerCase().startsWith(weightVariable.toLowerCase())
            ) {
              weightedAverages[columnName] = getMissingValue();
              return;
            }

            // Compute average if there's a non-zero weight sum
            const sum = columnSums[columnName];
            const wSum = columnWeightSums[columnName];
            if (wSum > 0) {
              weightedAverages[columnName] = sum / wSum;
            }
          });

          return weightedAverages;
        }

        let combinedDataRows = [];
        let baselineDataset = null;
        let outcomesDataset = null;
        let weightedAverages = {};

        if (
          previewOption === "baseline" ||
          previewOption === "both" ||
          previewOption === "recurrent"
        ) {
          baselineDataset = buildDataRows(
            baselineVariables,
            previewOption === "recurrent",
            sortOrder,
            true // isBaseline=true
          );
        }
        if (
          previewOption === "outcomes" ||
          previewOption === "both" ||
          previewOption === "recurrent"
        ) {
          outcomesDataset = buildDataRows(
            outcomesVariables,
            previewOption === "recurrent",
            sortOrder,
            false // isBaseline=false
          );
        }
        if (previewOption === "both" || previewOption === "recurrent") {
          combinedDataRows = studyIds.map((studyId) => {
            const baselineRow = baselineDataset.dataRows.find(
              (row) => row.studyId === studyId
            ) || { variables: {} };
            const outcomesRow = outcomesDataset.dataRows.find(
              (row) => row.studyId === studyId
            ) || { variables: {} };
            return {
              studyId,
              variables: {
                ...baselineRow.variables,
                ...outcomesRow.variables,
              },
            };
          });

          if (weightVariable) {
            weightedAverages = computeWeightedAverages(
              combinedDataRows,
              {
                ...baselineDataset.variableSubgroups,
                ...outcomesDataset.variableSubgroups,
              },
              weightVariable
            );
          }
        } else {
          const dataset =
            previewOption === "baseline" ? baselineDataset : outcomesDataset;
          if (dataset && weightVariable) {
            weightedAverages = computeWeightedAverages(
              dataset.dataRows,
              dataset.variableSubgroups,
              weightVariable
            );
          }
        }

        const handleSave = () => {
          // Determine naming based on groupType and groupNames
          let groupPart;
          if (groupType === "intervention") {
            groupPart = groupNames.interventionName;
          } else if (groupType === "intervention_comparison") {
            groupPart = `${groupNames.interventionName}_x_${groupNames.comparisonName}`;
          } else {
            groupPart = "Data"; // Fallback if unexpected groupType
          }

          if (previewOption === "both" || previewOption === "recurrent") {
            const wb = XLSX.utils.book_new();

            // Create data array for the sheet
            const ws_data = [];

            // Extract label arrays and subgroups from baseline/outcomes
            const baselineLabels = baselineDataset.allVariableLabels;
            const outcomesLabels = outcomesDataset.allVariableLabels;
            const baselineSubgroups = baselineDataset.variableSubgroups;
            const outcomesSubgroups = outcomesDataset.variableSubgroups;

            // 1) FIRST HEADER ROW — for “Study ID” and then “BASELINE” and “OUTCOMES”
            const header1 = ["Study ID"];
            const header1Merges = [];
            let colIndex = 1;

            // Count total columns for Baseline
            let totalBaselineColumns = 0;
            baselineLabels.forEach((label) => {
              const subgroups = baselineSubgroups[label];
              const colspan = subgroups.length || 1;
              totalBaselineColumns += colspan;
            });

            // Count total columns for Outcomes
            let totalOutcomesColumns = 0;
            outcomesLabels.forEach((label) => {
              const subgroups = outcomesSubgroups[label];
              const colspan = subgroups.length || 1;
              totalOutcomesColumns += colspan;
            });

            // If baseline has columns, add “BASELINE” spanning those columns
            if (baselineLabels.length > 0) {
              header1.push("BASELINE");
              const startCol = colIndex;
              const endCol = startCol + totalBaselineColumns - 1;
              header1Merges.push({
                s: { r: 0, c: startCol },
                e: { r: 0, c: endCol },
              });
              // Fill with null placeholders
              for (let i = 1; i < totalBaselineColumns; i++) {
                header1.push(null);
              }
              colIndex = endCol + 1;
            }

            // If outcomes has columns, add “OUTCOMES” spanning those columns
            if (outcomesLabels.length > 0) {
              header1.push("OUTCOMES");
              const startCol = colIndex;
              const endCol = startCol + totalOutcomesColumns - 1;
              header1Merges.push({
                s: { r: 0, c: startCol },
                e: { r: 0, c: endCol },
              });
              // Fill with null placeholders
              for (let i = 1; i < totalOutcomesColumns; i++) {
                header1.push(null);
              }
              colIndex = endCol + 1;
            }
            ws_data.push(header1);

            // 2) SECOND HEADER ROW — variable labels
            const header2 = [""];
            const header2Merges = [];
            colIndex = 1;

            // Baseline variable labels
            baselineLabels.forEach((label) => {
              const subgroups = baselineSubgroups[label];
              const colspan = subgroups.length || 1;
              header2.push(label);
              if (colspan > 1) {
                header2Merges.push({
                  s: { r: 1, c: colIndex },
                  e: { r: 1, c: colIndex + colspan - 1 },
                });
                // Fill with null placeholders
                for (let i = 1; i < colspan; i++) {
                  header2.push(null);
                }
              }
              colIndex += colspan;
            });

            // Outcomes variable labels
            outcomesLabels.forEach((label) => {
              const subgroups = outcomesSubgroups[label];
              const colspan = subgroups.length || 1;
              header2.push(label);
              if (colspan > 1) {
                header2Merges.push({
                  s: { r: 1, c: colIndex },
                  e: { r: 1, c: colIndex + colspan - 1 },
                });
                // Fill with null placeholders
                for (let i = 1; i < colspan; i++) {
                  header2.push(null);
                }
              }
              colIndex += colspan;
            });
            ws_data.push(header2);

            // 3) THIRD HEADER ROW — subgroups
            const header3 = [""];
            const variableColumns = [];

            // Build subgroups for Baseline
            baselineLabels.forEach((label) => {
              const subgroups = baselineSubgroups[label];
              if (subgroups.length > 0) {
                subgroups.forEach((sub) => {
                  header3.push(sub);
                  variableColumns.push(sub ? `${label}_${sub}` : label);
                });
              } else {
                header3.push("");
                variableColumns.push(label);
              }
            });

            // Build subgroups for Outcomes
            outcomesLabels.forEach((label) => {
              const subgroups = outcomesSubgroups[label];
              if (subgroups.length > 0) {
                subgroups.forEach((sub) => {
                  header3.push(sub);
                  variableColumns.push(sub ? `${label}_${sub}` : label);
                });
              } else {
                header3.push("");
                variableColumns.push(label);
              }
            });
            ws_data.push(header3);

            // 4) DATA ROWS
            combinedDataRows.forEach((row) => {
              const rowValues = [row.studyId];
              variableColumns.forEach((columnName) => {
                const cellValue =
                  row.variables[columnName] || getMissingValue();
                rowValues.push(cellValue);
              });
              ws_data.push(rowValues);
            });

            // 5) WEIGHTED AVERAGES ROW
            if (Object.keys(weightedAverages).length > 0) {
              const avgRow = ["Weighted Averages"];
              variableColumns.forEach((columnName) => {
                const avgValue = weightedAverages[columnName];
                avgRow.push(
                  avgValue !== undefined ? avgValue : getMissingValue()
                );
              });
              ws_data.push(avgRow);
            }

            // Convert the array-of-arrays (AOA) to a Sheet
            const ws = XLSX.utils.aoa_to_sheet(ws_data);

            // Merge 'Study ID' across the three header rows
            ws["!merges"] = [
              ...header1Merges,
              ...header2Merges,
              { s: { r: 0, c: 0 }, e: { r: 2, c: 0 } },
            ];

            // Append to Workbook
            XLSX.utils.book_append_sheet(wb, ws, "Combined_Data");

            // Create filename with date/time + groupPart
            const timestamp = new Date();
            const formattedTimestamp = timestamp
              .toISOString()
              .slice(0, 19)
              .replace("T", "_")
              .replace(/:/g, "-");

            const filename = `Combined_Data_${groupPart}_${formattedTimestamp}.xlsx`;
            XLSX.writeFile(wb, filename);
          } else {
            // Handling just baseline OR outcomes
            const dataset =
              previewOption === "baseline" ? baselineDataset : outcomesDataset;
            const dataLabel =
              previewOption === "baseline" ? "Baseline_Data" : "Outcomes_Data";

            const wb = XLSX.utils.book_new();
            const ws_data = [];

            // 1) FIRST HEADER ROW
            const header1 = ["Study ID"];
            const header1Merges = [];
            let colIndex = 1;

            // Count total columns
            let totalColumns = 0;
            dataset.allVariableLabels.forEach((label) => {
              const subgroups = dataset.variableSubgroups[label];
              const colspan = subgroups.length || 1;
              totalColumns += colspan;
            });

            if (dataset.allVariableLabels.length > 0) {
              // E.g. “BASELINE” or “OUTCOMES” spanning the columns
              header1.push(previewOption.toUpperCase());
              const startCol = colIndex;
              const endCol = startCol + totalColumns - 1;
              header1Merges.push({
                s: { r: 0, c: startCol },
                e: { r: 0, c: endCol },
              });
              // Fill with null placeholders
              for (let i = 1; i < totalColumns; i++) {
                header1.push(null);
              }
            } else {
              // If no columns, just merge “Study ID”
              header1Merges.push({ s: { r: 0, c: 0 }, e: { r: 2, c: 0 } });
            }
            ws_data.push(header1);

            // 2) SECOND HEADER ROW — variable labels
            const header2 = [""];
            const header2Merges = [];
            colIndex = 1;

            dataset.allVariableLabels.forEach((label) => {
              const subgroups = dataset.variableSubgroups[label];
              const colspan = subgroups.length || 1;
              header2.push(label);
              if (colspan > 1) {
                header2Merges.push({
                  s: { r: 1, c: colIndex },
                  e: { r: 1, c: colIndex + colspan - 1 },
                });
                for (let i = 1; i < colspan; i++) {
                  header2.push(null);
                }
              }
              colIndex += colspan;
            });
            ws_data.push(header2);

            // 3) THIRD HEADER ROW — subgroups
            const header3 = [""];
            const variableColumns = [];

            dataset.allVariableLabels.forEach((label) => {
              const subgroups = dataset.variableSubgroups[label];
              if (subgroups.length > 0) {
                subgroups.forEach((sub) => {
                  header3.push(sub);
                  variableColumns.push(sub ? `${label}_${sub}` : label);
                });
              } else {
                header3.push("");
                variableColumns.push(label);
              }
            });
            ws_data.push(header3);

            // 4) DATA ROWS
            dataset.dataRows.forEach((row) => {
              const rowValues = [row.studyId];
              variableColumns.forEach((columnName) => {
                const cellValue =
                  row.variables[columnName] || getMissingValue();
                rowValues.push(cellValue);
              });
              ws_data.push(rowValues);
            });

            // 5) WEIGHTED AVERAGES ROW
            if (Object.keys(weightedAverages).length > 0) {
              const avgRow = ["Weighted Averages"];
              variableColumns.forEach((columnName) => {
                const avgValue = weightedAverages[columnName];
                avgRow.push(
                  avgValue !== undefined ? avgValue : getMissingValue()
                );
              });
              ws_data.push(avgRow);
            }

            // Convert to a sheet and merge “Study ID”
            const ws = XLSX.utils.aoa_to_sheet(ws_data);
            ws["!merges"] = [
              ...header1Merges,
              ...header2Merges,
              { s: { r: 0, c: 0 }, e: { r: 2, c: 0 } },
            ];

            XLSX.utils.book_append_sheet(wb, ws, dataLabel);

            // Construct filename (e.g. “Baseline_Data_Intervention_YYYY-MM-DD_HH-MM-SS.xlsx”)
            const timestamp = new Date();
            const formattedTimestamp = timestamp
              .toISOString()
              .slice(0, 19)
              .replace("T", "_")
              .replace(/:/g, "-");

            const filename = `${dataLabel}_${groupPart}_${formattedTimestamp}.xlsx`;
            XLSX.writeFile(wb, filename);
          }

          // Finally, try opening any "Spreadsheet Files" links in localStorage
          try {
            const storedData =
              JSON.parse(localStorage.getItem("driveLinks")) || {};
            const spreadsheetLinks = storedData["Spreadsheet Files"] || [];
            spreadsheetLinks.forEach((link) => {
              window.open(link, "_blank");
            });
          } catch (err) {
            console.error("Error opening Spreadsheet Files links:", err);
          }
        };

        function getVariableCountsFromDatasets(datasets) {
          const variableCounts = {};

          studyIds.forEach((studyId) => {
            let studyVars = [];

            datasets.forEach((dataset) => {
              studyVars = studyVars.concat(dataset[studyId] || []);
            });

            const labelsInStudy = new Set();

            studyVars.forEach((variable) => {
              labelsInStudy.add(variable.label);
            });

            labelsInStudy.forEach((label) => {
              variableCounts[label] = (variableCounts[label] || 0) + 1;
            });
          });

          return variableCounts;
        }

        function buildRowUsingVariableTotals(
          studyId,
          targetVar,
          format,
          groupNames,
          groupType
        ) {
          // 'row' will store the resulting CSV fields for this study
          let row = {};

          // Always store the Study ID
          if (format === "RevMan") {
            row["Study ID"] = studyId;
          } else {
            // For RStudio and Stata, often the column is 'study'
            row.study = studyId;
          }

          // Distinguish by type + arm
          if (
            groupType === "intervention_comparison" &&
            targetVar.armType === "double"
          ) {
            // DOUBLE-ARM
            if (targetVar.type === "dichotomous") {
              const iEvents = targetVar.value.intervention || "";
              const iTotal = targetVar.value.interventionTotal || "";
              const cEvents = targetVar.value.comparison || "";
              const cTotal = targetVar.value.comparisonTotal || "";

              if (format === "RevMan") {
                row["Intervention Events"] = iEvents;
                row["Intervention Total"] = iTotal;
                row["Comparison Events"] = cEvents;
                row["Comparison Total"] = cTotal;
              } else if (format === "RStudio") {
                row.events_inter = iEvents;
                row.n_inter = iTotal;
                row.events_control = cEvents;
                row.n_control = cTotal;
              } else if (format === "Stata") {
                // For Stata, typical approach is yes/no
                const interYes = parseFloat(iEvents) || 0;
                const interTot = parseFloat(iTotal) || 0;
                const interNo = interTot - interYes;

                const compYes = parseFloat(cEvents) || 0;
                const compTot = parseFloat(cTotal) || 0;
                const compNo = compTot - compYes;

                row.yes_inter = interYes;
                row.no_inter = interNo;
                row.yes_control = compYes;
                row.no_control = compNo;
              }
            } else if (targetVar.type === "continuous") {
              const iMean = (targetVar.value.intervention || {}).mean || "";
              const iSd = (targetVar.value.intervention || {}).sd || "";
              const iTotal = targetVar.value.interventionTotal || "";

              const cMean = (targetVar.value.comparison || {}).mean || "";
              const cSd = (targetVar.value.comparison || {}).sd || "";
              const cTotal = targetVar.value.comparisonTotal || "";

              if (format === "RevMan") {
                row["Intervention Mean"] = iMean;
                row["Intervention SD"] = iSd;
                row["Intervention Total"] = iTotal;
                row["Comparison Mean"] = cMean;
                row["Comparison SD"] = cSd;
                row["Comparison Total"] = cTotal;
              } else if (format === "RStudio") {
                row.mean_inter = iMean;
                row.sd_inter = iSd;
                row.n_inter = iTotal;
                row.mean_control = cMean;
                row.sd_control = cSd;
                row.n_control = cTotal;
              } else if (format === "Stata") {
                row.n_inter = iTotal;
                row.mean_inter = iMean;
                row.sd_inter = iSd;
                row.n_control = cTotal;
                row.mean_control = cMean;
                row.sd_control = cSd;
              }
            } else if (targetVar.type === "text") {
              const iText = targetVar.value.intervention || "";
              const iTotal = targetVar.value.interventionTotal || "";
              const cText = targetVar.value.comparison || "";
              const cTotal = targetVar.value.comparisonTotal || "";

              if (format === "RevMan") {
                row["Intervention Text"] = iText;
                row["Intervention Total"] = iTotal;
                row["Comparison Text"] = cText;
                row["Comparison Total"] = cTotal;
              } else if (format === "RStudio") {
                row.intervention_text = iText;
                row.intervention_total = iTotal;
                row.comparison_text = cText;
                row.comparison_total = cTotal;
              } else if (format === "Stata") {
                row.intervention_text = iText;
                row.intervention_total = iTotal;
                row.comparison_text = cText;
                row.comparison_total = cTotal;
              }
            } else if (targetVar.type === "population_size") {
              const iPop = targetVar.value.interventionPop || "";
              const cPop = targetVar.value.comparisonPop || "";

              if (format === "RevMan") {
                row["Intervention Population Size"] = iPop;
                row["Comparison Population Size"] = cPop;
              } else if (format === "RStudio") {
                row.population_inter = iPop;
                row.population_control = cPop;
              } else if (format === "Stata") {
                row.population_inter = iPop;
                row.population_control = cPop;
              }
            }
          } else if (
            groupType === "intervention_comparison" &&
            targetVar.armType === "single"
          ) {
            // SINGLE-ARM in an intervention+comparison environment
            if (targetVar.type === "dichotomous") {
              const e = targetVar.value.events || "";
              const t = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Events"] = e;
                row["Intervention Total"] = t;
              } else if (format === "RStudio") {
                row.events_inter = e;
                row.n_inter = t;
              } else if (format === "Stata") {
                const yes = parseFloat(e) || 0;
                const tot = parseFloat(t) || 0;
                const no = tot - yes;
                row.yes_inter = yes;
                row.no_inter = no;
                row.total_inter = tot;
              }
            } else if (targetVar.type === "continuous") {
              const m = targetVar.value.mean || "";
              const s = targetVar.value.sd || "";
              const t = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Mean"] = m;
                row["Intervention SD"] = s;
                row["Intervention Total"] = t;
              } else if (format === "RStudio") {
                row.mean_inter = m;
                row.sd_inter = s;
                row.n_inter = t;
              } else if (format === "Stata") {
                row.n_inter = t;
                row.mean_inter = m;
                row.sd_inter = s;
              }
            } else if (targetVar.type === "text") {
              const txt = targetVar.value.text || "";
              const t = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Text"] = txt;
                row["Intervention Total"] = t;
              } else if (format === "RStudio") {
                row.text = txt;
                row.total = t;
              } else if (format === "Stata") {
                row.text = txt;
                row.total = t;
              }
            } else if (targetVar.type === "population_size") {
              const pop = targetVar.value.population || "";
              if (format === "RevMan") {
                row["Population Size"] = pop;
              } else if (format === "RStudio") {
                row.population = pop;
              } else if (format === "Stata") {
                row.population = pop;
              }
            }
          } else {
            // SINGLE-ARM, SINGLE GROUP (groupType === 'intervention')
            if (targetVar.type === "dichotomous") {
              const e = targetVar.value.events || "";
              const t = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Events"] = e;
                row["Intervention Total"] = t;
              } else if (format === "RStudio") {
                row.events_inter = e;
                row.n_inter = t;
              } else if (format === "Stata") {
                const yes = parseFloat(e) || 0;
                const tot = parseFloat(t) || 0;
                const no = tot - yes;
                row.yes_inter = yes;
                row.no_inter = no;
                row.total_inter = tot;
              }
            } else if (targetVar.type === "continuous") {
              const m = targetVar.value.mean || "";
              const s = targetVar.value.sd || "";
              const t = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Mean"] = m;
                row["Intervention SD"] = s;
                row["Intervention Total"] = t;
              } else if (format === "RStudio") {
                row.mean_inter = m;
                row.sd_inter = s;
                row.n_inter = t;
              } else if (format === "Stata") {
                row.n_inter = t;
                row.mean_inter = m;
                row.sd_inter = s;
              }
            } else if (targetVar.type === "text") {
              const txt = targetVar.value.text || "";
              const t = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Text"] = txt;
                row["Intervention Total"] = t; // optional, if you want to store it
              } else if (format === "RStudio") {
                row.text = txt;
                row.total = t;
              } else if (format === "Stata") {
                row.text = txt;
                row.total = t;
              }
            } else if (targetVar.type === "population_size") {
              const pop = targetVar.value.population || "";
              if (format === "RevMan") {
                row["Population Size"] = pop;
              } else if (format === "RStudio") {
                row.population = pop;
              } else if (format === "Stata") {
                row.population = pop;
              }
            }
          }

          return row;
        }

const handleDownloadFolder = async () => {
  if (!selectedPopulationVariable) {
    alert("Please select a Population Size Variable.");
    return;
  }

  let groupPart;
  if (groupType === "intervention") {
    groupPart = groupNames.interventionName;
  } else if (groupType === "intervention_comparison") {
    groupPart = `${groupNames.interventionName}_x_${groupNames.comparisonName}`;
  } else {
    groupPart = "Data";
  }

  const zip = new JSZip();
  let createdAnyCSV = false;

  // Helper function to process a dataset (baseline or outcomes)
  const processDataset = (datasetName, variablesToUse) => {
    let labels = getVariableLabelsFromDataset(variablesToUse);

    const variableCounts = {};
    labels.forEach(label => {
      let count = 0;
      studyIds.forEach(studyId => {
        if (variablesToUse[studyId]?.some(v => v.label === label)) count++;
      });
      variableCounts[label] = count;
    });

    if (previewOption === "recurrent") {
      labels = labels.filter(label => variableCounts[label] >= 2);
    }

    labels.forEach(label => {
      const dataRows = [];
      studyIds.forEach(studyId => {
        const localVars = variablesToUse[studyId] || [];
        const targetVar = localVars.find(v => v.label === label);
        if (!targetVar) return;

        if (onlyCompleteStudies) {
          if (selectedPopulationVariable === "Total Patients") {
            if (!hasCompleteDoubleTotals(targetVar)) return;
          } else {
            let popVar = localVars.find(v => v.label === selectedPopulationVariable);
            if (!popVar) {
              // Look in the other dataset if not found
              const otherVariables = (datasetName === "BASELINE DATA" ? outcomesVariables : baselineVariables);
              popVar = (otherVariables[studyId] || []).find(v => v.label === selectedPopulationVariable);
            }
            if (!popVar || !hasCompleteData(targetVar, popVar)) return;
          }
        }

        let rowData;
        if (selectedPopulationVariable === "Total Patients") {
          rowData = buildRowUsingVariableTotals(studyId, targetVar, selectedFormat, groupNames, groupType);
        } else {
          let popVar = localVars.find(v => v.label === selectedPopulationVariable);
          if (!popVar) {
            const otherVariables = (datasetName === "BASELINE DATA" ? outcomesVariables : baselineVariables);
            popVar = (otherVariables[studyId] || []).find(v => v.label === selectedPopulationVariable);
          }
          if (!popVar) return;
          rowData = buildDataRow(studyId, targetVar, popVar, selectedFormat, groupNames, groupType);
        }

        if (rowData) dataRows.push(rowData);
      });

      if (dataRows.length === 0) return;

      const effectiveCount = dataRows.length;
      const subfolderName = effectiveCount < 3 ? "LESS THAN 3 STUDIES" : "3 OR MORE STUDIES";

      const csvContent = generateCSVContent(dataRows, selectedFormat);
      const safeLabel = label.replace(/\//g, '_');
      zip.file(`${datasetName}/${subfolderName}/${safeLabel}.csv`, csvContent);
      createdAnyCSV = true;
    });
  };

  // Process baseline if applicable
  if (previewOption === "baseline" || previewOption === "both" || previewOption === "recurrent") {
    processDataset("BASELINE DATA", baselineVariables);
  }

  // Process outcomes if applicable
  if (previewOption === "outcomes" || previewOption === "both" || previewOption === "recurrent") {
    processDataset("OUTCOMES DATA", outcomesVariables);
  }

  // If we didn't produce any CSV
  if (!createdAnyCSV) {
    alert("No data available to download.");
    return;
  }

  // Generate and download the ZIP
  zip.generateAsync({ type: "blob" }).then((blob) => {
    const now = new Date();
    const fname = `Variables_${groupPart}_${now.toISOString().slice(0, 19).replace("T", "_").replace(/:/g, "-")}.zip`;
    saveAs(blob, fname);

    // Open "Variable Files" Google Drive links
    try {
      const storedData = JSON.parse(localStorage.getItem("driveLinks")) || {};
      const variableLinks = storedData["Variable Files"] || [];
      variableLinks.forEach((link) => {
        window.open(link, "_blank");
      });
    } catch (err) {
      console.error("Error opening Variable Files links:", err);
    }
  });

  // close the modal
  closeDownloadFolderModal();
};

        function buildDataRowUsingTotalsOnly(
          studyId,
          targetVar,
          format,
          groupNames,
          groupType
        ) {
          // The row object we'll eventually return
          const row = {};

          // Always store the Study ID in some form
          // For "RevMan", we'll keep "Study ID" as the header
          // For "RStudio" and "Stata", often we store it under "study"
          row["Study ID"] = studyId;

          // Distinguish by variable type first
          if (targetVar.type === "dichotomous") {
            if (
              groupType === "intervention_comparison" &&
              targetVar.armType === "double"
            ) {
              // DOUBLE-ARM DICHOTOMOUS
              const iEvents = targetVar.value.intervention || "";
              const iTotal = targetVar.value.interventionTotal || "";
              const cEvents = targetVar.value.comparison || "";
              const cTotal = targetVar.value.comparisonTotal || "";

              if (format === "RevMan") {
                row["Intervention Events"] = iEvents;
                row["Intervention Total"] = iTotal;
                row["Comparison Events"] = cEvents;
                row["Comparison Total"] = cTotal;
              } else if (format === "RStudio") {
                // Typically "study", "events_inter", "n_inter", "events_control", "n_control"
                // We'll also set row.study = studyId so it’s consistent with your usage
                row.study = studyId;
                row.events_control = cEvents;
                row.n_control = cTotal;
                row.events_inter = iEvents;
                row.n_inter = iTotal;
              } else if (format === "Stata") {
                // In Stata, you might store “yes_inter/no_inter” and “yes_control/no_control”
                row.study = studyId;

                const yes_inter = parseFloat(iEvents) || 0;
                const total_inter = parseFloat(iTotal) || 0;
                const no_inter = total_inter - yes_inter;

                const yes_control = parseFloat(cEvents) || 0;
                const total_control = parseFloat(cTotal) || 0;
                const no_control = total_control - yes_control;

                row["yes_inter"] = yes_inter;
                row["no_inter"] = no_inter;
                row["yes_control"] = yes_control;
                row["no_control"] = no_control;
              }
            } else {
              // SINGLE-ARM DICHOTOMOUS
              const events = targetVar.value.events || "";
              const total = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Events"] = events;
                row["Intervention Total"] = total;
              } else if (format === "RStudio") {
                row.study = studyId;
                row.events_inter = events;
                row.n_inter = total;
              } else if (format === "Stata") {
                row.study = studyId;
                const yes = parseFloat(events) || 0;
                const tot = parseFloat(total) || 0;
                const no = tot - yes;

                row["yes_inter"] = yes;
                row["no_inter"] = no;
                row["total_inter"] = tot;
              }
            }
          } else if (targetVar.type === "continuous") {
            if (
              groupType === "intervention_comparison" &&
              targetVar.armType === "double"
            ) {
              // DOUBLE-ARM CONTINUOUS
              const iMean = (targetVar.value.intervention || {}).mean || "";
              const iSd = (targetVar.value.intervention || {}).sd || "";
              const iTotal = targetVar.value.interventionTotal || "";

              const cMean = (targetVar.value.comparison || {}).mean || "";
              const cSd = (targetVar.value.comparison || {}).sd || "";
              const cTotal = targetVar.value.comparisonTotal || "";

              if (format === "RevMan") {
                // Example columns: "Intervention Mean", "Intervention SD", "Intervention Total" ...
                row["Intervention Mean"] = iMean;
                row["Intervention SD"] = iSd;
                row["Intervention Total"] = iTotal;
                row["Comparison Mean"] = cMean;
                row["Comparison SD"] = cSd;
                row["Comparison Total"] = cTotal;
              } else if (format === "RStudio") {
                // Example columns: "study", "mean_inter", "sd_inter", "n_inter", "mean_control", "sd_control", "n_control"
                row.study = studyId;
                row.mean_control = cMean;
                row.sd_control = cSd;
                row.n_control = cTotal;
                row.mean_inter = iMean;
                row.sd_inter = iSd;
                row.n_inter = iTotal;
              } else if (format === "Stata") {
                // Example columns for Stata: "n_inter", "mean_inter", "sd_inter", "n_control", "mean_control", "sd_control", etc.
                row.study = studyId;
                row.n_inter = iTotal;
                row.mean_inter = iMean;
                row.sd_inter = iSd;
                row.n_control = cTotal;
                row.mean_control = cMean;
                row.sd_control = cSd;
              }
            } else {
              // SINGLE-ARM CONTINUOUS
              const mean = targetVar.value.mean || "";
              const sd = targetVar.value.sd || "";
              const total = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Mean"] = mean;
                row["Intervention SD"] = sd;
                row["Intervention Total"] = total;
              } else if (format === "RStudio") {
                row.study = studyId;
                row.mean_inter = mean;
                row.sd_inter = sd;
                row.n_inter = total;
              } else if (format === "Stata") {
                row.study = studyId;
                row.n_inter = total;
                row.mean_inter = mean;
                row.sd_inter = sd;
              }
            }
          } else if (targetVar.type === "text") {
            if (
              groupType === "intervention_comparison" &&
              targetVar.armType === "double"
            ) {
              // DOUBLE-ARM TEXT
              const iText = targetVar.value.intervention || "";
              const iTotal = targetVar.value.interventionTotal || "";
              const cText = targetVar.value.comparison || "";
              const cTotal = targetVar.value.comparisonTotal || "";

              if (format === "RevMan") {
                row["Intervention Text"] = iText;
                row["Intervention Total"] = iTotal; // If you want to store it, depends on usage
                row["Comparison Text"] = cText;
                row["Comparison Total"] = cTotal; // Similarly optional
              } else if (format === "RStudio") {
                // Typically you'd not store text variables in the same place you store numeric columns,
                // but for completeness:
                row.study = studyId;
                row.intervention_text = iText;
                row.intervention_total = iTotal;
                row.comparison_text = cText;
                row.comparison_total = cTotal;
              } else if (format === "Stata") {
                // Same note about text fields in Stata
                row.study = studyId;
                row["intervention_text"] = iText;
                row["intervention_total"] = iTotal;
                row["comparison_text"] = cText;
                row["comparison_total"] = cTotal;
              }
            } else {
              // SINGLE-ARM TEXT
              const textValue = targetVar.value.text || "";
              const total = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Text"] = textValue;
                row["Intervention Total"] = total; // If needed
              } else if (format === "RStudio") {
                row.study = studyId;
                row.text = textValue;
                row.total = total; // optional
              } else if (format === "Stata") {
                row.study = studyId;
                row.text = textValue;
                row.total = total; // optional
              }
            }
          } else if (targetVar.type === "population_size") {
            if (
              groupType === "intervention_comparison" &&
              targetVar.armType === "double"
            ) {
              // DOUBLE-ARM population_size
              const iPop = targetVar.value.interventionPop || "";
              const cPop = targetVar.value.comparisonPop || "";

              if (format === "RevMan") {
                row["Intervention Population Size"] = iPop;
                row["Comparison Population Size"] = cPop;
              } else if (format === "RStudio") {
                row.study = studyId;
                row.population_inter = iPop;
                row.population_control = cPop;
              } else if (format === "Stata") {
                row.study = studyId;
                row["population_inter"] = iPop;
                row["population_control"] = cPop;
              }
            } else {
              // SINGLE-ARM population_size
              const pop = targetVar.value.population || "";

              if (format === "RevMan") {
                row["Population Size"] = pop;
              } else if (format === "RStudio") {
                row.study = studyId;
                row.population = pop;
              } else if (format === "Stata") {
                row.study = studyId;
                row.population = pop;
              }
            }
          }

          return row;
        }

        function hasCompleteDoubleTotals(targetVar) {
          // 1) Check if double-arm or single-arm
          if (targetVar.armType === "double") {
            // DOUBLE-ARM variable
            if (targetVar.type === "dichotomous") {
              // Expect .value.intervention, .value.interventionTotal, .value.comparison, .value.comparisonTotal
              return (
                !!targetVar.value.intervention &&
                !!targetVar.value.interventionTotal &&
                !!targetVar.value.comparison &&
                !!targetVar.value.comparisonTotal
              );
            } else if (targetVar.type === "continuous") {
              // Expect .value.intervention.mean, .value.intervention.sd, .value.interventionTotal, etc.
              return (
                !!(
                  targetVar.value.intervention &&
                  targetVar.value.intervention.mean
                ) &&
                !!(
                  targetVar.value.intervention &&
                  targetVar.value.intervention.sd
                ) &&
                !!targetVar.value.interventionTotal &&
                !!(
                  targetVar.value.comparison && targetVar.value.comparison.mean
                ) &&
                !!(
                  targetVar.value.comparison && targetVar.value.comparison.sd
                ) &&
                !!targetVar.value.comparisonTotal
              );
            } else if (targetVar.type === "text") {
              // Possibly need .value.intervention, .value.interventionTotal, .value.comparison, .value.comparisonTotal
              return (
                !!targetVar.value.intervention &&
                !!targetVar.value.interventionTotal &&
                !!targetVar.value.comparison &&
                !!targetVar.value.comparisonTotal
              );
            } else if (targetVar.type === "population_size") {
              // Expect .value.interventionPop and .value.comparisonPop
              return (
                !!targetVar.value.interventionPop &&
                !!targetVar.value.comparisonPop
              );
            }

            // If we have an unexpected type, decide whether to treat as complete
            return false;
          } else {
            // SINGLE-ARM variable
            if (targetVar.type === "dichotomous") {
              // Expect .value.events and .value.total
              return !!targetVar.value.events && !!targetVar.value.total;
            } else if (targetVar.type === "continuous") {
              // Expect .value.mean, .value.sd, and .value.total
              return (
                !!targetVar.value.mean &&
                !!targetVar.value.sd &&
                !!targetVar.value.total
              );
            } else if (targetVar.type === "text") {
              // Possibly check .value.text, or consider 'complete' if text is present
              // Some might also want to see if .value.total is present
              return !!targetVar.value.text;
              // && !!targetVar.value.total  (optional check if needed)
            } else if (targetVar.type === "population_size") {
              // Expect .value.population
              return !!targetVar.value.population;
            }

            // If unexpected type
            return false;
          }
        }

        // Function to get variable labels from a dataset
        function getVariableLabelsFromDataset(variables) {
          const variableLabelsSet = new Set();

          Object.values(variables).forEach((studyVars) => {
            studyVars.forEach((variable) => {
              variableLabelsSet.add(variable.label);
            });
          });

          return Array.from(variableLabelsSet);
        }

        // Function to count occurrences of each variable label
        function getVariableCounts(variableLabels) {
          const counts = {};
          variableLabels.forEach((label) => {
            counts[label] = (counts[label] || 0) + 1;
          });
          return counts;
        }

        // Helper functions
        function hasCompleteData(targetVar, populationVar) {
          // Check if all required fields are present
          if (targetVar.type === "dichotomous") {
            if (
              groupType === "intervention_comparison" &&
              targetVar.armType === "double"
            ) {
              return (
                targetVar.value.intervention &&
                targetVar.value.comparison &&
                populationVar.value.intervention &&
                populationVar.value.comparison
              );
            } else {
              return targetVar.value && populationVar.value;
            }
          } else if (targetVar.type === "continuous") {
            if (
              groupType === "intervention_comparison" &&
              targetVar.armType === "double"
            ) {
              return (
                targetVar.value.intervention.mean &&
                targetVar.value.intervention.sd &&
                targetVar.value.comparison.mean &&
                targetVar.value.comparison.sd &&
                populationVar.value.intervention &&
                populationVar.value.comparison
              );
            } else {
              return (
                targetVar.value.mean &&
                targetVar.value.sd &&
                populationVar.value
              );
            }
          }
          return false;
        }

        function buildDataRow(
          studyId,
          targetVar,
          populationVar,
          format,
          groupNames,
          groupType
        ) {
          let row = {};

          if (format === "RevMan") {
            row["Study ID"] = studyId; // Include Study ID

            if (targetVar.type === "dichotomous") {
              if (
                groupType === "intervention_comparison" &&
                targetVar.armType === "double"
              ) {
                row = {
                  ...row,
                  "Intervention Events": targetVar.value.intervention,
                  "Intervention Total": populationVar.value.interventionPop, // Updated
                  "Comparison Events": targetVar.value.comparison,
                  "Comparison Total": populationVar.value.comparisonPop, // Updated
                };
              } else {
                row = {
                  ...row,
                  "Intervention Events": targetVar.value,
                  "Intervention Total":
                    populationVar.value.interventionPop || getMissingValue(), // Updated
                };
              }
            } else if (targetVar.type === "continuous") {
              if (
                groupType === "intervention_comparison" &&
                targetVar.armType === "double"
              ) {
                row = {
                  ...row,
                  "Intervention Mean": targetVar.value.intervention.mean,
                  "Intervention SD": targetVar.value.intervention.sd,
                  "Intervention Total": populationVar.value.interventionPop, // Updated
                  "Comparison Mean": targetVar.value.comparison.mean,
                  "Comparison SD": targetVar.value.comparison.sd,
                  "Comparison Total": populationVar.value.comparisonPop, // Updated
                };
              } else {
                row = {
                  ...row,
                  "Intervention Mean": targetVar.value.mean,
                  "Intervention SD": targetVar.value.sd,
                  "Intervention Total":
                    populationVar.value.interventionPop || getMissingValue(), // Updated
                };
              }
            } else if (targetVar.type === "population_size") {
              if (groupType === "intervention_comparison") {
                if (
                  populationVar.value.interventionPop !== undefined &&
                  populationVar.value.comparisonPop !== undefined
                ) {
                  row = {
                    ...row,
                    "Intervention Population Size":
                      populationVar.value.interventionPop, // Updated
                    "Comparison Population Size":
                      populationVar.value.comparisonPop, // Updated
                  };
                }
              } else {
                row = {
                  ...row,
                  "Population Size":
                    populationVar.value.population || getMissingValue(), // Ensure correct property
                };
              }
            }

            // Handle additional types if necessary (e.g., 'text')
            // Add similar blocks here if 'text' type requires population size
          } else if (format === "RStudio") {
            if (targetVar.type === "dichotomous") {
              if (
                groupType === "intervention_comparison" &&
                targetVar.armType === "double"
              ) {
                row = {
                  study: studyId,
                  events_control: targetVar.value.comparison,
                  n_control: populationVar.value.comparisonPop, // Updated
                  events_inter: targetVar.value.intervention,
                  n_inter: populationVar.value.interventionPop, // Updated
                };
              } else {
                row = {
                  study: studyId,
                  events_inter: targetVar.value,
                  n_inter:
                    populationVar.value.interventionPop || getMissingValue(), // Updated
                };
              }
            } else if (targetVar.type === "continuous") {
              if (
                groupType === "intervention_comparison" &&
                targetVar.armType === "double"
              ) {
                row = {
                  study: studyId,
                  mean_control: targetVar.value.comparison.mean,
                  sd_control: targetVar.value.comparison.sd,
                  n_control: populationVar.value.comparisonPop, // Updated
                  mean_inter: targetVar.value.intervention.mean,
                  sd_inter: targetVar.value.intervention.sd,
                  n_inter: populationVar.value.interventionPop, // Updated
                };
              } else {
                row = {
                  study: studyId,
                  mean_inter: targetVar.value.mean,
                  sd_inter: targetVar.value.sd,
                  n_inter:
                    populationVar.value.interventionPop || getMissingValue(), // Updated
                };
              }
            } else if (targetVar.type === "population_size") {
              if (groupType === "intervention_comparison") {
                row = {
                  study: studyId,
                  population_inter: populationVar.value.interventionPop, // Updated
                  population_control: populationVar.value.comparisonPop, // Updated
                };
              } else {
                row = {
                  study: studyId,
                  population:
                    populationVar.value.population || getMissingValue(), // Ensure correct property
                };
              }
            }

            // Handle additional types if necessary (e.g., 'text')
            // Add similar blocks here if 'text' type requires population size
          } else if (format === "Stata") {
            // Stata format: dichotomous = Yes/No instead of Events/Total
            // Continuous similar to RStudio
            row["study"] = studyId;

            if (targetVar.type === "dichotomous") {
              if (
                groupType === "intervention_comparison" &&
                targetVar.armType === "double"
              ) {
                const interYes = parseFloat(targetVar.value.intervention) || 0;
                const interTotal =
                  parseFloat(populationVar.value.interventionPop) || 0;
                const interNo = interTotal - interYes;

                const compYes = parseFloat(targetVar.value.comparison) || 0;
                const compTotal =
                  parseFloat(populationVar.value.comparisonPop) || 0;
                const compNo = compTotal - compYes;

                row["yes_inter"] = interYes;
                row["no_inter"] = interNo;
                row["yes_control"] = compYes;
                row["no_control"] = compNo;
              } else {
                const yes = parseFloat(targetVar.value) || 0;
                const total =
                  parseFloat(populationVar.value.interventionPop) || 0;
                const no = total - yes;

                // Single-arm data in Stata format
                row["yes_inter"] = yes;
                row["no_inter"] = no;
                row["total_inter"] = total;
              }
            } else if (targetVar.type === "continuous") {
              if (
                groupType === "intervention_comparison" &&
                targetVar.armType === "double"
              ) {
                row = {
                  ...row,
                  n_inter: populationVar.value.interventionPop, // Updated
                  mean_inter: targetVar.value.intervention.mean,
                  sd_inter: targetVar.value.intervention.sd,
                  n_control: populationVar.value.comparisonPop, // Updated
                  mean_control: targetVar.value.comparison.mean,
                  sd_control: targetVar.value.comparison.sd,
                };
              } else {
                row = {
                  ...row,
                  n_inter: populationVar.value.interventionPop, // Updated
                  mean_inter: targetVar.value.mean,
                  sd_inter: targetVar.value.sd,
                };
              }
            } else if (targetVar.type === "population_size") {
              if (groupType === "intervention_comparison") {
                row["population_inter"] = populationVar.value.interventionPop; // Updated
                row["population_control"] = populationVar.value.comparisonPop; // Updated
              } else {
                row["population"] =
                  populationVar.value.population || getMissingValue(); // Ensure correct property
              }
            }

            // Handle additional types if necessary (e.g., 'text')
            // Add similar blocks here if 'text' type requires population size
          }

          return row;
        }

        function generateCSVContent(dataRows, format) {
          let csv = "";

          if (format === "RevMan") {
            const headers = Object.keys(dataRows[0]);
            csv += headers.join(";") + "\n";
            dataRows.forEach((row) => {
              const values = headers.map((header) => row[header]);
              csv += values.join(";") + "\n";
            });
          } else if (format === "RStudio") {
            const headers = Object.keys(dataRows[0]);
            csv += headers.join(";") + "\n";
            dataRows.forEach((row) => {
              const values = headers.map((header) => row[header]);
              csv += values.join(";") + "\n";
            });
          } else if (format === "Stata") {
            const headers = Object.keys(dataRows[0]);
            csv += headers.join(";") + "\n";
            dataRows.forEach((row) => {
              const values = headers.map((header) => row[header]);
              csv += values.join(";") + "\n";
            });
          }

          return "\uFEFF" + csv;
        }
        return (
          <div className="space-y-6">
            <h1 className="text-2xl font-bold">Preview Dataset</h1>
            <div className="flex space-x-4">
              <button
                onClick={() => setPreviewOption("baseline")}
                className={`font-semibold py-2 px-4 rounded-lg transition duration-300 ${
                  previewOption === "baseline"
                    ? "bg-blue-600"
                    : "bg-gray-700 hover:bg-gray-600"
                }`}
              >
                Baseline Data
              </button>
              <button
                onClick={() => setPreviewOption("outcomes")}
                className={`font-semibold py-2 px-4 rounded-lg transition duration-300 ${
                  previewOption === "outcomes"
                    ? "bg-blue-600"
                    : "bg-gray-700 hover:bg-gray-600"
                }`}
              >
                Outcomes Data
              </button>
              <button
                onClick={() => setPreviewOption("both")}
                className={`font-semibold py-2 px-4 rounded-lg transition duration-300 ${
                  previewOption === "both"
                    ? "bg-blue-600"
                    : "bg-gray-700 hover:bg-gray-600"
                }`}
              >
                Both
              </button>
              <button
                onClick={() => setPreviewOption("recurrent")}
                className={`font-semibold py-2 px-4 rounded-lg transition duration-300 ${
                  previewOption === "recurrent"
                    ? "bg-blue-600"
                    : "bg-gray-700 hover:bg-gray-600"
                }`}
              >
                Recurrent
              </button>
            </div>
            <div className="mt-4 flex flex-col md:flex-row md:items-center md:space-x-4">
              <div className="flex items-center space-x-4">
                <label className="font-semibold">
                  Missing Data Representation:
                </label>
                <select
                  value={missingDataRepresentation}
                  onChange={(e) => setMissingDataRepresentation(e.target.value)}
                  className="p-2 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="">Empty</option>
                  <option value="NA">NA</option>
                  <option value="N/A">N/A</option>
                  <option value=".">.</option>
                  <option value="-">-</option>
                  <option value="custom">Custom</option>
                </select>
                {missingDataRepresentation === "custom" && (
                  <input
                    type="text"
                    value={customMissingValue}
                    onChange={(e) => setCustomMissingValue(e.target.value)}
                    className="p-2 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="Enter custom value"
                  />
                )}
              </div>

              <div className="mt-4 md:mt-0 flex items-center space-x-4 relative">
                <label className="font-semibold">Weight Variable:</label>
                <button
                  onClick={() => setIsWeightOpen(!isWeightOpen)}
                  className="p-2 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 flex items-center justify-between w-48"
                >
                  {weightVariable || "None"}
                  <i className="fas fa-chevron-down ml-2"></i>
                </button>
                {isWeightOpen && (
                  <div className="absolute top-full left-0 mt-2 w-48 bg-gray-800 border border-gray-700 rounded-lg max-h-48 overflow-y-auto z-10">
                    <ul>
                      <li
                        onClick={() => {
                          setWeightVariable("");
                          setIsWeightOpen(false);
                        }}
                        className="p-2 hover:bg-gray-700 cursor-pointer"
                      >
                        None
                      </li>
                      {getWeightVariableOptions().map((label) => (
                        <li
                          key={label}
                          onClick={() => {
                            setWeightVariable(label);
                            setIsWeightOpen(false);
                          }}
                          className="p-2 hover:bg-gray-700 cursor-pointer"
                        >
                          {label}
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>

              <div className="mt-4 md:mt-0 flex items-center space-x-4">
                <label className="font-semibold">Order By:</label>
                <select
                  value={sortOrder}
                  onChange={(e) => setSortOrder(e.target.value)}
                  className="p-2 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="addition">Order of Addition</option>
                  <option value="alphabetical">Alphabetical</option>
                  <option value="fixed_alphabetical">
                    PICO + Alphabetical
                  </option>
                </select>
              </div>
            </div>
            {(() => {
              let dataRowsToRender = [];
              let variableColumns = [];
              let dataset = null;

              // Decide which dataset(s) to show
              if (previewOption === "both" || previewOption === "recurrent") {
                dataRowsToRender = combinedDataRows;
                variableColumns = [
                  ...baselineDataset.allVariableColumns,
                  ...outcomesDataset.allVariableColumns,
                ];
              } else if (previewOption === "baseline" && baselineDataset) {
                dataRowsToRender = baselineDataset.dataRows;
                variableColumns = baselineDataset.allVariableColumns;
                dataset = baselineDataset;
              } else if (previewOption === "outcomes" && outcomesDataset) {
                dataRowsToRender = outcomesDataset.dataRows;
                variableColumns = outcomesDataset.allVariableColumns;
                dataset = outcomesDataset;
              }

              // ---------------------------------------------
              // Remove "comparison" columns if single-arm
              // i.e., groupType === 'intervention'
              // ---------------------------------------------
              if (groupType === "intervention") {
                variableColumns = variableColumns.filter(
                  (col) => !col.toLowerCase().includes("comparison")
                );
              }

              if (dataRowsToRender.length > 0) {
                return (
                  <div className="overflow-x-auto mt-6">
                    <table className="w-full table-auto border-collapse">
                      <thead>
                        <tr>
                          <th
                            className="border-b-2 border-gray-700 px-4 py-2 text-left"
                            rowSpan="3"
                          >
                            Study ID
                          </th>
                          {(() => {
                            // For "both" or "recurrent": show BASELINE and OUTCOMES spanned headers
                            if (
                              previewOption === "both" ||
                              previewOption === "recurrent"
                            ) {
                              // Filter out "comparison" columns if single-arm
                              const baselineColSpan =
                                baselineDataset.allVariableColumns.filter(
                                  (col) =>
                                    groupType === "intervention_comparison" ||
                                    !col.toLowerCase().includes("comparison")
                                ).length;
                              const outcomesColSpan =
                                outcomesDataset.allVariableColumns.filter(
                                  (col) =>
                                    groupType === "intervention_comparison" ||
                                    !col.toLowerCase().includes("comparison")
                                ).length;
                              return (
                                <>
                                  {baselineColSpan > 0 && (
                                    <th
                                      className="border-b-2 border-gray-700 px-4 py-2 text-center"
                                      colSpan={baselineColSpan}
                                    >
                                      BASELINE
                                    </th>
                                  )}
                                  {outcomesColSpan > 0 && (
                                    <th
                                      className="border-b-2 border-gray-700 px-4 py-2 text-center"
                                      colSpan={outcomesColSpan}
                                    >
                                      OUTCOMES
                                    </th>
                                  )}
                                </>
                              );
                            }
                            // For just one dataset (baseline or outcomes)
                            else if (dataset) {
                              const totalColSpan =
                                dataset.allVariableColumns.filter(
                                  (col) =>
                                    groupType === "intervention_comparison" ||
                                    !col.toLowerCase().includes("comparison")
                                ).length;
                              return (
                                <th
                                  className="border-b-2 border-gray-700 px-4 py-2 text-center"
                                  colSpan={totalColSpan}
                                >
                                  {previewOption.toUpperCase()}
                                </th>
                              );
                            }
                          })()}
                        </tr>

                        {/* Second header row: each variable label (again ignoring "comparison" if single-arm) */}
                        <tr>
                          {(() => {
                            const labelHeaders = [];
                            if (
                              previewOption === "both" ||
                              previewOption === "recurrent"
                            ) {
                              // Baseline labels
                              baselineDataset.allVariableLabels.forEach(
                                (label) => {
                                  const colspan =
                                    baselineDataset.variableSubgroups[
                                      label
                                    ].filter(
                                      (sub) =>
                                        groupType ===
                                          "intervention_comparison" ||
                                        !sub
                                          .toLowerCase()
                                          .includes("comparison")
                                    ).length || 1;
                                  if (colspan > 0) {
                                    labelHeaders.push(
                                      <th
                                        key={`baseline_${label}`}
                                        className="border-b-2 border-gray-700 px-4 py-2 text-center"
                                        colSpan={colspan}
                                      >
                                        {label}
                                      </th>
                                    );
                                  }
                                }
                              );
                              // Outcomes labels
                              outcomesDataset.allVariableLabels.forEach(
                                (label) => {
                                  const colspan =
                                    outcomesDataset.variableSubgroups[
                                      label
                                    ].filter(
                                      (sub) =>
                                        groupType ===
                                          "intervention_comparison" ||
                                        !sub
                                          .toLowerCase()
                                          .includes("comparison")
                                    ).length || 1;
                                  if (colspan > 0) {
                                    labelHeaders.push(
                                      <th
                                        key={`outcomes_${label}`}
                                        className="border-b-2 border-gray-700 px-4 py-2 text-center"
                                        colSpan={colspan}
                                      >
                                        {label}
                                      </th>
                                    );
                                  }
                                }
                              );
                            } else if (dataset) {
                              // Just baseline or just outcomes
                              dataset.allVariableLabels.forEach((label) => {
                                const colspan =
                                  dataset.variableSubgroups[label].filter(
                                    (sub) =>
                                      groupType === "intervention_comparison" ||
                                      !sub.toLowerCase().includes("comparison")
                                  ).length || 1;
                                if (colspan > 0) {
                                  labelHeaders.push(
                                    <th
                                      key={label}
                                      className="border-b-2 border-gray-700 px-4 py-2 text-center"
                                      colSpan={colspan}
                                    >
                                      {label}
                                    </th>
                                  );
                                }
                              });
                            }
                            return labelHeaders;
                          })()}
                        </tr>

                        {/* Third header row: subgroups (again filtering if single-arm) */}
                        <tr>
                          {variableColumns.map((columnName) => (
                            <th
                              key={columnName}
                              className="border-b-2 border-gray-700 px-4 py-2 text-left"
                            >
                              {(() => {
                                const parts = columnName.split("_");
                                // If there's only one part, we show a blank heading;
                                // otherwise show everything after the first underscore
                                return parts.slice(1).join("_") || "\u00A0";
                              })()}
                            </th>
                          ))}
                        </tr>
                      </thead>

                      <tbody>
                        {dataRowsToRender.map((row, index) => (
                          <tr
                            key={index}
                            className={`hover:bg-gray-800 ${
                              index % 2 === 0 ? "bg-gray-900" : "bg-gray-800"
                            }`}
                          >
                            <td className="px-4 py-2">{row.studyId}</td>
                            {variableColumns.map((columnName) => {
                              const cellValue =
                                row.variables[columnName] || getMissingValue();
                              return (
                                <td key={columnName} className="px-4 py-2">
                                  {cellValue}
                                </td>
                              );
                            })}
                          </tr>
                        ))}

                        {/* Weighted averages row (if any) */}
                        {Object.keys(weightedAverages).length > 0 && (
                          <tr className="bg-gray-700">
                            <td className="px-4 py-2 font-semibold">
                              Weighted Averages
                            </td>
                            {variableColumns.map((columnName) => {
                              const avgValue = weightedAverages[columnName];
                              return (
                                <td key={columnName} className="px-4 py-2">
                                  {avgValue !== undefined &&
                                  avgValue !== getMissingValue()
                                    ? avgValue.toFixed(2)
                                    : getMissingValue()}
                                </td>
                              );
                            })}
                          </tr>
                        )}
                      </tbody>
                    </table>
                  </div>
                );
              } else {
                return (
                  <p className="text-gray-400">
                    No data available for preview.
                  </p>
                );
              }
            })()}

            <div className="flex flex-col md:flex-row md:justify-between mt-8 space-y-4 md:space-y-0 md:space-x-4">
              <button
                onClick={onBack}
                className="flex items-center justify-center bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
              >
                <i className="fas fa-arrow-left mr-2"></i> Back
              </button>
              <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0">
                <button
                  onClick={onBackupDownload}
                  className="flex items-center justify-center bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
                >
                  <i className="fas fa-save mr-2"></i> Save Backup
                </button>
                <button
  onClick={handlePicoDownload}
  className="flex items-center justify-center bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
>
  <i className="fas fa-table mr-2"></i> PICO TABLE
</button>
                <button
                  onClick={handleSave}
                  className="flex items-center justify-center bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
                >
                  <i className="fas fa-download mr-2"></i> Save Spreadsheet
                </button>
                <button
                  onClick={openDownloadFolderModal}
                  className="flex items-center justify-center bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
                >
                  <i className="fas fa-folder-open mr-2"></i> Download Folder
                </button>
                <button
                  onClick={openDriveModal}
                  className="flex items-center justify-center bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
                >
                  <i className="fas fa-cloud mr-2"></i> Google Drive
                </button>
              </div>
            </div>

            {/* Download Folder Modal */}
            {isDownloadModalOpen && (
              <div className="fixed inset-0 flex items-center justify-center z-50">
                <div className="absolute inset-0 bg-black opacity-50"></div>
                <div className="bg-gray-900 text-gray-100 p-6 rounded-lg z-50 w-11/12 md:w-2/3 lg:w-1/2">
                  <h2 className="text-xl font-bold mb-4">
                    Download Folder with Variables
                  </h2>
                  <div className="mt-4">
                    <label className="block font-semibold mb-2">
                      Select Format
                    </label>
                    <select
                      value={selectedFormat}
                      onChange={(e) => setSelectedFormat(e.target.value)}
                      className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                      <option value="RevMan">RevMan</option>
                      <option value="RStudio">RStudio</option>
                      <option value="Stata">Stata</option>{" "}
                      {/* New Format Added */}
                    </select>
                  </div>
                  <div className="mt-4">
                    <label className="block font-semibold mb-2">
                      Select Population Size Variable
                    </label>
                    <select
                      value={selectedPopulationVariable}
                      onChange={(e) =>
                        setSelectedPopulationVariable(e.target.value)
                      }
                      className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                      {getPopulationVariableOptions().map((label) => (
                        <option key={label} value={label}>
                          {label}
                        </option>
                      ))}
                    </select>
                  </div>
                  <div className="mt-4 flex items-center">
                    <input
                      type="checkbox"
                      checked={onlyCompleteStudies}
                      onChange={(e) => setOnlyCompleteStudies(e.target.checked)}
                      className="form-checkbox h-5 w-5 text-blue-600"
                    />
                    <label className="ml-2 font-semibold">
                      Just studies with all the Variable data
                    </label>
                  </div>
                  <div className="mt-6 flex justify-end space-x-4">
                    <button
                      onClick={closeDownloadFolderModal}
                      className="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
                    >
                      Close
                    </button>
                    <button
                      onClick={handleDownloadFolder}
                      className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300 flex items-center"
                    >
                      <i className="fas fa-folder-open mr-2"></i> Download
                      Folder
                    </button>
                  </div>
                </div>
              </div>
            )}
            {isDriveModalOpen && (
              <div className="fixed inset-0 flex items-center justify-center z-50">
                <div className="absolute inset-0 bg-black opacity-50"></div>
                <div
                  className="relative bg-gray-900 text-gray-100 p-6 rounded-lg w-11/12 md:w-2/3 lg:w-1/2 max-h-96 overflow-y-auto"
                  style={{
                    border: "1px solid #4A4A4A",
                    boxShadow: "0 0 20px #00FFD1",
                  }}
                >
                  <h2 className="text-2xl font-bold mb-4 text-indigo-300">
                    Google Drive Links
                  </h2>
                  <p className="mb-4 text-gray-400">
                    Add your Google Drive folder links here. This will help open
                    related pages after downloads.
                  </p>

                  <div className="mb-4">
                    <label className="block font-semibold mb-2 text-indigo-200">
                      Select Folder Category
                    </label>
                    <select
                      value={selectedDriveCategory}
                      onChange={(e) => setSelectedDriveCategory(e.target.value)}
                      className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
                    >
                      <option value="Backup Files">Backup Files</option>
                      <option value="Spreadsheet Files">
                        Spreadsheet Files
                      </option>
                      <option value="Variable Files">Variable Files</option>
                    </select>
                  </div>

                  <div className="mb-4">
                    <label className="block font-semibold mb-2 text-indigo-200">
                      New Link
                    </label>
                    <input
                      type="text"
                      value={newDriveLink}
                      onChange={(e) => setNewDriveLink(e.target.value)}
                      placeholder="Paste your Google Drive link here..."
                      className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
                    />
                    <button
                      onClick={handleAddDriveLink}
                      className="mt-2 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
                    >
                      Add New Link
                    </button>
                  </div>

                  <div>
                    <h3 className="text-xl font-semibold text-indigo-300 mb-2">
                      Your Links
                    </h3>
                    {Object.keys(driveLinks).map((category) => (
                      <div key={category} className="mb-4">
                        <h4 className="font-semibold text-indigo-200 mb-2">
                          {category}
                        </h4>
                        {driveLinks[category].length > 0 ? (
                          <ul className="space-y-1 text-gray-300">
                            {driveLinks[category].map((link, index) => (
                              <li
                                key={index}
                                className="flex justify-between items-center bg-gray-800 p-2 rounded"
                              >
                                <a
                                  href={link}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="underline hover:text-indigo-400 truncate"
                                  style={{ maxWidth: "85%" }}
                                >
                                  {link}
                                </a>
                                {/* Delete Button */}
                                <button
                                  onClick={() =>
                                    removeDriveLink(category, index)
                                  }
                                  className="text-red-500 hover:text-red-700 p-1 ml-2"
                                >
                                  <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    viewBox="0 0 448 512"
                                    className="w-4 h-4 fill-current"
                                  >
                                    <path d="M135.2 17.7L128 32 32 32C14.3 32 0 46.3 0 64S14.3 96 32 96l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0-7.2-14.3C307.4 6.8 296.3 0 284.2 0L163.8 0c-12.1 0-23.2 6.8-28.6 17.7zM416 128L32 128 53.2 467c1.6 25.3 22.6 45 47.9 45l245.8 0c25.3 0 46.3-19.7 47.9-45L416 128z" />
                                  </svg>
                                </button>
                              </li>
                            ))}
                          </ul>
                        ) : (
                          <p className="text-gray-500 text-sm">
                            No links added yet.
                          </p>
                        )}
                      </div>
                    ))}
                  </div>

                  <div className="mt-6 flex justify-end space-x-4">
                    <button
                      onClick={closeDriveModal}
                      className="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
                    >
                      Close
                    </button>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      ReactDOM.render(<App />, document.getElementById("root"));
    </script>
  </body>
</html>
