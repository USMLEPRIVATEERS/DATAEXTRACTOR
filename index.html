<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Data Extraction App for research data management" />
    <title>Data Extraction App</title>
    <!-- Preconnect to CDNs for faster resource loading -->
    <link rel="preconnect" href="https://unpkg.com">
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <!-- Tailwind CSS -->
    <link
      href="https://unpkg.com/tailwindcss@^2.2/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <!-- Include SheetJS library for Excel file generation - Deferred loading -->
    <script defer src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <!-- Existing scripts... -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <!-- Include FileSaver.js library - Deferred loading -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- Font Awesome for icons -->
    <!-- Removed due to CORS issues when opening from file:// -->
    <style>
      /* CSS Variables for Theme System */
      :root {
        /* Backgrounds */
        --bg-primary: #ffffff;
        --bg-secondary: #f4f3ee;
        --bg-tertiary: #f4f3ee;
        --bg-navbar: #ffffff;
        --bg-button-primary: #c15f3c;
        --bg-button-primary-hover: #a04d2f;
        --bg-button-secondary: #b1ada1;
        --bg-button-secondary-hover: #9a9789;
        --bg-button-white: #ffffff;
        --bg-button-white-hover: #f4f3ee;
        --bg-input: #ffffff;
        --bg-table-row: #ffffff;
        --bg-table-row-hover: #f4f3ee;
        --bg-modal: rgba(255, 255, 255, 0.98);
        --bg-modal-overlay: rgba(0, 0, 0, 0.5);

        /* Text colors */
        --text-primary: #111827;
        --text-secondary: #374151;
        --text-tertiary: #6b7280;
        --text-on-button-colored: #ffffff;
        --text-on-button-white: #111827;

        /* Borders */
        --border-primary: #b1ada1;
        --border-secondary: #b1ada1;
        --border-navbar: #b1ada1;
        --border-input: #b1ada1;
        --border-table: #b1ada1;

        /* Scrollbar */
        --scrollbar-track: #f4f3ee;
        --scrollbar-thumb: #b1ada1;
        --scrollbar-thumb-hover: #9a9789;

        /* Container */
        --container-bg: #ffffff;
        --container-border: #b1ada1;
        --container-shadow: rgba(193, 95, 60, 0.1);

        /* Neon/Accent colors */
        --neon-primary: #c15f3c;
        --neon-secondary: #b1ada1;
        --accent-color: #c15f3c;

        /* Special effects */
        --dropzone-border: rgba(193, 95, 60, 0.4);
        --dropzone-bg-hover: rgba(193, 95, 60, 0.05);
        --dropzone-shadow: rgba(193, 95, 60, 0.2);
        --overlay-gradient-1: rgba(193, 95, 60, 0.08);
        --overlay-gradient-2: rgba(177, 173, 161, 0.08);
        --hover-shadow: rgba(193, 95, 60, 0.1);
      }

      body.dark-mode {
        /* Backgrounds */
        --bg-primary: linear-gradient(135deg, #0c0c0c 0%, #1e1e1e 100%);
        --bg-secondary: #1a1a1a;
        --bg-tertiary: #242424;
        --bg-navbar: #1a1a1a;
        --bg-button-primary: #5b9dd9;
        --bg-button-primary-hover: #6ba8e3;
        --bg-button-secondary: #4a6d8c;
        --bg-button-secondary-hover: #5a7d9c;
        --bg-input: #1e1e1e;
        --bg-table-row: #1a1a1a;
        --bg-table-row-hover: #242424;
        --bg-modal: rgba(26, 26, 26, 0.98);
        --bg-modal-overlay: rgba(0, 0, 0, 0.8);

        /* Text colors */
        --text-primary: #e8e8e8;
        --text-secondary: #e0e0e0;
        --text-tertiary: #d1d1d1;
        --text-on-button: #ffffff;

        /* Borders - mais destacadas */
        --border-primary: #5b9dd9;
        --border-secondary: #4a8bc7;
        --border-navbar: #3a3a3a;
        --border-input: #5b9dd9;
        --border-table: #4a8bc7;

        /* Scrollbar */
        --scrollbar-track: #242424;
        --scrollbar-thumb: #5b9dd9;
        --scrollbar-thumb-hover: #6ba8e3;

        /* Container */
        --container-bg: #1a1a1a;
        --container-border: #5b9dd9;
        --container-shadow: rgba(91, 157, 217, 0.3);

        /* Accent colors - azul fosco */
        --neon-primary: #5b9dd9;
        --neon-secondary: #6ba8e3;
        --accent-color: #5b9dd9;

        /* Special effects */
        --dropzone-border: rgba(91, 157, 217, 0.5);
        --dropzone-bg-hover: rgba(91, 157, 217, 0.08);
        --dropzone-shadow: rgba(91, 157, 217, 0.3);
        --overlay-gradient-1: rgba(91, 157, 217, 0.12);
        --overlay-gradient-2: rgba(107, 168, 227, 0.12);
        --hover-shadow: rgba(91, 157, 217, 0.15);
      }

      /* Theme Toggle Button Styles */
      .theme-toggle {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 100;
        background: var(--container-bg);
        border: 2px solid var(--border-primary);
        border-radius: 50%;
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 6px var(--container-shadow);
      }

      .theme-toggle:hover {
        transform: scale(1.1) rotate(15deg);
        border-color: var(--neon-primary);
        box-shadow: 0 0 20px var(--dropzone-shadow);
      }

      .theme-toggle svg {
        width: 26px;
        height: 26px;
        color: var(--text-primary);
        transition: all 0.3s ease;
      }

      .theme-toggle svg path {
        stroke: var(--text-primary);
      }

      .dragging {
        opacity: 0.3;
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.25),
          inset 0 0 15px rgba(0, 255, 255, 0.15);
        transition: opacity 0.2s ease-in-out, box-shadow 0.2s ease-in-out,
          transform 0.3s ease;
        border-radius: 12px; /* More pronounced rounding for 3D corners */
        transform: perspective(1000px) translateZ(20px) rotateX(2deg)
          rotateY(-1.5deg);
      }

      .dropzone {
        transition: all 0.3s ease-in-out;
        border: 2px dashed var(--dropzone-border);
        border-radius: 16px;
        position: relative;
      }
      .dropzone:hover {
        background: var(--dropzone-bg-hover);
        box-shadow: inset 0 0 10px var(--dropzone-bg-hover),
          0 0 15px var(--dropzone-shadow);
        transform: perspective(800px) translateZ(5px);
      }

      /*****************************************
   * CUSTOM SCROLLBARS (MORE ROUNDED / 3D)
   *****************************************/
      /* Chrome, Safari, Edge */
      ::-webkit-scrollbar {
        width: 12px;
      }
      ::-webkit-scrollbar-track {
        background: var(--scrollbar-track);
        border-radius: 12px;
      }
      ::-webkit-scrollbar-thumb {
        background: var(--scrollbar-thumb);
        border-radius: 12px;
        border: 2px solid var(--scrollbar-track);
      }
      ::-webkit-scrollbar-thumb:hover {
        background: var(--scrollbar-thumb-hover);
      }

      /* Firefox */
      * {
        scrollbar-width: thin;
        scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
      }
      .modern-scrollbar {
        scrollbar-width: thin;
        scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
      }
      .modern-scrollbar::-webkit-scrollbar {
        width: 12px;
      }
      .modern-scrollbar::-webkit-scrollbar-track {
        background: var(--scrollbar-track);
        border-radius: 12px;
      }
      .modern-scrollbar::-webkit-scrollbar-thumb {
        background: var(--scrollbar-thumb);
        border-radius: 12px;
        border: 2px solid var(--scrollbar-track);
      }
      .modern-scrollbar::-webkit-scrollbar-thumb:hover {
        background: var(--scrollbar-thumb-hover);
      }

      /*****************************************
   * GLOBAL THEME & BASE FONTS
   *****************************************/
      body {
        background: var(--bg-secondary);
        font-family: "Inter", sans-serif;
        color: var(--text-primary);
        margin: 0;
        padding: 0;
        overflow-x: hidden;
        transition: background 0.3s ease, color 0.3s ease;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      body.dark-mode {
        background: linear-gradient(135deg, #0c0c0c 0%, #1e1e1e 100%);
      }

      #root {
        width: 100%;
        padding: 1.5rem;
      }

      /*****************************************
   * MAIN CONTAINER (FUTURISTIC 3D NEON BOX)
   *****************************************/
      #root > div {
        background: var(--container-bg);
        border: 1px solid var(--container-border);
        border-radius: 20px; /* bigger rounding for a more 3D look */
        position: relative;
        padding: 24px;
        overflow: hidden;
        box-shadow: 0 0 25px var(--container-shadow),
          0 0 15px var(--dropzone-shadow), inset 0 0 16px var(--container-shadow);
        transform: perspective(1400px) translateZ(0);
        transition: all 0.3s ease;
      }
      /* Subtle animated gradient overlay for a futuristic feel */
      #root > div::before {
        content: "";
        position: absolute;
        top: -40%;
        left: -40%;
        width: 180%;
        height: 180%;
        background: radial-gradient(
            circle at 30% 30%,
            var(--overlay-gradient-1),
            transparent 40%
          ),
          radial-gradient(
            circle at 70% 70%,
            var(--overlay-gradient-2),
            transparent 40%
          ),
          linear-gradient(135deg, var(--overlay-gradient-1) 0%, transparent 100%);
        pointer-events: none;
        z-index: 0;
        border-radius: 50%;
        animation: floatAround 10s infinite alternate ease-in-out;
      }
      @keyframes floatAround {
        0% {
          transform: translate(0, 0) rotate(0deg);
        }
        50% {
          transform: translate(6%, -6%) rotate(8deg);
        }
        100% {
          transform: translate(-4%, 5%) rotate(-8deg);
        }
      }

      /*****************************************
   * TITLES WITH UNDERLINE ONLY UNDER TEXT
   *****************************************/
      .parent-heading {
        text-align: center;
      }
      h1,
      h2,
      h3 {
        margin: 0;
        font-weight: 700;
        color: var(--text-primary);
        text-shadow: 0 0 6px rgba(255, 255, 255, 0.04);
        display: inline-block; /* limit underline width to text only */
        position: relative;
        padding-bottom: 8px; /* spacing so the underline is right below */
      }
      /* NEON UNDERLINE DIRECTLY BELOW THE WORDS */
      h1::after,
      h2::after,
      h3::after {
        content: "";
        position: absolute;
        left: 0;
        bottom: 0; /* underline sits right at the bottom of the text container */
        width: 100%;
        height: 3px;
        background: linear-gradient(90deg, var(--neon-primary), var(--neon-secondary), var(--neon-primary));
        border-radius: 2px;
        animation: neonFlow 2.5s linear infinite;
      }
      @keyframes neonFlow {
        0% {
          background-position: 0%;
        }
        100% {
          background-position: 200%;
        }
      }

      /*****************************************
   * MODAL BACKGROUND (BLUR + 3D)
   *****************************************/
      .modal-bg {
        backdrop-filter: blur(12px) brightness(0.85);
        background-color: var(--bg-modal);
        border-radius: 14px;
        box-shadow: 0 0 20px var(--dropzone-shadow);
        border: 1px solid var(--border-primary);
        animation: popIn 0.4s ease;
      }

      /* Modal overlay */
      .fixed.inset-0.bg-black {
        background-color: var(--bg-modal-overlay) !important;
      }
      @keyframes popIn {
        0% {
          transform: scale(0.8) translateY(10px);
          opacity: 0;
        }
        100% {
          transform: scale(1) translateY(0);
          opacity: 1;
        }
      }

      /* Special Modals (Calculator & Import Data) */
      .special-modal-container {
        background: #ffffff;
        border: 2px solid #b1ada1;
        box-shadow: 0 0 50px rgba(193, 95, 60, 0.2);
      }

      .special-modal-header-icon {
        background: linear-gradient(135deg, #c15f3c 0%, #a04d2f 100%);
      }

      .special-modal-title {
        background: linear-gradient(90deg, #c15f3c 0%, #a04d2f 100%);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }

      .special-modal-border {
        border-color: #b1ada1;
      }

      .special-modal-text {
        color: #111827;
      }

      .special-modal-label {
        color: #374151;
      }

      body.dark-mode .special-modal-container {
        background: linear-gradient(135deg, #0c0c0c 0%, #1e1e1e 100%);
        border: 2px solid #5b9dd9;
        box-shadow: 0 0 50px rgba(91, 157, 217, 0.3);
      }

      body.dark-mode .special-modal-header-icon {
        background: linear-gradient(135deg, #5b9dd9 0%, #4a8bc7 100%);
      }

      body.dark-mode .special-modal-title {
        background: linear-gradient(90deg, #5b9dd9 0%, #6ba8e3 100%);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }

      body.dark-mode .special-modal-border {
        border-color: #5b9dd9;
      }

      body.dark-mode .special-modal-text {
        color: #e8e8e8;
      }

      body.dark-mode .special-modal-label {
        color: #d1d1d1;
      }

      /* Apply to all labels and text inside special modals */
      .special-modal-container label {
        color: #374151;
      }

      body.dark-mode .special-modal-container label {
        color: #d1d1d1;
      }

      /* Close button styling */
      .special-modal-container .text-gray-400 {
        color: #6b7280 !important;
      }

      body.dark-mode .special-modal-container .text-gray-400 {
        color: #9ca3af !important;
      }

      .special-modal-container .text-gray-400:hover {
        color: #111827 !important;
      }

      body.dark-mode .special-modal-container .text-gray-400:hover {
        color: #e8e8e8 !important;
      }

      /*****************************************
   * FORM ELEMENTS (3D-EDGED INPUTS)
   *****************************************/
      input[type="number"],
      input[type="text"],
      textarea,
      select {
        background: var(--bg-input);
        border: 2px solid var(--border-input);
        color: var(--text-primary);
        padding: 0.625rem 0.75rem;
        border-radius: 8px;
        transition: border-color 0.3s ease, box-shadow 0.3s ease,
          transform 0.3s ease;
      }
      input::placeholder,
      textarea::placeholder {
        color: #858585;
      }
      input:focus,
      textarea:focus,
      select:focus {
        border-color: var(--accent-color);
        box-shadow: 0 0 12px var(--dropzone-shadow),
          inset 0 0 6px var(--dropzone-bg-hover);
        outline: none;
        transform: perspective(800px) translateZ(6px) rotateX(1deg);
      }

      /*****************************************
   * BUTTONS (TRANSPARENT 3D GLASS EFFECT)
   *****************************************/
      button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.75rem 1.25rem;
        border: 2px solid var(--neon-secondary);
        border-radius: 10px;
        font-weight: 600;
        cursor: pointer;
        color: var(--text-primary);

        /* Transparent "glass" background with slight blur */
        background: rgba(255, 255, 255, 0.06);
        backdrop-filter: blur(6px);

        transition: transform 0.25s ease, box-shadow 0.35s ease,
          border 0.25s ease;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.6),
          inset 0 0 4px var(--dropzone-bg-hover);
      }

      button:hover {
        transform: translateY(-3px) scale(1.04) perspective(1000px)
          rotateX(2deg);
        border-color: var(--neon-primary);
        box-shadow: 0 5px 15px var(--dropzone-shadow),
          0 0 5px var(--hover-shadow), inset 0 0 8px var(--dropzone-bg-hover);
      }

      button:active {
        transform: scale(0.98) translateY(2px);
        border-color: var(--neon-secondary);
        box-shadow: 0 4px 10px var(--dropzone-shadow),
          inset 0 0 6px var(--dropzone-bg-hover);
      }

      /* If you have color classes for borders, you could do something like:
     .bg-blue-500 { border-color: var(--neon-primary); }
     .bg-purple-500 { border-color: var(--neon-secondary); }
     etc...
     Just remove the default background-color approach, since these are now glassy.
  */

      /*****************************************
   * SCROLLABLE AREAS / HISTORY
   *****************************************/
      .max-h-96 {
        max-height: 24rem;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        border-radius: 10px;
        box-shadow: inset 0 0 6px var(--hover-shadow);
        transition: box-shadow 0.3s ease;
      }
      .max-h-96:hover {
        box-shadow: inset 0 0 10px var(--dropzone-shadow);
      }

      /*****************************************
   * TABLE & NEON HEADERS (3D-EFFECT)
   *****************************************/
      table {
        border-collapse: collapse;
        width: 100%;
        color: var(--text-primary);
        background: var(--bg-table-row);
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 2px 5px var(--container-shadow),
          inset 0 0 10px var(--hover-shadow);
        transform: translateZ(0);
      }
      th,
      td {
        border: 1px solid var(--border-table);
        text-align: center;
        padding: 0.75rem;
        transition: background 0.2s ease, box-shadow 0.2s ease;
      }
      th {
        background: var(--bg-tertiary);
        position: relative;
        font-weight: 600;
        overflow: hidden;
        color: var(--text-primary);
      }
      th::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(45deg, var(--neon-primary), var(--neon-secondary));
        opacity: 0.08;
      }
      tr:hover td {
        box-shadow: inset 0 0 6px var(--hover-shadow);
      }
      td:hover {
        background: var(--bg-table-row-hover);
        box-shadow: inset 0 0 6px var(--hover-shadow);
        transform: perspective(600px) translateZ(2px);
      }

      /*****************************************
   * TEXT & LABELS
   *****************************************/
      label,
      strong,
      p,
      span {
        color: var(--text-secondary) !important;
      }

      input,
      option,
      select,
      textarea {
        color: var(--text-primary) !important;
        background-color: var(--bg-input) !important;
        border-color: var(--border-input) !important;
      }

      /*****************************************
   * UTILITY CLASSES TO OVERRIDE TAILWIND
   *****************************************/
      /* Background utilities */
      .bg-gray-900,
      .bg-gray-800,
      .bg-gray-700 {
        background-color: var(--bg-navbar) !important;
      }

      .bg-gray-100,
      .bg-gray-50 {
        background-color: var(--bg-secondary) !important;
      }

      /* Text utilities */
      .text-gray-100,
      .text-gray-200,
      .text-white {
        color: var(--text-primary) !important;
      }

      .text-gray-300,
      .text-gray-400,
      .text-gray-500,
      .text-gray-600 {
        color: var(--text-secondary) !important;
      }

      .text-gray-700,
      .text-gray-800 {
        color: var(--text-tertiary) !important;
      }

      /* Border utilities */
      .border-gray-700,
      .border-gray-600,
      .border-gray-500 {
        border-color: var(--border-navbar) !important;
      }

      .border-gray-300,
      .border-gray-400 {
        border-color: var(--border-primary) !important;
      }

      /* Button styles */
      button {
        transition: all 0.3s ease;
      }

      .bg-blue-600 {
        background-color: var(--bg-button-primary) !important;
        color: var(--text-on-button-colored) !important;
      }

      .bg-blue-600:hover,
      .hover\:bg-blue-700:hover {
        background-color: var(--bg-button-primary-hover) !important;
        color: var(--text-on-button-colored) !important;
      }

      /* White buttons with black text */
      .btn-white {
        background-color: var(--bg-button-white) !important;
        color: var(--text-on-button-white) !important;
        border: 1px solid var(--border-primary) !important;
      }

      .btn-white:hover {
        background-color: var(--bg-button-white-hover) !important;
        color: var(--text-on-button-white) !important;
      }

      /* Secondary colored buttons (beige/gray) with white text */
      button.bg-gray-700,
      button.bg-gray-800,
      button.bg-gray-600 {
        background-color: var(--bg-button-secondary) !important;
        color: var(--text-on-button-colored) !important;
      }

      button.bg-gray-700:hover,
      button.bg-gray-800:hover,
      button.bg-gray-600:hover,
      button.hover\:bg-gray-600:hover {
        background-color: var(--bg-button-secondary-hover) !important;
        color: var(--text-on-button-colored) !important;
      }

      .bg-red-600:hover,
      .hover\:bg-red-700:hover {
        background-color: #dc2626 !important;
      }

      .bg-green-600:hover,
      .hover\:bg-green-700:hover {
        background-color: #16a34a !important;
      }

      /* Table styles */
      table {
        color: var(--text-primary);
      }

      tbody tr {
        background-color: var(--bg-table-row) !important;
        border-color: var(--border-table) !important;
      }

      tbody tr:hover {
        background-color: var(--bg-table-row-hover) !important;
      }

      td,
      th {
        border-color: var(--border-table) !important;
      }

      /* PICO Table Highlight Colors - Override global td styles */
      .bg-green-900\/40 {
        background-color: rgba(20, 83, 45, 0.4) !important;
      }

      .bg-red-900\/40 {
        background-color: rgba(127, 29, 29, 0.4) !important;
      }

      .border-green-500 {
        border-color: #10b981 !important;
      }

      .border-red-500 {
        border-color: #ef4444 !important;
      }

      /* Dark mode adjustments for PICO table highlights */
      body.dark-mode .bg-green-900\/40 {
        background-color: rgba(20, 83, 45, 0.5) !important;
      }

      body.dark-mode .bg-red-900\/40 {
        background-color: rgba(127, 29, 29, 0.5) !important;
      }

      /* Prevent hover effects from overriding PICO highlights */
      td.bg-green-900\/40:hover,
      td.bg-red-900\/40:hover {
        background-color: inherit !important;
      }

      tr:hover td.bg-green-900\/40 {
        background-color: rgba(20, 83, 45, 0.4) !important;
      }

      tr:hover td.bg-red-900\/40 {
        background-color: rgba(127, 29, 29, 0.4) !important;
      }

      body.dark-mode tr:hover td.bg-green-900\/40 {
        background-color: rgba(20, 83, 45, 0.5) !important;
      }

      body.dark-mode tr:hover td.bg-red-900\/40 {
        background-color: rgba(127, 29, 29, 0.5) !important;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- React and ReactDOM - Production versions for better performance -->
    <script
      src="https://unpkg.com/react@17/umd/react.production.min.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"
      crossorigin
    ></script>

    <!-- Babel for JSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      // ============================================
      // PROJECT MANAGEMENT SYSTEM
      // ============================================
      const STORAGE_KEY = 'data_extraction_projects';

      /**
       * Generates a unique project ID
       * Format: project_[timestamp]_[random9chars]
       */
      function generateProjectId() {
        const timestamp = Date.now();
        const randomStr = Math.random().toString(36).substring(2, 11);
        return `project_${timestamp}_${randomStr}`;
      }

      /**
       * Saves the projects list to localStorage
       */
      function saveProjectsList(projects) {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(projects));
          return true;
        } catch (error) {
          console.error('Error saving projects:', error);
          alert('Error saving: insufficient browser storage!');
          return false;
        }
      }

      /**
       * Retrieves all projects from localStorage
       */
      function getAllProjects() {
        try {
          const data = localStorage.getItem(STORAGE_KEY);
          return data ? JSON.parse(data) : [];
        } catch (error) {
          console.error('Error loading projects:', error);
          return [];
        }
      }

      /**
       * Gets projects sorted by update date (most recent first)
       */
      function getProjectsSortedByDate() {
        const projects = getAllProjects();
        return projects.sort((a, b) => {
          return new Date(b.updatedAt) - new Date(a.updatedAt);
        });
      }

      /**
       * Formats ISO date string for display
       */
      function formatDate(isoString) {
        const date = new Date(isoString);
        return date.toLocaleString('en-US', {
          month: '2-digit',
          day: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      }

      /**
       * Escapes HTML to prevent XSS
       */
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      /**
       * PICO Table Preview Component
       * Displays editable table with color highlighting for recognized/unrecognized items
       */
      function PicoTablePreview({
        data,
        orientation,
        studyIds,
        suggestedLabels,
        variableMappings,
        studyMappings,
        onDataChange,
        onVariableMappingChange,
        onStudyMappingChange
      }) {
        const [editingCell, setEditingCell] = useState(null);
        const [dropdownOpen, setDropdownOpen] = useState(null);
        const [hoveredAction, setHoveredAction] = useState(null); // { type: 'row'|'col', index: number }
        const [hoverTimeout, setHoverTimeout] = useState(null);

        // Close dropdown when clicking outside
        useEffect(() => {
          const handleClickOutside = (e) => {
            if (dropdownOpen && !e.target.closest('.pico-dropdown-cell')) {
              setDropdownOpen(null);
            }
          };

          if (dropdownOpen) {
            document.addEventListener('click', handleClickOutside);
            return () => document.removeEventListener('click', handleClickOutside);
          }
        }, [dropdownOpen]);

        // Handle hover with 3-second delay on mouse leave
        const handleActionHover = (type, index) => {
          // Clear any existing timeout
          if (hoverTimeout) {
            clearTimeout(hoverTimeout);
            setHoverTimeout(null);
          }
          setHoveredAction({ type, index });
        };

        const handleActionLeave = () => {
          // Set 3-second delay before hiding
          const timeout = setTimeout(() => {
            setHoveredAction(null);
          }, 3000);
          setHoverTimeout(timeout);
        };

        const handleActionMouseEnter = () => {
          // Cancel hide timeout if mouse re-enters
          if (hoverTimeout) {
            clearTimeout(hoverTimeout);
            setHoverTimeout(null);
          }
        };

        // Cleanup timeout on unmount
        useEffect(() => {
          return () => {
            if (hoverTimeout) {
              clearTimeout(hoverTimeout);
            }
          };
        }, [hoverTimeout]);

        const updateCell = (rowIdx, colIdx, value) => {
          const newData = data.map((row, rIdx) =>
            rIdx === rowIdx
              ? row.map((cell, cIdx) => (cIdx === colIdx ? value : cell))
              : row
          );
          onDataChange(newData);
        };

        const addRow = (afterRowIdx) => {
          const newRow = new Array(data[0].length).fill('');
          const newData = [...data];
          // Insert after the clicked row
          newData.splice(afterRowIdx + 1, 0, newRow);
          onDataChange(newData);
        };

        const removeRow = (rowIdx) => {
          if (data.length <= 2) {
            alert('Cannot remove row - table must have at least header and one data row');
            return;
          }
          onDataChange(data.filter((_, idx) => idx !== rowIdx));
        };

        const addColumn = (afterColIdx) => {
          const newData = data.map(row => {
            const newRow = [...row];
            // Insert empty cell after the clicked column
            newRow.splice(afterColIdx + 1, 0, '');
            return newRow;
          });
          onDataChange(newData);
        };

        const removeColumn = (colIdx) => {
          if (data[0].length <= 2) {
            alert('Cannot remove column - table must have at least 2 columns');
            return;
          }
          onDataChange(data.map(row => row.filter((_, idx) => idx !== colIdx)));
        };

        const isVariableRecognized = (label) => {
          return suggestedLabels.includes(label);
        };

        const isStudyRecognized = (studyId) => {
          return studyIds.includes(studyId);
        };

        const getCellHighlight = (rowIdx, colIdx, value) => {
          if (rowIdx === 0 && colIdx === 0) return 'bg-gray-700'; // Corner cell

          if (orientation === 'rows') {
            // First row = variable labels (except first cell)
            // First column = study IDs (except first cell)
            if (rowIdx === 0 && colIdx > 0) {
              const mapped = variableMappings[value] || value;
              return isVariableRecognized(mapped) ? 'bg-green-900/40 border-green-500' : 'bg-red-900/40 border-red-500';
            }
            if (colIdx === 0 && rowIdx > 0) {
              const mapped = studyMappings[value] || value;
              return isStudyRecognized(mapped) ? 'bg-green-900/40 border-green-500' : 'bg-red-900/40 border-red-500';
            }
          } else {
            // First row = study IDs (except first cell)
            // First column = variable labels (except first cell)
            if (rowIdx === 0 && colIdx > 0) {
              const mapped = studyMappings[value] || value;
              return isStudyRecognized(mapped) ? 'bg-green-900/40 border-green-500' : 'bg-red-900/40 border-red-500';
            }
            if (colIdx === 0 && rowIdx > 0) {
              const mapped = variableMappings[value] || value;
              return isVariableRecognized(mapped) ? 'bg-green-900/40 border-green-500' : 'bg-red-900/40 border-red-500';
            }
          }

          return 'bg-gray-800/30';
        };

        const handleCellClick = (rowIdx, colIdx, value) => {
          // If dropdown is already open for this cell, close it
          if (dropdownOpen?.rowIdx === rowIdx && dropdownOpen?.colIdx === colIdx) {
            setDropdownOpen(null);
            return;
          }

          const isHeader = (orientation === 'rows' && (rowIdx === 0 || colIdx === 0)) ||
                          (orientation === 'columns' && (rowIdx === 0 || colIdx === 0));

          if (!isHeader || (rowIdx === 0 && colIdx === 0)) return;

          const isVariable = (orientation === 'rows' && rowIdx === 0) || (orientation === 'columns' && colIdx === 0);
          const isStudy = (orientation === 'rows' && colIdx === 0) || (orientation === 'columns' && rowIdx === 0);

          if (isVariable) {
            const mapped = variableMappings[value] || value;
            if (!isVariableRecognized(mapped)) {
              setDropdownOpen({ type: 'variable', rowIdx, colIdx, value });
            }
          } else if (isStudy) {
            const mapped = studyMappings[value] || value;
            if (!isStudyRecognized(mapped)) {
              setDropdownOpen({ type: 'study', rowIdx, colIdx, value });
            }
          }
        };

        const handleMapping = (mappedValue) => {
          if (!dropdownOpen) return;

          if (dropdownOpen.type === 'variable') {
            onVariableMappingChange({ ...variableMappings, [dropdownOpen.value]: mappedValue });
          } else if (dropdownOpen.type === 'study') {
            onStudyMappingChange({ ...studyMappings, [dropdownOpen.value]: mappedValue });
          }

          setDropdownOpen(null);
        };

        return (
          <div className="overflow-x-auto">
            <table className="w-full border-collapse text-sm">
              <tbody>
                {data.map((row, rowIdx) => (
                  <tr key={rowIdx}>
                    {row.map((cell, colIdx) => {
                      // Determine if this cell should show action buttons
                      const isFirstColumn = colIdx === 0;
                      const isFirstRow = rowIdx === 0;
                      const showRowActions = isFirstColumn && rowIdx > 0;
                      const showColActions = isFirstRow && colIdx > 0;

                      return (
                        <td
                          key={`${rowIdx}-${colIdx}`}
                          className={`border border-gray-600 p-2 relative pico-dropdown-cell ${getCellHighlight(rowIdx, colIdx, cell)}`}
                          onMouseEnter={() => {
                            if (showRowActions) handleActionHover('row', rowIdx);
                            if (showColActions) handleActionHover('col', colIdx);
                          }}
                          onMouseLeave={handleActionLeave}
                        >
                          {editingCell?.rowIdx === rowIdx && editingCell?.colIdx === colIdx ? (
                            <input
                              type="text"
                              value={cell}
                              onChange={(e) => updateCell(rowIdx, colIdx, e.target.value)}
                              onBlur={() => setEditingCell(null)}
                              onKeyDown={(e) => {
                                if (e.key === 'Enter') setEditingCell(null);
                              }}
                              autoFocus
                              className="w-full bg-gray-700 px-1 py-0.5 outline-none"
                            />
                          ) : (
                            <div
                              className="min-h-[1.5rem] cursor-text hover:bg-gray-700/30 transition-colors rounded px-1"
                              onDoubleClick={() => setEditingCell({ rowIdx, colIdx })}
                              onClick={(e) => {
                                e.stopPropagation();
                                handleCellClick(rowIdx, colIdx, cell);
                              }}
                              title="Double-click to edit"
                            >
                              {variableMappings[cell] || studyMappings[cell] ? (
                                <span>
                                  <s className="text-gray-500">{cell}</s> → {variableMappings[cell] || studyMappings[cell]}
                                </span>
                              ) : (
                                cell || <span className="text-gray-500 italic">empty</span>
                              )}
                            </div>
                          )}

                          {/* Row action buttons - show on hover of first column cells */}
                          {showRowActions && hoveredAction?.type === 'row' && hoveredAction?.index === rowIdx && (
                            <div
                              className="absolute top-1 right-1 flex gap-1 z-10"
                              onMouseEnter={handleActionMouseEnter}
                              onMouseLeave={handleActionLeave}
                            >
                              <button
                                onClick={() => removeRow(rowIdx)}
                                className="px-2 py-0.5 bg-red-600/90 hover:bg-red-700 rounded text-xs text-white shadow-lg backdrop-blur-sm transition-all duration-200"
                                title="Remove row"
                              >
                                −
                              </button>
                              <button
                                onClick={() => addRow(rowIdx)}
                                className="px-2 py-0.5 bg-blue-600/90 hover:bg-blue-700 rounded text-xs text-white shadow-lg backdrop-blur-sm transition-all duration-200"
                                title="Add row below"
                              >
                                +
                              </button>
                            </div>
                          )}

                          {/* Column action buttons - show on hover of first row cells */}
                          {showColActions && hoveredAction?.type === 'col' && hoveredAction?.index === colIdx && (
                            <div
                              className="absolute top-1 right-1 flex gap-1 z-10"
                              onMouseEnter={handleActionMouseEnter}
                              onMouseLeave={handleActionLeave}
                            >
                              <button
                                onClick={() => removeColumn(colIdx)}
                                className="px-2 py-0.5 bg-red-600/90 hover:bg-red-700 rounded text-xs text-white shadow-lg backdrop-blur-sm transition-all duration-200"
                                title="Remove column"
                              >
                                −
                              </button>
                              <button
                                onClick={() => addColumn(colIdx)}
                                className="px-2 py-0.5 bg-blue-600/90 hover:bg-blue-700 rounded text-xs text-white shadow-lg backdrop-blur-sm transition-all duration-200"
                                title="Add column to the right"
                              >
                                +
                              </button>
                            </div>
                          )}
                        </td>
                      );
                    })}
                  </tr>
                ))}
              </tbody>
            </table>

            <div className="mt-4 p-3 bg-gray-700/50 rounded text-sm">
              <div className="font-semibold mb-2">Legend:</div>
              <div className="flex flex-wrap gap-4">
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 bg-green-900/40 border border-green-500 rounded"></div>
                  <span>Recognized</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 bg-red-900/40 border border-red-500 rounded"></div>
                  <span>Not Recognized (click to map)</span>
                </div>
              </div>
              <div className="mt-2 text-gray-400">
                Double-click any cell to edit • Click red cells to map to existing values • Hover over header row or first column to add/remove rows/columns
              </div>
            </div>

            {/* Mapping Modal - Appears above everything */}
            {dropdownOpen && (
              <div className="fixed inset-0 z-[9999] flex items-start justify-center pointer-events-none pt-20 px-4">
                {/* Modal content */}
                <div className="relative z-[10000] bg-gray-800 border-2 border-purple-500 rounded-xl shadow-2xl max-w-sm w-full overflow-hidden flex flex-col pointer-events-auto">
                  {/* Close button */}
                  <button
                    onClick={() => setDropdownOpen(null)}
                    className="absolute top-3 right-3 text-gray-400 hover:text-white transition-colors z-10"
                  >
                    <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                    </svg>
                  </button>

                  {/* Header - Fixed */}
                  <div className="p-4 pb-3 flex-shrink-0 border-b border-gray-700">
                    <h3 className="text-lg font-bold text-purple-400 mb-3 pr-8">
                      {dropdownOpen.type === 'variable' ? 'Map Variable' : 'Map Study ID'}
                    </h3>

                    <div className="mb-3 p-2 bg-gray-700 rounded-lg">
                      <div className="text-xs text-gray-400 mb-1">Current value:</div>
                      <div className="text-sm font-semibold text-white">{dropdownOpen.value}</div>
                    </div>

                    <div className="text-xs text-gray-300">
                      Select a {dropdownOpen.type === 'variable' ? 'variable label' : 'study ID'} to map to:
                    </div>
                  </div>

                  {/* Options list - Scrollable with max height */}
                  <div className="overflow-y-auto p-4 space-y-2" style={{ maxHeight: '200px' }}>
                    {dropdownOpen.type === 'variable' && suggestedLabels.map((label) => (
                      <button
                        key={label}
                        onClick={() => handleMapping(label)}
                        className="w-full text-left px-4 py-2 bg-gray-700 hover:bg-purple-600 rounded-lg transition-colors duration-200 text-gray-100"
                      >
                        {label}
                      </button>
                    ))}
                    {dropdownOpen.type === 'study' && studyIds.map((id) => (
                      <button
                        key={id}
                        onClick={() => handleMapping(id)}
                        className="w-full text-left px-4 py-2 bg-gray-700 hover:bg-purple-600 rounded-lg transition-colors duration-200 text-gray-100"
                      >
                        {id}
                      </button>
                    ))}
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      function App() {
        const [currentScreen, setCurrentScreen] = useState("welcome");
        const [groupType, setGroupType] = useState("intervention");
        const [studyIds, setStudyIds] = useState([]);
        const [selectedOption, setSelectedOption] = useState("baseline");
        const [baselineVariables, setBaselineVariables] = useState({});
        const [outcomesVariables, setOutcomesVariables] = useState({});
        const [inputValues, setInputValues] = useState({
          studyIdInput: "",
          variableLabel: "",
          variableType: "dichotomous",
          variableValue: {},
          selectedStudyId: "",
          variableArmType: "single",
          interventionName: "",
        });

        // New state for group names
        const [groupNames, setGroupNames] = useState({
          interventionName: "Intervention",
          comparisonName: "Comparison",
        });

        // New state for used interventions (for Network mode autocomplete)
        const [usedInterventions, setUsedInterventions] = useState([]);

        // Load data from uploaded backup
        const [uploadedData, setUploadedData] = useState(null);

        // ============================================
        // PROJECT MANAGEMENT STATES
        // ============================================
        const [currentProject, setCurrentProject] = useState(null);
        const [autoSaveEnabled, setAutoSaveEnabled] = useState(true);
        const [autoSaveStatus, setAutoSaveStatus] = useState('inactive'); // 'inactive', 'active', 'saving', 'saved', 'error'
        const [isProjectsModalOpen, setIsProjectsModalOpen] = useState(false);
        const [tempProjectName, setTempProjectName] = useState('');

        // Use useRef for timer to avoid re-renders
        const autoSaveTimer = useRef(null);

        // ============================================
        // THEME MANAGEMENT
        // ============================================
        const [isDarkMode, setIsDarkMode] = useState(() => {
          // Load theme preference from localStorage, default to false (light mode)
          const savedTheme = localStorage.getItem('theme');
          return savedTheme === 'dark';
        });

        // Apply theme to body on mount and when theme changes
        useEffect(() => {
          if (isDarkMode) {
            document.body.classList.add('dark-mode');
            localStorage.setItem('theme', 'dark');
          } else {
            document.body.classList.remove('dark-mode');
            localStorage.setItem('theme', 'light');
          }
        }, [isDarkMode]);

        const toggleTheme = () => {
          setIsDarkMode(!isDarkMode);
        };

        const handleBackupDownload = () => {
          // 1) Determine naming for the file
          let groupPart;
          if (groupType === "intervention") {
            groupPart = groupNames.interventionName;
          } else if (groupType === "intervention_comparison") {
            groupPart = `${groupNames.interventionName}_x_${groupNames.comparisonName}`;
          } else {
            groupPart = "Data";
          }

          // 2) Build the backup data object
          const backupData = {
            groupType,
            studyIds,
            baselineVariables,
            outcomesVariables,
            inputValues,
            groupNames,
            usedInterventions,
          };

          // (Optional) Also include Google Drive links from localStorage if needed
          const driveLinks =
            JSON.parse(localStorage.getItem("driveLinks")) || {};
          backupData.driveLinks = driveLinks;

          // 3) Save a copy in localStorage (so it persists even if the user doesn’t re-upload)
          try {
            localStorage.setItem(
              "allVariablesBackup",
              JSON.stringify(backupData)
            );
          } catch (err) {
            console.error("Error saving dataset backup to localStorage:", err);
          }

          // 4) Convert to JSON + trigger download
          const blob = new Blob([JSON.stringify(backupData)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;

          const timestamp = new Date();
          const formattedTimestamp = timestamp
            .toISOString()
            .slice(0, 19)
            .replace("T", "_")
            .replace(/:/g, "-");

          a.download = `dataset_backup_${groupPart}_${formattedTimestamp}.json`;
          a.click();
          URL.revokeObjectURL(url);

          // 5) (Optional) Open "Backup Files" links from Google Drive
          try {
            const storedData =
              JSON.parse(localStorage.getItem("driveLinks")) || {};
            const backupLinks = storedData["Backup Files"] || [];
            backupLinks.forEach((link) => {
              window.open(link, "_blank");
            });
          } catch (err) {
            console.error("Error opening Backup Files links:", err);
          }
        };

        // Auto-download backup on page unload - DISABLED (using localStorage project system instead)
        // useEffect(() => {
        //   const handleBeforeUnload = (e) => {
        //     handleBackupDownload();
        //     e.preventDefault();
        //     e.returnValue = "";
        //   };
        //   window.addEventListener("beforeunload", handleBeforeUnload);
        //   return () => {
        //     window.removeEventListener("beforeunload", handleBeforeUnload);
        //   };
        // }, [
        //   groupType,
        //   studyIds,
        //   baselineVariables,
        //   outcomesVariables,
        //   inputValues,
        //   groupNames,
        // ]);

        useEffect(() => {
          if (uploadedData) {
            setGroupType(uploadedData.groupType || "intervention");
            setStudyIds(uploadedData.studyIds || []);
            setBaselineVariables(uploadedData.baselineVariables || {});
            setOutcomesVariables(uploadedData.outcomesVariables || {});
            setInputValues((prevValues) => ({
              ...prevValues,
              ...uploadedData.inputValues,
            }));
            setGroupNames(
              uploadedData.groupNames || {
                interventionName: "Intervention",
                comparisonName: "Comparison",
              }
            );
            setCurrentScreen("variableInput");
          }
        }, [uploadedData]);

        // ============================================
        // PROJECT MANAGEMENT FUNCTIONS
        // ============================================

        /**
         * Creates a new empty project
         */
        const createNewProject = (projectName, initialGroupType = 'intervention') => {
          if (!projectName || projectName.trim() === '') {
            alert('Project name cannot be empty!');
            return null;
          }

          const projects = getAllProjects();
          const newProject = {
            id: generateProjectId(),
            name: projectName.trim(),
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            data: {
              groupType: initialGroupType,
              studyIds: [],
              baselineVariables: {},
              outcomesVariables: {},
              inputValues: {
                studyIdInput: "",
                variableLabel: "",
                variableType: "dichotomous",
                variableValue: {},
                selectedStudyId: "",
                variableArmType: "single",
                interventionName: "",
              },
              groupNames: {
                interventionName: "Intervention",
                comparisonName: "Comparison",
              },
              usedInterventions: [],
              driveLinks: {}
            }
          };

          projects.push(newProject);

          if (saveProjectsList(projects)) {
            console.log(`✅ Project "${projectName}" created successfully with groupType: ${initialGroupType}`);
            return newProject;
          }

          return null;
        };

        /**
         * Loads a specific project by ID
         */
        const loadProject = (projectId) => {
          const projects = getAllProjects();
          const project = projects.find(p => p.id === projectId);

          if (!project) {
            alert('Project not found!');
            return null;
          }

          // Set as current project
          setCurrentProject(project);

          // Load all data into states
          setGroupType(project.data.groupType || 'intervention');
          setStudyIds(project.data.studyIds || []);
          setBaselineVariables(project.data.baselineVariables || {});
          setOutcomesVariables(project.data.outcomesVariables || {});
          setInputValues(project.data.inputValues || {
            studyIdInput: "",
            variableLabel: "",
            variableType: "dichotomous",
            variableValue: {},
            selectedStudyId: "",
            variableArmType: "single",
            interventionName: "",
          });
          setGroupNames(project.data.groupNames || {
            interventionName: "Intervention",
            comparisonName: "Comparison",
          });
          setUsedInterventions(project.data.usedInterventions || []);

          // Restore driveLinks to localStorage
          if (project.data.driveLinks) {
            localStorage.setItem('driveLinks', JSON.stringify(project.data.driveLinks));
          }

          // Navigate to variableInput screen
          setCurrentScreen('variableInput');
          setAutoSaveStatus('active');

          console.log(`✅ Project "${project.name}" loaded!`);
          return project;
        };

        /**
         * Saves the current project to localStorage
         */
        const saveCurrentProject = () => {
          if (!currentProject) {
            console.warn('No project is currently loaded!');
            return false;
          }

          const projects = getAllProjects();
          const projectIndex = projects.findIndex(p => p.id === currentProject.id);

          if (projectIndex === -1) {
            console.error('Current project not found in projects list!');
            return false;
          }

          // Get current driveLinks from localStorage
          const driveLinks = JSON.parse(localStorage.getItem('driveLinks')) || {};

          // Update project data
          projects[projectIndex] = {
            ...projects[projectIndex],
            updatedAt: new Date().toISOString(),
            data: {
              groupType,
              studyIds,
              baselineVariables,
              outcomesVariables,
              inputValues,
              groupNames,
              usedInterventions,
              driveLinks
            }
          };

          if (saveProjectsList(projects)) {
            setCurrentProject(projects[projectIndex]);
            console.log('✅ Project updated successfully!');
            return true;
          }

          return false;
        };

        /**
         * Deletes a project permanently
         */
        const deleteProject = (projectId) => {
          const projects = getAllProjects();
          const project = projects.find(p => p.id === projectId);

          if (!project) {
            alert('Project not found!');
            return false;
          }

          const confirmDelete = confirm(
            `WARNING: Are you sure you want to delete the project "${project.name}"?\n\n` +
            `This action cannot be undone!`
          );

          if (!confirmDelete) {
            return false;
          }

          const filteredProjects = projects.filter(p => p.id !== projectId);

          if (saveProjectsList(filteredProjects)) {
            console.log(`✅ Project "${project.name}" deleted!`);

            // If deleted project was the current one, clear it
            if (currentProject && currentProject.id === projectId) {
              setCurrentProject(null);
              setAutoSaveStatus('inactive');
              setCurrentScreen('welcome');
            }

            return true;
          }

          return false;
        };

        /**
         * Exports a project to JSON file (old backup format for compatibility)
         */
        const exportProject = (projectId) => {
          try {
            console.log('🔍 Exporting project:', projectId);
            const projects = getAllProjects();
            console.log('📦 All projects:', projects);
            const project = projects.find(p => p.id === projectId);

            if (!project) {
              alert('Project not found!');
              console.error('❌ Project not found:', projectId);
              return;
            }

            console.log('✅ Found project:', project);

            // Export in OLD backup format for compatibility (with project name)
            const exportData = {
              projectName: project.name,
              groupType: project.data.groupType,
              studyIds: project.data.studyIds,
              baselineVariables: project.data.baselineVariables,
              outcomesVariables: project.data.outcomesVariables,
              inputValues: project.data.inputValues,
              groupNames: project.data.groupNames,
              driveLinks: project.data.driveLinks || {},
              usedInterventions: project.data.usedInterventions || []
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;

            // Use project name for file
            let groupPart;
            if (project.data.groupType === "intervention") {
              groupPart = project.data.groupNames?.interventionName || 'intervention';
            } else if (project.data.groupType === "intervention_comparison") {
              groupPart = `${project.data.groupNames?.interventionName || 'intervention'}_x_${project.data.groupNames?.comparisonName || 'comparison'}`;
            } else {
              groupPart = project.name.replace(/[^a-z0-9]/gi, '_');
            }

            const timestamp = new Date();
            const formattedTimestamp = timestamp
              .toISOString()
              .slice(0, 19)
              .replace("T", "_")
              .replace(/:/g, "-");

            link.download = `dataset_backup_${groupPart}_${formattedTimestamp}.json`;

            // Append to body, click, then remove
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            URL.revokeObjectURL(url);

            console.log(`✅ Project "${project.name}" exported successfully!`);
            alert(`Project "${project.name}" exported successfully!`);
          } catch (error) {
            console.error('❌ Error exporting project:', error);
            alert('Error exporting project: ' + error.message);
          }
        };

        /**
         * Imports a backup file (detects old format and creates project)
         */
        const importBackupAsProject = (backupData) => {
          // Check if it's old format (no project structure)
          const isOldFormat = !backupData.id && !backupData.name && backupData.groupType;

          if (isOldFormat) {
            // Old format - use projectName from backup or ask for one
            let projectName = backupData.projectName;

            if (!projectName) {
              projectName = prompt(
                'Enter a name for the imported project:',
                backupData.groupNames?.interventionName || 'Imported Project'
              );

              if (!projectName) {
                alert('Import cancelled - no project name provided.');
                return null;
              }
            }

            const projects = getAllProjects();
            const newProject = {
              id: generateProjectId(),
              name: projectName.trim(),
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
              data: {
                groupType: backupData.groupType || 'intervention',
                studyIds: backupData.studyIds || [],
                baselineVariables: backupData.baselineVariables || {},
                outcomesVariables: backupData.outcomesVariables || {},
                inputValues: backupData.inputValues || {},
                groupNames: backupData.groupNames || {
                  interventionName: "Intervention",
                  comparisonName: "Comparison",
                },
                usedInterventions: backupData.usedInterventions || [],
                driveLinks: backupData.driveLinks || {}
              }
            };

            projects.push(newProject);

            if (saveProjectsList(projects)) {
              alert(`Project "${projectName}" created from backup successfully!`);
              return newProject;
            }
          }

          return null;
        };

        /**
         * Auto-save with debounce
         */
        const triggerAutoSave = () => {
          if (!autoSaveEnabled || !currentProject) {
            return;
          }

          setAutoSaveStatus('saving');

          // Clear previous timer
          if (autoSaveTimer.current) {
            clearTimeout(autoSaveTimer.current);
          }

          // Set new timer (1 second debounce)
          autoSaveTimer.current = setTimeout(() => {
            if (saveCurrentProject()) {
              setAutoSaveStatus('saved');
              // After 2 seconds, change back to active
              setTimeout(() => {
                setAutoSaveStatus('active');
              }, 2000);
            } else {
              setAutoSaveStatus('error');
            }
          }, 1000);
        };

        /**
         * Toggle auto-save on/off
         */
        const toggleAutoSave = () => {
          const newState = !autoSaveEnabled;
          setAutoSaveEnabled(newState);
          setAutoSaveStatus(newState ? 'active' : 'inactive');

          if (!newState && autoSaveTimer.current) {
            clearTimeout(autoSaveTimer.current);
            autoSaveTimer.current = null;
          }
        };

        // ============================================
        // AUTO-ADJUST VARIABLE ARM TYPE BASED ON GROUP TYPE
        // ============================================
        useEffect(() => {
          if (groupType === "intervention_comparison" && inputValues.variableArmType === "single") {
            setInputValues(prev => ({
              ...prev,
              variableArmType: "double"
            }));
          } else if (groupType === "intervention" && inputValues.variableArmType === "double") {
            setInputValues(prev => ({
              ...prev,
              variableArmType: "single"
            }));
          }
        }, [groupType]);

        // ============================================
        // AUTO-SAVE TRIGGER ON DATA CHANGES
        // ============================================
        useEffect(() => {
          if (currentProject) {
            triggerAutoSave();
          }
        }, [
          groupType,
          studyIds,
          baselineVariables,
          outcomesVariables,
          inputValues,
          groupNames
        ]);

        // ============================================
        // LOAD LAST PROJECT ON MOUNT
        // ============================================
        useEffect(() => {
          const projects = getProjectsSortedByDate();
          if (projects.length > 0 && !currentProject) {
            // Auto-load most recent project
            // Comment this out if you don't want auto-load
            // loadProject(projects[0].id);
          }
        }, []);

        // ============================================
        // PROJECTS MANAGEMENT UI (VIA PROMPTS)
        // ============================================
        const showProjectsManagementPrompt = () => {
          const projects = getProjectsSortedByDate();

          if (projects.length === 0) {
            const createNew = confirm('No projects found.\n\nWould you like to create a new project?');
            if (createNew) {
              const projectName = prompt('Enter project name:', 'Data Extraction - ' + new Date().toLocaleDateString());
              if (projectName) {
                const newProject = createNewProject(projectName);
                if (newProject) {
                  alert('Project created successfully!\n\nClick OK to start working on it.');
                  loadProject(newProject.id);
                }
              }
            }
            return;
          }

          // Build list of projects
          let message = 'MY PROJECTS:\n\n';
          projects.forEach((project, index) => {
            const isActive = currentProject && currentProject.id === project.id;
            message += `${index + 1}. ${project.name}${isActive ? ' [ACTIVE]' : ''}\n`;
            message += `   Studies: ${project.data.studyIds?.length || 0}\n`;
            message += `   Updated: ${formatDate(project.updatedAt)}\n\n`;
          });

          message += '\nOPTIONS:\n';
          message += '• Enter number to LOAD a project\n';
          message += '• Type "new" to CREATE new project\n';
          message += '• Type "delete" to DELETE a project\n';
          message += '• Type "export" to EXPORT a project\n';
          message += '• Click Cancel to close';

          const choice = prompt(message);

          if (!choice) return;

          // Handle choice
          if (choice.toLowerCase() === 'new') {
            const projectName = prompt('Enter project name:', 'Data Extraction - ' + new Date().toLocaleDateString());
            if (projectName) {
              const newProject = createNewProject(projectName);
              if (newProject) {
                const loadNow = confirm('Project created!\n\nLoad it now?');
                if (loadNow) {
                  loadProject(newProject.id);
                } else {
                  showProjectsManagementPrompt();
                }
              }
            }
          } else if (choice.toLowerCase() === 'delete') {
            const deleteChoice = prompt('Enter project number to DELETE:\n\n' +
              projects.map((p, i) => `${i + 1}. ${p.name}`).join('\n'));
            const deleteIndex = parseInt(deleteChoice) - 1;
            if (deleteIndex >= 0 && deleteIndex < projects.length) {
              deleteProject(projects[deleteIndex].id);
              showProjectsManagementPrompt();
            }
          } else if (choice.toLowerCase() === 'export') {
            const exportChoice = prompt('Enter project number to EXPORT:\n\n' +
              projects.map((p, i) => `${i + 1}. ${p.name}`).join('\n'));
            const exportIndex = parseInt(exportChoice) - 1;
            if (exportIndex >= 0 && exportIndex < projects.length) {
              exportProject(projects[exportIndex].id);
              showProjectsManagementPrompt();
            }
          } else {
            const projectIndex = parseInt(choice) - 1;
            if (projectIndex >= 0 && projectIndex < projects.length) {
              loadProject(projects[projectIndex].id);
            } else {
              alert('Invalid choice!');
              showProjectsManagementPrompt();
            }
          }
        };

        return (
          <div className="min-h-screen">
            {/* Theme Toggle Button */}
            <button
              onClick={toggleTheme}
              className="theme-toggle"
              aria-label="Toggle theme"
              title={isDarkMode ? "Switch to Light Mode" : "Switch to Dark Mode"}
            >
              {isDarkMode ? (
                // Sun icon for dark mode (clicking will switch to light)
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <circle cx="12" cy="12" r="5"/>
                  <line x1="12" y1="1" x2="12" y2="3"/>
                  <line x1="12" y1="21" x2="12" y2="23"/>
                  <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                  <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                  <line x1="1" y1="12" x2="3" y2="12"/>
                  <line x1="21" y1="12" x2="23" y2="12"/>
                  <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                  <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                </svg>
              ) : (
                // Moon icon for light mode (clicking will switch to dark)
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                  <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                </svg>
              )}
            </button>

            {/* Fixed Navigation Bar */}
            {currentScreen !== "welcome" && (
              <div className="fixed top-0 left-0 right-0 z-50 bg-gray-900 border-b border-gray-700 shadow-lg">
                <div className="max-w-7xl mx-auto px-4 md:px-6 py-3 flex justify-end gap-3">
                  <button
                    onClick={() => setCurrentScreen("projectsManagement")}
                    className="bg-blue-600 hover:bg-blue-700 text-white text-sm font-semibold py-2 px-4 rounded transition duration-300"
                  >
                    My Projects
                  </button>
                </div>
              </div>
            )}

            <div className={`max-w-7xl mx-auto px-4 md:px-6 ${currentScreen !== "welcome" ? "pt-16" : ""}`}>
            {currentScreen === "welcome" && (
              <WelcomeScreen
                onManageProjects={() => setCurrentScreen("projectsManagement")}
              />
            )}
            {currentScreen === "projectsManagement" && (
              <ProjectsManagementScreen
                onBack={() => setCurrentScreen("welcome")}
                onCreateNew={() => setCurrentScreen("projectName")}
                onUpload={() => setCurrentScreen("uploadDataset")}
                onLoadProject={loadProject}
                onDeleteProject={deleteProject}
                onExportProject={exportProject}
                currentProject={currentProject}
              />
            )}
            {currentScreen === "projectName" && (
              <ProjectNameScreen
                onSubmit={(name) => {
                  setTempProjectName(name);
                  setCurrentScreen("groupSelection");
                }}
                onBack={() => setCurrentScreen("projectsManagement")}
              />
            )}
            {currentScreen === "groupSelection" && (
              <GroupSelectionScreen
                onSelectGroup={(type) => {
                  setGroupType(type);
                  const newProject = createNewProject(tempProjectName, type);
                  if (newProject) {
                    loadProject(newProject.id);
                    // Network mode skips GroupNaming screen
                    setCurrentScreen(type === "network" ? "studyIdInput" : "groupNaming");
                  }
                }}
              />
            )}
            {currentScreen === "groupNaming" && (
              <GroupNamingScreen
                groupType={groupType}
                onSubmit={(names) => {
                  setGroupNames(names);
                  setCurrentScreen("studyIdInput");
                }}
                onBack={() => setCurrentScreen("projectsManagement")}
              />
            )}
            {currentScreen === "uploadDataset" && (
              <UploadDatasetScreen
                onBack={() => setCurrentScreen("projectsManagement")}
                onUpload={(data) => {
                  const importedProject = importBackupAsProject(data);

                  if (importedProject) {
                    loadProject(importedProject.id);
                    setCurrentScreen("studyIdInput");
                  } else {
                    setUploadedData(data);
                  }
                }}
              />
            )}
            {currentScreen === "studyIdInput" && (
              <StudyIdInputScreen
                inputValues={inputValues}
                setInputValues={setInputValues}
                onSubmit={(ids) => {
                  setStudyIds(ids);
                  setCurrentScreen("variableInput");
                }}
                onBack={() => setCurrentScreen("groupNaming")}
                baselineVariables={baselineVariables}
                setBaselineVariables={setBaselineVariables}
                outcomesVariables={outcomesVariables}
                setOutcomesVariables={setOutcomesVariables}
                studyIds={studyIds}
                setStudyIds={setStudyIds}
              />
            )}

            {currentScreen === "variableInput" && (
              <VariableInputScreen
                studyIds={studyIds}
                baselineVariables={baselineVariables}
                setBaselineVariables={setBaselineVariables}
                outcomesVariables={outcomesVariables}
                setOutcomesVariables={setOutcomesVariables}
                groupType={groupType}
                groupNames={groupNames}
                selectedOption={selectedOption}
                setSelectedOption={setSelectedOption}
                onPreview={() => setCurrentScreen("preview")}
                onBack={() => setCurrentScreen("studyIdInput")}
                inputValues={inputValues}
                setInputValues={setInputValues}
                usedInterventions={usedInterventions}
                setUsedInterventions={setUsedInterventions}
              />
            )}
            {currentScreen === "preview" && (
              <PreviewScreen
                studyIds={studyIds}
                baselineVariables={baselineVariables}
                outcomesVariables={outcomesVariables}
                groupType={groupType}
                groupNames={groupNames}
                onBack={() => setCurrentScreen("variableInput")}
                onBackupDownload={handleBackupDownload}
              />
            )}
            </div>
          </div>
        );
      }

      // ============================================
      // PROJECT UI COMPONENTS - TEMPORARILY DISABLED DUE TO BABEL PARSING ISSUES
      // Use console and prompts for now
      // ============================================

      // WelcomeScreen Component - Initial screen with only My Projects button
      function WelcomeScreen({ onManageProjects }) {
        return (
          <div className="min-h-screen flex items-center justify-center relative overflow-hidden">
            <div className="w-full max-w-3xl mx-auto px-4 relative z-10">
              {/* Subtle background orbs using brand colors */}
              <div className="absolute top-1/4 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[60vw] h-[60vh] bg-gradient-to-br from-[#c15f3c]/10 to-[#b1ada1]/10 blur-3xl rounded-full opacity-20 pointer-events-none animate-pulse"></div>
              <div className="absolute top-1/3 right-1/4 w-[40vw] h-[40vh] bg-[#f4f3ee]/20 blur-3xl rounded-full opacity-15 pointer-events-none"></div>

              {/* Main content container */}
              <div className="text-center py-12">
                {/* Title */}
                <h1 className="welcome-title text-6xl md:text-7xl font-extrabold tracking-tight mb-6">
                  Data Extraction Tool
                </h1>

                {/* Subtitle */}
                <p className="welcome-subtitle text-xl md:text-2xl max-w-2xl mx-auto mb-14 leading-relaxed">
                  Organize and manage your scientific data extraction projects
                  <span className="welcome-subtext block text-base mt-2">with precision and efficiency</span>
                </p>
              </div>

              {/* CTA Button */}
              <div className="flex justify-center mb-8">
                <button
                  onClick={onManageProjects}
                  className="welcome-button group relative inline-flex items-center justify-center font-bold py-6 px-16 rounded-2xl text-white text-2xl transition-all duration-500 transform hover:scale-110 focus:outline-none focus:ring-4 overflow-hidden shadow-2xl"
                >
                  {/* Shimmer effect */}
                  <span className="absolute inset-0 w-full h-full">
                    <span className="absolute top-0 left-0 w-full h-full bg-gradient-to-r from-transparent via-white/30 to-transparent skew-x-12 translate-x-[-200%] group-hover:translate-x-[200%] transition-transform duration-1000"></span>
                  </span>

                  {/* Beautiful briefcase icon */}
                  <span className="relative mr-5 transform group-hover:scale-110 group-hover:rotate-6 transition-all duration-500" style={{ filter: 'drop-shadow(0 0 8px rgba(255, 255, 255, 0.5))' }}>
                    <svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
                      {/* Handle */}
                      <path d="M12 8h4a2 2 0 012 2v2h4v-2a2 2 0 012-2h4" stroke="white" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" opacity="0.9"/>

                      {/* Main body */}
                      <rect x="6" y="12" width="28" height="20" rx="3" stroke="white" strokeWidth="2.5" strokeLinejoin="round" fill="white" fillOpacity="0.2"/>

                      {/* Top line separator */}
                      <path d="M6 17h28" stroke="white" strokeWidth="2.5" strokeLinecap="round" opacity="0.8"/>

                      {/* Lock/clasp detail */}
                      <circle cx="20" cy="23" r="2.5" fill="white" opacity="0.9"/>
                      <path d="M20 25.5v3" stroke="white" strokeWidth="2" strokeLinecap="round" opacity="0.9"/>

                      {/* Corner details */}
                      <circle cx="11" cy="27" r="1" fill="white" opacity="0.6"/>
                      <circle cx="29" cy="27" r="1" fill="white" opacity="0.6"/>
                    </svg>
                  </span>

                  <span className="relative font-extrabold tracking-wider uppercase" style={{ letterSpacing: '0.1em', textShadow: '0 2px 10px rgba(0, 0, 0, 0.3)', color: '#ffffff' }}>
                    My Projects
                  </span>

                  {/* Arrow indicator with bounce */}
                  <span className="relative ml-5 transform group-hover:translate-x-2 transition-all duration-500 group-hover:animate-bounce">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M9 5l7 7-7 7" stroke="white" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"/>
                    </svg>
                  </span>
                </button>
              </div>

              {/* Acknowledgements section */}
              <div className="mt-20 text-center">
                <div className="welcome-ack-box inline-block backdrop-blur-sm px-8 py-4 rounded-xl">
                  <p className="welcome-ack-text text-sm leading-relaxed">
                    <strong>Acknowledgements:</strong> This app was developed by
                    <span> Marcos Antônio Dias Vilela</span>
                    <span className="block mt-1">
                      (ORCID:{" "}
                      <a href="https://orcid.org/0000-0001-9303-504X" target="_blank" className="welcome-ack-link transition-colors underline">
                        0000-0001-9303-504X
                      </a>
                      , PubMed: Vilela MAD) at FAMERP
                    </span>
                  </p>
                </div>
              </div>
            </div>

            <style jsx>{`
              /* Light mode styles (default) */
              .welcome-title {
                color: #c15f3c;
              }

              .welcome-subtitle {
                color: #000000;
              }

              .welcome-subtext {
                color: #374151;
              }

              .welcome-button {
                background-color: #c15f3c;
                box-shadow: 0 25px 50px -12px rgba(193, 95, 60, 0.5);
                color: #ffffff !important;
              }

              .welcome-button:hover {
                background-color: #a04d2f;
                box-shadow: 0 25px 50px -12px rgba(193, 95, 60, 0.8);
                color: #ffffff !important;
              }

              .welcome-button span {
                color: #ffffff !important;
              }

              .welcome-ack-box {
                background-color: #f4f3ee;
                border: 1px solid #b1ada1;
              }

              .welcome-ack-text {
                color: #000000;
              }

              .welcome-ack-link {
                color: #c15f3c;
                text-decoration-color: rgba(193, 95, 60, 0.3);
              }

              .welcome-ack-link:hover {
                color: #a04d2f;
                text-decoration-color: rgba(160, 77, 47, 1);
              }

              /* Dark mode styles */
              body.dark-mode .welcome-title {
                color: #5b9dd9;
              }

              body.dark-mode .welcome-subtitle {
                color: #e8e8e8;
              }

              body.dark-mode .welcome-subtext {
                color: #d1d1d1;
              }

              body.dark-mode .welcome-button {
                background-color: #5b9dd9;
                box-shadow: 0 25px 50px -12px rgba(91, 157, 217, 0.5);
                color: #ffffff;
              }

              body.dark-mode .welcome-button:hover {
                background-color: #6ba8e3;
                box-shadow: 0 25px 50px -12px rgba(107, 168, 227, 0.8);
                color: #ffffff;
              }

              body.dark-mode .welcome-button span {
                color: #ffffff !important;
              }

              body.dark-mode .welcome-ack-box {
                background-color: rgba(26, 26, 26, 0.8);
                border: 1px solid #5b9dd9;
              }

              body.dark-mode .welcome-ack-text {
                color: #e8e8e8;
              }

              body.dark-mode .welcome-ack-link {
                color: #5b9dd9;
                text-decoration-color: rgba(91, 157, 217, 0.3);
              }

              body.dark-mode .welcome-ack-link:hover {
                color: #6ba8e3;
                text-decoration-color: rgba(107, 168, 227, 1);
              }

              .bg-noise-pattern {
                background-image: url('data:image/svg+xml,%3Csvg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg"%3E%3Crect width="1" height="1" fill="%23222222"/%3E%3C/svg%3E');
                background-size: 200px 200px;
              }

              @keyframes gradient {
                0%, 100% {
                  background-size: 200% 200%;
                  background-position: 0% 50%;
                }
                50% {
                  background-size: 200% 200%;
                  background-position: 100% 50%;
                }
              }

              .animate-gradient {
                animation: gradient 8s ease infinite;
              }

              @keyframes gradientShift {
                0% {
                  background-position: 0% 50%;
                }
                50% {
                  background-position: 100% 50%;
                }
                100% {
                  background-position: 0% 50%;
                }
              }
            `}</style>
          </div>
        );
      }

      // ProjectNameScreen Component
      function ProjectNameScreen({ onSubmit, onBack }) {
        const [projectName, setProjectName] = useState('Data Extraction - ' + new Date().toLocaleDateString());

        const handleSubmit = (e) => {
          e.preventDefault();
          if (projectName.trim()) {
            onSubmit(projectName.trim());
          } else {
            alert('Please enter a project name!');
          }
        };

        return (
          <div className="min-h-screen flex items-center justify-center px-4">
            <div className="w-full max-w-md bg-gray-800 rounded-lg shadow-xl p-8 border border-gray-700">
              <h1 className="text-3xl font-bold text-center mb-6 bg-gradient-to-r from-green-400 to-blue-500 bg-clip-text text-transparent">
                New Project
              </h1>

              <form onSubmit={handleSubmit}>
                <div className="mb-6">
                  <label className="block text-gray-300 text-sm font-semibold mb-2">
                    Project Name
                  </label>
                  <input
                    type="text"
                    value={projectName}
                    onChange={(e) => setProjectName(e.target.value)}
                    className="w-full px-4 py-3 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent"
                    placeholder="Enter project name..."
                    autoFocus
                  />
                </div>

                <div className="flex gap-3">
                  <button
                    type="button"
                    onClick={onBack}
                    className="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-semibold py-3 px-6 rounded-lg transition duration-300"
                  >
                    Cancel
                  </button>
                  <button
                    type="submit"
                    className="flex-1 bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-300 transform hover:scale-105"
                  >
                    Continue
                  </button>
                </div>
              </form>
            </div>
          </div>
        );
      }

      // GroupSelectionScreen Component - for selecting study type after naming project
      function GroupSelectionScreen({ onSelectGroup }) {
        return (
          <div className="min-h-screen flex items-center justify-center">
            <div className="w-full max-w-2xl mx-auto px-4">
              {/* Soft spotlight behind the headline */}
              <div className="absolute top-1/4 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[50vw] h-[50vh] bg-white/5 blur-3xl rounded-full opacity-10 pointer-events-none"></div>

              {/* Noise texture overlay */}
              <div className="pointer-events-none absolute inset-0 bg-noise-pattern opacity-5"></div>

              <div className="text-center py-10">
                <h1 className="text-4xl md:text-5xl font-extrabold tracking-tight mb-4 bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-400">
                  Select Study Type
                </h1>
                <p className="text-gray-400 max-w-md mx-auto">
                  Choose the type of study design for your data extraction.
                </p>
              </div>

              {/* Glassmorphism panel */}
              <div className="bg-white/5 backdrop-blur-md rounded-xl border border-white/10 p-6 shadow-lg">
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                  {/* Intervention (Magnifying Glass) */}
                  <button
                    onClick={() => onSelectGroup("intervention")}
                    className="relative w-full inline-flex items-center justify-center font-medium py-3 px-6 rounded border border-blue-400 text-gray-100 transition-transform transform hover:scale-105 hover:border-blue-300 focus:outline-none focus:ring-2 focus:ring-blue-500
                         hover:before:content-[''] hover:before:absolute hover:before:bottom-0 hover:before:left-0 hover:before:h-[2px] hover:before:w-full hover:before:bg-blue-400 hover:before:animate-underlineGlow"
                  >
                    <span className="mr-2 text-blue-300">
                      {/* Minimal line icon (magnifying glass) */}
                      <svg
                        width="16"
                        height="16"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="1.5"
                        className="inline-block align-middle"
                      >
                        <circle
                          cx="7"
                          cy="7"
                          r="5"
                          strokeLinecap="round"
                          strokeLinejoin="round"
                        />
                        <line
                          x1="11"
                          y1="11"
                          x2="15"
                          y2="15"
                          strokeLinecap="round"
                          strokeLinejoin="round"
                        />
                      </svg>
                    </span>
                    Intervention
                  </button>

                  {/* Intervention & Comparison (Crossed Swords) */}
                  <button
                    onClick={() => onSelectGroup("intervention_comparison")}
                    className="relative w-full inline-flex items-center justify-center font-medium py-3 px-6 rounded border border-green-400 text-gray-100 transition-transform transform hover:scale-105 hover:border-green-300 focus:outline-none focus:ring-2 focus:ring-green-500
                         hover:before:content-[''] hover:before:absolute hover:before:bottom-0 hover:before:left-0 hover:before:h-[2px] hover:before:w-full hover:before:bg-green-400 hover:before:animate-underlineGlow"
                  >
                    <span
                      className="mr-2 text-green-300 font-serif text-lg leading-none"
                      style={{ fontFamily: '"Times New Roman", serif' }}
                    >
                      {/* Use the Crossed Swords unicode character */}⚔
                    </span>
                    Intervention & Comparison
                  </button>

                  {/* Network (Network Icon) */}
                  <button
                    onClick={() => onSelectGroup("network")}
                    className="relative w-full inline-flex items-center justify-center font-medium py-3 px-6 rounded border border-purple-400 text-gray-100 transition-transform transform hover:scale-105 hover:border-purple-300 focus:outline-none focus:ring-2 focus:ring-purple-500
                         hover:before:content-[''] hover:before:absolute hover:before:bottom-0 hover:before:left-0 hover:before:h-[2px] hover:before:w-full hover:before:bg-purple-400 hover:before:animate-underlineGlow"
                  >
                    <span
                      className="mr-2 text-purple-300 text-lg leading-none"
                    >
                      {/* Network icon */}🕸️
                    </span>
                    Network
                  </button>
                </div>
              </div>
            </div>

            <style jsx>{`
              .bg-noise-pattern {
                background-image: url('data:image/svg+xml,%3Csvg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg"%3E%3Crect width="1" height="1" fill="%23222222"/%3E%3C/svg%3E');
                background-size: 200px 200px;
              }
            `}</style>
          </div>
        );
      }

      // ProjectsManagementScreen Component
      function ProjectsManagementScreen({ onBack, onCreateNew, onUpload, onLoadProject, onDeleteProject, onExportProject, currentProject }) {
        const [projects, setProjects] = useState([]);
        const [refreshKey, setRefreshKey] = useState(0);

        useEffect(() => {
          setProjects(getProjectsSortedByDate());
        }, [refreshKey]);

        const handleDelete = (projectId, projectName) => {
          console.log('Attempting to delete project:', projectId, projectName);
          const result = onDeleteProject(projectId);
          console.log('Delete result:', result);
          if (result) {
            console.log('Refreshing project list...');
            setRefreshKey(prev => {
              console.log('RefreshKey updated from', prev, 'to', prev + 1);
              return prev + 1;
            });
          }
        };

        const handleExport = (projectId) => {
          if (onExportProject) {
            onExportProject(projectId);
          } else {
            console.error('onExportProject prop is not defined');
            alert('Export function is not available');
          }
        };

        const handleLoad = (projectId) => {
          onLoadProject(projectId);
        };

        return (
          <div className="space-y-6">
            <h1 className="text-3xl font-bold text-center bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">
              My Projects
            </h1>

            <div className="flex justify-center gap-4">
              <button
                onClick={onCreateNew}
                className="bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-300 transform hover:scale-105"
              >
                + Create New Project
              </button>
              <button
                onClick={onUpload}
                className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-300 transform hover:scale-105"
              >
                Upload Dataset
              </button>
            </div>

            {/* Projects List */}
            {projects.length === 0 ? (
              <div className="text-center py-12 bg-gray-800 rounded-lg border border-gray-700">
                <p className="text-xl text-gray-400 mb-4">No projects found</p>
                <p className="text-gray-500">Create your first project to get started!</p>
              </div>
            ) : (
              <div className="space-y-4">
                {projects.map((project) => (
                  <div
                    key={project.id}
                    className={`bg-gray-800 border rounded-lg p-6 transition duration-300 ${
                      currentProject && currentProject.id === project.id
                        ? 'border-blue-500 shadow-lg shadow-blue-500/20'
                        : 'border-gray-700 hover:border-gray-600'
                    }`}
                  >
                    <div className="flex justify-between items-start mb-4">
                      <div className="flex-1">
                        <h3 className="text-xl font-semibold text-white mb-2">
                          {project.name}
                          {currentProject && currentProject.id === project.id && (
                            <span className="ml-3 text-xs bg-blue-600 px-3 py-1 rounded-full">
                              ACTIVE
                            </span>
                          )}
                        </h3>
                        <div className="text-sm text-gray-400 space-y-1">
                          <p>
                            <span className="font-semibold text-gray-300">Studies:</span>{' '}
                            {project.data.studyIds?.length || 0}
                          </p>
                          <p>
                            <span className="font-semibold text-gray-300">Created:</span>{' '}
                            {formatDate(project.createdAt)}
                          </p>
                          <p>
                            <span className="font-semibold text-gray-300">Updated:</span>{' '}
                            {formatDate(project.updatedAt)}
                          </p>
                        </div>
                      </div>
                    </div>

                    <div className="flex gap-3 flex-wrap">
                      <button
                        onClick={() => handleLoad(project.id)}
                        className="flex-1 min-w-[120px] bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded transition duration-300"
                      >
                        Open
                      </button>
                      <button
                        onClick={() => handleExport(project.id)}
                        className="flex-1 min-w-[120px] bg-orange-600 hover:bg-orange-700 text-white font-semibold py-2 px-4 rounded transition duration-300"
                      >
                        Export Backup
                      </button>
                      <button
                        onClick={() => handleDelete(project.id, project.name)}
                        className="flex-1 min-w-[120px] bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded transition duration-300"
                      >
                        Delete
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            )}

            {/* Back Button */}
            <div className="flex justify-center mt-8">
              <button
                onClick={onBack}
                className="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
              >
                Back to Home
              </button>
            </div>
          </div>
        );
      }

      // GroupNamingScreen Component
      function GroupNamingScreen({ groupType, onSubmit, onBack }) {
        const [interventionName, setInterventionName] =
          useState("Intervention");
        const [comparisonName, setComparisonName] = useState("Comparison");

        const handleSubmit = () => {
          if (!interventionName.trim()) {
            alert("Please enter a name for the Intervention group.");
            return;
          }
          if (
            groupType === "intervention_comparison" &&
            !comparisonName.trim()
          ) {
            alert("Please enter a name for the Comparison group.");
            return;
          }
          onSubmit({
            interventionName: interventionName.trim(),
            comparisonName:
              groupType === "intervention_comparison"
                ? comparisonName.trim()
                : "",
          });
        };

        return (
          <div className="space-y-6">
            <h1 className="text-2xl font-bold">Name Your Groups</h1>
            <div className="space-y-4">
              <div>
                <label className="block font-semibold mb-2">
                  Intervention Group Name
                </label>
                <input
                  type="text"
                  value={interventionName}
                  onChange={(e) => setInterventionName(e.target.value)}
                  className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="Enter Intervention Group Name"
                />
              </div>
              {groupType === "intervention_comparison" && (
                <div>
                  <label className="block font-semibold mb-2">
                    Comparison Group Name
                  </label>
                  <input
                    type="text"
                    value={comparisonName}
                    onChange={(e) => setComparisonName(e.target.value)}
                    className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="Enter Comparison Group Name"
                  />
                </div>
              )}
            </div>
            <div className="flex flex-col md:flex-row justify-between mt-4 space-y-4 md:space-y-0">
              <button
                onClick={onBack}
                className="w-full md:w-auto bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
              >
                <i className="fas fa-arrow-left mr-2"></i> Back
              </button>
              <button
                onClick={handleSubmit}
                className="w-full md:w-auto bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
              >
                Next <i className="fas fa-arrow-right ml-2"></i>
              </button>
            </div>
          </div>
        );
      }

      // UploadDatasetScreen Component
      function UploadDatasetScreen({ onBack, onUpload }) {
        const [dragOver, setDragOver] = useState(false);

        const handleFileUpload = (file) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = JSON.parse(e.target.result);

              // NEW CODE: Restore the driveLinks from the backup file if present
              if (data.driveLinks) {
                localStorage.setItem(
                  "driveLinks",
                  JSON.stringify(data.driveLinks)
                );
              }

              // Then proceed with your existing onUpload
              onUpload(data);
            } catch (error) {
              alert("Invalid backup file.");
            }
          };
          reader.readAsText(file);
        };

        const handleDrop = (e) => {
          e.preventDefault();
          setDragOver(false);
          if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            const file = e.dataTransfer.files[0];
            handleFileUpload(file);
            e.dataTransfer.clearData();
          }
        };

        const handleDragOver = (e) => {
          e.preventDefault();
          setDragOver(true);
        };

        const handleDragLeave = (e) => {
          e.preventDefault();
          setDragOver(false);
        };

        const handleFileSelect = (e) => {
          if (e.target.files && e.target.files.length > 0) {
            const file = e.target.files[0];
            handleFileUpload(file);
          }
        };

        return (
          <div className="space-y-6">
            <h1 className="text-2xl font-bold">Upload Dataset Backup</h1>
            <div
              className={`border-4 ${
                dragOver ? "border-blue-500" : "border-gray-700"
              } border-dashed rounded-lg p-6 text-center cursor-pointer`}
              onDrop={handleDrop}
              onDragOver={handleDragOver}
              onDragLeave={handleDragLeave}
              onClick={() => document.getElementById("fileInput").click()}
            >
              <input
                type="file"
                id="fileInput"
                accept=".json"
                style={{ display: "none" }}
                onChange={handleFileSelect}
              />
              <p className="text-xl">
                {dragOver
                  ? "Drop the file here..."
                  : "Drag and drop a backup file here, or click to select a file"}
              </p>
            </div>
            <div className="flex justify-between mt-4">
              <button
                onClick={onBack}
                className="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
              >
                <i className="fas fa-arrow-left mr-2"></i> Back
              </button>
            </div>
          </div>
        );
      }

      // StudyIdInputScreen Component
      function StudyIdInputScreen({
        inputValues,
        setInputValues,
        onSubmit,
        onBack,
        baselineVariables,
        setBaselineVariables,
        outcomesVariables,
        setOutcomesVariables,
        studyIds,
        setStudyIds,
      }) {
        const [localStudyIds, setLocalStudyIds] = useState(studyIds);
        const [mode, setMode] = useState("paste"); // 'paste' or 'edit'
        const [studyIdFormatOption, setStudyIdFormatOption] =
          useState("Surname, Year");

        useEffect(() => {
          if (mode === "paste") {
            setInputValues((prevValues) => ({
              ...prevValues,
              studyIdInput: localStudyIds.join("\n"),
            }));
          } else {
            setLocalStudyIds(
              inputValues.studyIdInput
                .split("\n")
                .map((id) => id.trim())
                .filter((id) => id !== "")
            );
          }
        }, [mode]);

        const handleAddStudyId = () => {
          const newStudyId = `New Study ${localStudyIds.length + 1}`;
          const updatedStudyIds = [...localStudyIds, newStudyId];
          setLocalStudyIds(updatedStudyIds);

          // Update global studyIds immediately
          setStudyIds(updatedStudyIds);

          // Initialize empty variables for the new study
          setBaselineVariables(prev => ({ ...prev, [newStudyId]: [] }));
          setOutcomesVariables(prev => ({ ...prev, [newStudyId]: [] }));

          // Update inputValues
          setInputValues(prev => ({
            ...prev,
            studyIdInput: updatedStudyIds.join("\n")
          }));
        };

        const handleStudyIdChange = (index, value) => {
          const oldStudyId = localStudyIds[index];
          const updatedStudyIds = [...localStudyIds];
          updatedStudyIds[index] = value;
          setLocalStudyIds(updatedStudyIds);

          // Update global studyIds immediately
          setStudyIds(updatedStudyIds);

          // Rename the study in variables (move data from old ID to new ID)
          if (oldStudyId !== value && oldStudyId) {
            const updatedBaselineVars = { ...baselineVariables };
            const updatedOutcomesVars = { ...outcomesVariables };

            // Transfer data to new ID
            if (updatedBaselineVars[oldStudyId]) {
              updatedBaselineVars[value] = updatedBaselineVars[oldStudyId];
              delete updatedBaselineVars[oldStudyId];
            }
            if (updatedOutcomesVars[oldStudyId]) {
              updatedOutcomesVars[value] = updatedOutcomesVars[oldStudyId];
              delete updatedOutcomesVars[oldStudyId];
            }

            setBaselineVariables(updatedBaselineVars);
            setOutcomesVariables(updatedOutcomesVars);

            // Update selected study if it was the renamed one
            if (inputValues.selectedStudyId === oldStudyId) {
              setInputValues(prev => ({
                ...prev,
                selectedStudyId: value,
                studyIdInput: updatedStudyIds.join("\n")
              }));
            } else {
              setInputValues(prev => ({
                ...prev,
                studyIdInput: updatedStudyIds.join("\n")
              }));
            }
          }
        };

        const handleRemoveStudyId = (index) => {
          const studyIdToRemove = localStudyIds[index];
          const updatedStudyIds = [...localStudyIds];
          updatedStudyIds.splice(index, 1);
          setLocalStudyIds(updatedStudyIds);

          // Remove all data associated with this specific study
          const updatedBaselineVariables = { ...baselineVariables };
          const updatedOutcomesVariables = { ...outcomesVariables };

          // Delete the study's data by its ID (not by index!)
          delete updatedBaselineVariables[studyIdToRemove];
          delete updatedOutcomesVariables[studyIdToRemove];

          setBaselineVariables(updatedBaselineVariables);
          setOutcomesVariables(updatedOutcomesVariables);

          // Update studyIds immediately
          setStudyIds(updatedStudyIds);

          // If the removed study was selected, switch to the first remaining study
          if (inputValues.selectedStudyId === studyIdToRemove && updatedStudyIds.length > 0) {
            setInputValues(prev => ({
              ...prev,
              selectedStudyId: updatedStudyIds[0],
              studyIdInput: updatedStudyIds.join("\n")
            }));
          } else {
            setInputValues(prev => ({
              ...prev,
              studyIdInput: updatedStudyIds.join("\n")
            }));
          }
        };

        const handleSubmit = () => {
          let trimmedIds = [];
          if (mode === "paste") {
            trimmedIds = inputValues.studyIdInput
              .split("\n")
              .map((id) => id.trim())
              .filter((id) => id !== "");
          } else {
            trimmedIds = localStudyIds
              .map((id) => id.trim())
              .filter((id) => id !== "");
          }

          if (trimmedIds.length > 0) {
            // Check if we're in management mode (already have data)
            const hasExistingData = Object.keys(baselineVariables).length > 0 || Object.keys(outcomesVariables).length > 0;

            if (hasExistingData) {
              // MANAGEMENT MODE: Studies already modified via handleAddStudyId/handleRemoveStudyId/handleStudyIdChange
              // Just update the final state and proceed - NO REMAPPING!
              setStudyIds(trimmedIds);
              setInputValues((prevValues) => ({
                ...prevValues,
                studyIdInput: trimmedIds.join("\n"),
                selectedStudyId: trimmedIds.includes(prevValues.selectedStudyId)
                  ? prevValues.selectedStudyId
                  : trimmedIds[0],
              }));
            } else {
              // INITIAL MODE: First time entering studies, need to map by position
              const oldIds = studyIds;
              const updatedBaselineVariables = {};
              const updatedOutcomesVariables = {};

              // Create a mapping of old IDs to new IDs based on their positions
              const idMapping = {};
              oldIds.forEach((oldId, index) => {
                const newId = trimmedIds[index];
                if (newId && oldId !== newId) {
                  idMapping[oldId] = newId;
                } else if (newId === oldId) {
                  idMapping[oldId] = oldId;
                }
              });

              // Transfer variables based on idMapping
              Object.keys(baselineVariables).forEach((oldId) => {
                const newId = idMapping[oldId];
                if (newId) {
                  updatedBaselineVariables[newId] = baselineVariables[oldId];
                }
              });

              Object.keys(outcomesVariables).forEach((oldId) => {
                const newId = idMapping[oldId];
                if (newId) {
                  updatedOutcomesVariables[newId] = outcomesVariables[oldId];
                }
              });

              setBaselineVariables(updatedBaselineVariables);
              setOutcomesVariables(updatedOutcomesVariables);
              setStudyIds(trimmedIds);
              setInputValues((prevValues) => ({
                ...prevValues,
                studyIdInput: trimmedIds.join("\n"),
                selectedStudyId: trimmedIds.includes(prevValues.selectedStudyId)
                  ? prevValues.selectedStudyId
                  : trimmedIds[0],
              }));
            }

            onSubmit(trimmedIds);
          } else {
            alert("Please enter at least one study ID.");
          }
        };

        const switchMode = () => {
          setMode(mode === "paste" ? "edit" : "paste");
        };

        const handleConvertToStudyIds = () => {
          // 1) Split the entire textarea content into lines.
          const lines = inputValues.studyIdInput.split("\n");
          const convertedIds = [];

          for (const originalLine of lines) {
            const line = originalLine.trim();
            // Skip empty lines
            if (!line) continue;

            // Process the line to build a single "Study ID"
            const newStudyId = processInputLine(line, studyIdFormatOption);
            // If processInputLine returned a non-empty ID, add it:
            if (newStudyId) {
              convertedIds.push(newStudyId);
            }
          }

          // Update the textarea with our newly converted IDs
          setInputValues({
            ...inputValues,
            studyIdInput: convertedIds.join("\n"),
          });
        };

        const processInputLine = (line, formatOption) => {
          /**
           * 1) Splits the line into columns (tab or 2+ spaces).
           * 2) Skips lines that look like "Author Year", "Authors Date", etc. (header lines).
           * 3) Detects a 4-digit year (19xx or 20xx) anywhere in the line.
           * 4) Splits authors on "and" or ";" to handle multiple authors.
           * 5) The first author is used to form the "baseName," appending "et al." if multiple authors exist.
           * 6) If there's a comma in the first author, treat as "Surname, GivenName."
           *    Otherwise treat it as "GivenName Surname."
           * 7) SPECIAL CASE for 'Surname, Year': if the parsed surname is an abbreviation (like "A." or "G."),
           *    we return "GivenName Surname, Year" instead of "Surname, Year."
           */

          // Split on tab or 2+ spaces and trim each piece
          const columns = line.split(/\t| {2,}/).map((col) => col.trim());
          if (columns.length < 2) {
            // Not enough columns => just skip
            return "";
          }

          // Convert columns to lowercase for easier comparisons
          const col0Lower = columns[0].toLowerCase();
          const col1Lower = columns[1].toLowerCase();

          // A set of keywords we consider "header-like"
          const headerKeywords = new Set(["year", "date", "author", "authors"]);

          // Skip if BOTH columns are among the header keywords (e.g. "authors year")
          if (headerKeywords.has(col0Lower) && headerKeywords.has(col1Lower)) {
            return "";
          }

          // Find a 4-digit year (19xx or 20xx) anywhere in the line
          let yearPart = "";
          const yearMatch = line.match(/\b(19|20)\d{2}\b/);
          if (yearMatch) {
            yearPart = yearMatch[0];
          }

          // Identify which column is authors vs. year (if one is exactly a 4-digit year, the other is authors)
          let authorsRaw = "";
          if (/^\d{4}$/.test(columns[0])) {
            // Column0 is the year, so Column1 is the authors
            authorsRaw = columns[1];
          } else if (/^\d{4}$/.test(columns[1])) {
            // Column1 is the year, so Column0 is the authors
            authorsRaw = columns[0];
          } else {
            // If neither column is purely a year, default to using the second column as authors
            // or whichever doesn't contain the found year
            if (yearPart && columns[1].includes(yearPart)) {
              authorsRaw = columns[0];
            } else {
              authorsRaw = columns[1];
            }
          }

          // Split authors on "and" or ";" to capture multiple authors
          const authorsList = authorsRaw
            .split(/\s+and\s+|;/)
            .map((a) => a.trim())
            .filter(Boolean);

          if (authorsList.length === 0) {
            // Couldn’t parse any author => skip
            return "";
          }

          // Focus on the first author
          const firstAuthor = authorsList[0];
          const hasMultipleAuthors = authorsList.length > 1;

          // Distinguish "Surname, GivenName" vs. "GivenName Surname"
          let surname = "";
          let givenName = "";
          if (firstAuthor.includes(",")) {
            // e.g. "Mantziaris, G."
            const parts = firstAuthor.split(",");
            surname = parts[0].trim();
            givenName = parts.slice(1).join(",").trim();
          } else {
            // e.g. "Pikis S"
            const nameParts = firstAuthor.split(" ").filter(Boolean);
            if (nameParts.length >= 2) {
              surname = nameParts[nameParts.length - 1];
              givenName = nameParts.slice(0, -1).join(" ");
            } else {
              // Single token => treat entire token as the surname
              surname = firstAuthor;
            }
          }

          // Helper to detect a "too short" or "abbreviated" surname (e.g. "A.", "G.")
          const isAbbreviatedSurname = (str) => {
            // Remove spaces to handle e.g. "A. B." (though typically we wouldn't see that as a 'surname')
            const cleaned = str.replace(/\s+/g, "");
            // Matches 1 or 2 letters, each optionally followed by a period => e.g. "A", "A.", "AB.", "A.B."
            return /^[A-Za-z](\.?[A-Za-z]\.?)?$/.test(cleaned);
          };

          // Build our "baseName" depending on the chosen format
          switch (formatOption) {
            case "Name Surname et al., Year": {
              const fullName = (givenName + " " + surname).trim();
              const baseName = hasMultipleAuthors
                ? `${fullName} et al.`
                : fullName;
              if (yearPart && formatOption !== "Surname, Year") {
                return `${baseName}, ${yearPart}`;
              }
              return baseName;
            }

            case "Surname, Name et al., Year": {
              const fullName = surname
                ? surname + (givenName ? ", " + givenName : "")
                : givenName;
              const baseName = hasMultipleAuthors
                ? `${fullName} et al.`
                : fullName;
              if (yearPart && formatOption !== "Surname, Year") {
                return `${baseName}, ${yearPart}`;
              }
              return baseName;
            }

            case "Surname, Year": {
              // SPECIAL CASE: If "surname" is too short or looks like an abbreviation,
              // use "GivenName Surname" instead of just "Surname".
              if (isAbbreviatedSurname(surname) && givenName) {
                // e.g. "John A." => "John A., 2023"
                const combined = `${givenName} ${surname}`.trim();
                if (yearPart) {
                  return `${combined}, ${yearPart}`;
                } else {
                  return combined;
                }
              } else {
                // Normal scenario: "Smith, 2023" or "Smith"
                if (yearPart) {
                  return `${surname}, ${yearPart}`;
                } else {
                  return surname;
                }
              }
            }

            default: {
              // Default to "Surname, Name et al., Year"
              const fullName = surname
                ? surname + (givenName ? ", " + givenName : "")
                : givenName;
              const baseName = hasMultipleAuthors
                ? `${fullName} et al.`
                : fullName;
              if (yearPart) {
                return `${baseName}, ${yearPart}`;
              }
              return baseName;
            }
          }
        };

        // Check if we already have studies (user has been to extraction screen)
        const hasExistingStudies = studyIds.length > 0 && (Object.keys(baselineVariables).length > 0 || Object.keys(outcomesVariables).length > 0);

        return (
          <div className="space-y-6">
            <h1 className="text-2xl font-bold">
              {hasExistingStudies ? "Manage Study IDs" : "Enter Study IDs"}
            </h1>

            {hasExistingStudies ? (
              // Study Manager Mode (after data has been entered)
              <div className="space-y-4">
                <p className="text-gray-400">
                  Manage your studies below. Removing a study will delete all its associated data.
                </p>

                <div className="space-y-3">
                  {localStudyIds.map((id, index) => (
                    <div key={index} className="flex items-center gap-3 bg-gray-800 p-4 rounded-lg border border-gray-700 hover:border-gray-600 transition">
                      <div className="flex-grow flex items-center gap-3">
                        <svg className="w-5 h-5 text-blue-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                        </svg>
                        <div className="flex-grow">
                          <input
                            type="text"
                            value={id}
                            onChange={(e) => handleStudyIdChange(index, e.target.value)}
                            className="w-full bg-transparent border-0 border-b-2 border-transparent hover:border-gray-600 focus:border-blue-500 focus:outline-none font-semibold text-lg px-1 py-0 transition"
                            placeholder="Study ID"
                          />
                          <div className="text-sm text-gray-400 mt-1 px-1">
                            {(baselineVariables[id]?.length || 0) + (outcomesVariables[id]?.length || 0)} variables
                          </div>
                        </div>
                      </div>
                      <button
                        onClick={() => {
                          if (confirm(`Are you sure you want to delete "${id}" and all its data?`)) {
                            handleRemoveStudyId(index);
                          }
                        }}
                        className="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-300 flex items-center gap-2 flex-shrink-0"
                      >
                        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                        </svg>
                        Delete
                      </button>
                    </div>
                  ))}
                </div>

                <button
                  onClick={handleAddStudyId}
                  className="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-4 rounded-lg transition duration-300 flex items-center justify-center gap-2"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                  </svg>
                  Add New Study
                </button>
              </div>
            ) : (
              // Initial Entry Mode
              <div>
                <div className="flex justify-between items-center mb-4">
                  <p className="text-gray-400">
                    {mode === "paste"
                      ? "Enter your data below."
                      : "Edit your study IDs below."}
                  </p>
                  <button
                    onClick={switchMode}
                    className="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
                  >
                    Switch to {mode === "paste" ? "Edit Mode" : "Paste Mode"}
                  </button>
                </div>

            {mode === "paste" ? (
              <div>
                <textarea
                  value={inputValues.studyIdInput}
                  onChange={(e) =>
                    setInputValues({
                      ...inputValues,
                      studyIdInput: e.target.value,
                    })
                  }
                  rows="8"
                  className="w-full p-4 bg-gray-800 border border-gray-700 rounded-lg text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="Paste your data here..."
                ></textarea>
                <div className="mt-4 flex items-center">
                  <label className="mr-2 font-semibold">Study ID Format:</label>
                  <select
                    value={studyIdFormatOption}
                    onChange={(e) => setStudyIdFormatOption(e.target.value)}
                    className="p-2 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    <option value="Surname, Year">Surname, Year</option>
                    <option value="Name Surname et al., Year">
                      Name Surname et al., Year
                    </option>
                    <option value="Surname, Name et al., Year">
                      Surname, Name et al., Year
                    </option>
                  </select>
                  <button
                    onClick={handleConvertToStudyIds}
                    className="ml-4 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
                  >
                    Convert to Study IDs
                  </button>
                </div>
              </div>
            ) : (
              <div className="space-y-4">
                {localStudyIds.map((id, index) => (
                  <div key={index} className="flex items-center space-x-2">
                    <input
                      type="text"
                      value={id}
                      onChange={(e) =>
                        handleStudyIdChange(index, e.target.value)
                      }
                      className="flex-grow p-2 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                      placeholder={`Study ID ${index + 1}`}
                    />
                    <button
                      onClick={() => handleRemoveStudyId(index)}
                      className="text-red-500 hover:text-red-700"
                    >
                      <i className="fas fa-trash-alt"></i>
                    </button>
                  </div>
                ))}
                <button
                  onClick={handleAddStudyId}
                  className="mt-2 bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
                >
                  <i className="fas fa-plus mr-2"></i> Add Study ID
                </button>
              </div>
              )}
              </div>
            )}

            <div className="flex flex-col md:flex-row justify-between mt-4 space-y-4 md:space-y-0">
              <button
                onClick={onBack}
                className="w-full md:w-auto bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
              >
                <i className="fas fa-arrow-left mr-2"></i> Back
              </button>
              <button
                onClick={handleSubmit}
                className="w-full md:w-auto bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
              >
                Next <i className="fas fa-arrow-right ml-2"></i>
              </button>
            </div>
          </div>
        );
      }
      function CalculadoraEstimativas({
        groupType,
        baselineVariables,
        outcomesVariables,
        inputValues,
        setInputValues,
        selectedStudyId
      }) {
        const [metodo, setMetodo] = useState("Cenario1");
        const [inputs, setInputs] = useState({});
        const [resultado, setResultado] = useState({ meanOur: 0, sdOur: 0 });
        const [historico, setHistorico] = useState([]);
        const [isModalOpen, setIsModalOpen] = useState(false);
        const [isFormattingModalOpen, setIsFormattingModalOpen] =
          useState(false);
        const [isRevManModalOpen, setIsRevManModalOpen] = useState(false);
        const [mean, setMean] = useState("");
        const [sd, setSd] = useState("");
        const [formattedResult, setFormattedResult] = useState("");
        const [referenciaCopiada, setReferenciaCopiada] = useState(false);
        const [intervencao, setIntervencao] = useState([""]);
        const [controle, setControle] = useState([""]);
        const [planilhaOrganizada, setPlanilhaOrganizada] = useState(null);
        const [intervencaoTotal, setIntervencaoTotal] = useState([]);
        const [controleTotal, setControleTotal] = useState([]);
        const [autores, setAutores] = useState([""]);
        const [botaoCopiado, setBotaoCopiado] = useState(false);
        const [resultadoCopiado, setResultadoCopiado] = useState(false);
        const [targetGroup, setTargetGroup] = useState("intervention"); // "intervention" or "comparison"

        // Auto-fill population size when calculator opens or targetGroup changes
        useEffect(() => {
          let popSize = "";

          // First, check if the current inputValues is a population_size type
          if (inputValues && inputValues.variableType === "population_size" && inputValues.variableValue) {
            if (groupType === "intervention_comparison") {
              if (targetGroup === "intervention" && inputValues.variableValue.interventionPop) {
                popSize = inputValues.variableValue.interventionPop;
              } else if (targetGroup === "comparison" && inputValues.variableValue.comparisonPop) {
                popSize = inputValues.variableValue.comparisonPop;
              }
            } else {
              if (inputValues.variableValue.population) {
                popSize = inputValues.variableValue.population;
              }
            }
          }

          // If not found in current input, search in saved variables FOR THE SELECTED STUDY
          if (!popSize && selectedStudyId) {
            // Get variables only from the selected study
            const baselineVarsForStudy = baselineVariables?.[selectedStudyId] || [];
            const outcomesVarsForStudy = outcomesVariables?.[selectedStudyId] || [];
            const allVars = [...baselineVarsForStudy, ...outcomesVarsForStudy];

            const popVar = allVars.find((v) => v.type === "population_size");

            if (popVar && popVar.value) {
              if (groupType === "intervention_comparison") {
                if (targetGroup === "intervention" && popVar.value.interventionPop) {
                  popSize = popVar.value.interventionPop;
                } else if (targetGroup === "comparison" && popVar.value.comparisonPop) {
                  popSize = popVar.value.comparisonPop;
                }
              } else {
                if (popVar.value.population) {
                  popSize = popVar.value.population;
                }
              }
            }
          }

          if (popSize) {
            setInputs(prev => ({ ...prev, n: popSize }));
          }
        }, [targetGroup, baselineVariables, outcomesVariables, groupType, inputValues, selectedStudyId]);

        const handleInputChange = (e) => {
          const { name, value } = e.target;
          setInputs({ ...inputs, [name]: value });
        };

        const handlePaste = (e) => {
          const paste = e.clipboardData.getData("text").trim();

          // Regex to match the format of "median min max" (e.g., "20 10 30")
          const regex = /(\d+\.?\d*)[^0-9]*(\d+\.?\d*)[^0-9]*(\d+\.?\d*)/;
          const match = paste.match(regex);

          // If the pattern matches (i.e., three valid numbers)
          if (match) {
            const [_, median, min, max] = match.map(Number);

            // Handle the logic based on the selected 'metodo'
            if (metodo === "Cenario1") {
              setInputs({
                ...inputs,
                min: String(min),
                median: String(median),
                max: String(max),
              });
            } else if (metodo === "Cenario3") {
              setInputs({
                ...inputs,
                q1: String(min),
                median: String(median),
                q3: String(max),
              });
            }
            e.preventDefault(); // Prevent default paste action if match is found
          } else {
            // Handle pasting a single value and updating only the "min" field
            const singleValueRegex = /^(\d+\.?\d*)$/; // Regex to match a single numeric value
            const singleValueMatch = paste.match(singleValueRegex);

            if (singleValueMatch) {
              const value = singleValueMatch[1];

              // Check if we're pasting into the "min" field and update it
              if (e.target.name === "min") {
                setInputs({
                  ...inputs,
                  min: value, // Only update "min" field with the pasted value
                });
              }

              // Check if we're pasting into the "median" field and update it
              if (e.target.name === "median") {
                setInputs({
                  ...inputs,
                  median: value, // Only update "median" field with the pasted value
                });
              }

              // Check if we're pasting into the "max" field and update it
              if (e.target.name === "max") {
                setInputs({
                  ...inputs,
                  max: value, // Only update "max" field with the pasted value
                });
              }

              e.preventDefault(); // Prevent default paste action for single values
            } else {
              // If the paste doesn't match the expected pattern, ignore it
              console.log("Invalid or unsupported paste value:", paste);
              e.preventDefault(); // Prevent default paste action for invalid inputs
            }
          }
        };

        const calcular = () => {
          const val = (key) => parseFloat(inputs[key]);
          let meanOur = 0;
          let sdOur = 0;

          // Keep the calculation exactly the same as original!
          switch (metodo) {
            case "Cenario1":
              meanOur = (val("min") + 2 * val("median") + val("max")) / 4;
              sdOur =
                (val("max") - val("min")) /
                (2 * normInv((val("n") - 0.375) / (val("n") + 0.25)));
              console.log("sdOur antes do arredondamento:", sdOur);
              break;
            case "Cenario2":
              meanOur =
                (val("min") +
                  2 * val("q1") +
                  2 * val("median") +
                  2 * val("q3") +
                  val("max")) /
                8;
              sdOur =
                (val("max") - val("min")) /
                  (4 * normInv((val("n") - 0.375) / (val("n") + 0.25))) +
                (val("q3") - val("q1")) /
                  (4 * normInv((0.75 * val("n") - 0.125) / (val("n") + 0.25)));
              break;
            case "Cenario3":
              meanOur = (val("q1") + val("median") + val("q3")) / 3;
              sdOur =
                (val("q3") - val("q1")) /
                (2 * normInv((0.75 * val("n") - 0.125) / (val("n") + 0.25)));
              break;
            default:
              break;
          }

          // Truncate to four decimals
          const truncateToFourDecimals = (num) =>
            Math.floor(num * 10000) / 10000;

          const calculatedMean = truncateToFourDecimals(meanOur);
          const calculatedSd = truncateToFourDecimals(sdOur);

          setResultado({
            meanOur: calculatedMean,
            sdOur: calculatedSd,
          });
          setHistorico([
            ...historico,
            {
              meanOur: calculatedMean,
              sdOur: calculatedSd,
              label: "",
              formatted: false,
            },
          ]);

          // Auto-insert mean and SD into the appropriate fields if inputValues exists
          if (setInputValues && inputValues) {
            if (groupType === "intervention_comparison") {
              // Double arm mode
              if (targetGroup === "intervention") {
                setInputValues(prev => ({
                  ...prev,
                  variableValue: {
                    ...prev.variableValue,
                    interventionMean: calculatedMean.toString(),
                    interventionSd: calculatedSd.toString(),
                  }
                }));
              } else if (targetGroup === "comparison") {
                setInputValues(prev => ({
                  ...prev,
                  variableValue: {
                    ...prev.variableValue,
                    comparisonMean: calculatedMean.toString(),
                    comparisonSd: calculatedSd.toString(),
                  }
                }));
              }
            } else {
              // Single arm mode
              setInputValues(prev => ({
                ...prev,
                variableValue: {
                  ...prev.variableValue,
                  mean: calculatedMean.toString(),
                  sd: calculatedSd.toString(),
                }
              }));
            }
          }
        };

        const normInv = (p) => {
          return Math.sqrt(2) * erfInv(2 * p - 1);
        };
        const erfInv = (x) => {
          const a = 0.147;
          const ln = Math.log(1 - x * x);
          const tt1 = 2 / (Math.PI * a) + ln / 2;
          const tt2 = (1 / a) * ln;
          const sqrt1 = Math.sqrt(tt1 * tt1 - tt2);
          return Math.sign(x) * Math.sqrt(sqrt1 - tt1);
        };

        const copiarReferencia = () => {
          const referencia =
            "Wan, X., Wang, W., Liu, J. et al. Estimating the sample mean and standard deviation from the sample size, median, range and/or interquartile range. BMC Med Res Methodol 14, 135 (2014). https://doi.org/10.1186/1471-2288-14-135";
          const tempInput = document.createElement("textarea");
          tempInput.value = referencia;
          document.body.appendChild(tempInput);
          tempInput.select();
          document.execCommand("copy");
          document.body.removeChild(tempInput);
          setReferenciaCopiada(true);
          setTimeout(() => setReferenciaCopiada(false), 2000);
        };

        const copiarResultado = () => {
          const resultText = `${resultado.meanOur.toFixed(4)} ± ${resultado.sdOur.toFixed(4)}`;
          const tempInput = document.createElement("textarea");
          tempInput.value = resultText;
          document.body.appendChild(tempInput);
          tempInput.select();
          document.execCommand("copy");
          document.body.removeChild(tempInput);
          setResultadoCopiado(true);
          setTimeout(() => setResultadoCopiado(false), 2000);
        };

        const handleLabelChange = (index, label) => {
          const novoHistorico = [...historico];
          novoHistorico[index].label = label;
          setHistorico(novoHistorico);
        };

        const handleFormattingPaste = (e) => {
          const paste = e.clipboardData.getData("text");
          let meanValue = "";
          let sdValue = "";

          if (paste.includes("(") && paste.includes(")")) {
            const [meanStr, sdStr] = paste.split(" ");
            meanValue = parseFloat(meanStr.replace(",", "."));
            sdValue = parseFloat(sdStr.slice(1, -1).replace(",", "."));
          } else if (paste.includes(" ")) {
            const [meanStr, sdStr] = paste.split(" ");
            meanValue = parseFloat(meanStr.replace(",", "."));
            sdValue = parseFloat(sdStr.replace(",", "."));
          } else if (paste.includes("\t")) {
            const [meanStr, sdStr] = paste.split("\t");
            meanValue = parseFloat(meanStr.replace(",", "."));
            sdValue = parseFloat(sdStr.replace(",", "."));
          }

          if (meanValue && sdValue) {
            setMean(meanValue);
            setSd(sdValue);
            e.preventDefault();
          }
        };

        const formatar = () => {
          if (mean && sd) {
            // Format with 4 decimals
            const formatted = `${parseFloat(mean).toFixed(4)} ± ${parseFloat(
              sd
            ).toFixed(4)} [mean]`;
            setFormattedResult(formatted);

            setHistorico([
              ...historico,
              {
                meanOur: parseFloat(mean.toString()),
                sdOur: parseFloat(sd.toString()),
                label: "",
                formatted: true,
                result: formatted,
              },
            ]);
          }
        };

        const handleRevManPaste = (e) => {
          const paste = e.clipboardData.getData("text");
          const linhas = paste
            .split("\n")
            .map((l) => l.trim())
            .filter((l) => l !== "");
          let intervencaoData = [];
          let controleData = [];

          if (linhas.length > 0) {
            if (linhas[0].includes("\t")) {
              linhas.forEach((linha) => {
                const [interData, contData] = linha.split("\t");
                intervencaoData.push(interData);
                controleData.push(contData);
              });
            } else {
              intervencaoData = linhas.slice(0, Math.floor(linhas.length / 2));
              controleData = linhas.slice(Math.floor(linhas.length / 2));
            }
          }

          setIntervencao(intervencaoData);
          setControle(controleData);
          e.preventDefault();
        };

        const organizarPlanilha = () => {
          const organizarColunas = (dados, totais) => {
            const regexList = [
              /^(\d+\.?\d*)\s*±\s*(\d+\.?\d*)\s*\[mean\]$/,
              /^(\d+\.?\d*)\s*±\s*(\d+\.?\d*)$/,
              /^(\d+\.?\d*)\s*\(\s*±\s*(\d+\.?\d*)\)$/,
              /^(\d+\.?\d*)\s*\(\s*(\d+\.?\d*)\)$/,
              /^(\d+\.?\d*)\s*±\s*(\d+\.?\d*)\;$/,
              /^(\d+\.?\d*)\s+(\d+\.?\d*)$/,
              /^(\d+\.?\d*)\s*\/\s*(\d+\.?\d*)$/,
              /^(\d+\.?\d*)\s*\(\+\-\s*(\d+\.?\d*)\)$/,
              /^(\d+\.?\d*)\s*\(\s*(\d+\.?\d*)\s*SD\)$/,
              /^(\d+\.?\d*)±(\d+\.?\d*)$/,
            ];

            return dados.map((dado, index) => {
              let mean = null;
              let sd = null;
              for (let regex of regexList) {
                const match = dado.match(regex);
                if (match) {
                  mean = parseFloat(match[1]);
                  sd = parseFloat(match[2]);
                  break;
                }
              }
              if (mean !== null && sd !== null) {
                return {
                  mean,
                  sd,
                  total: totais[index] ? parseFloat(totais[index]) : "",
                };
              } else {
                return { mean: "", sd: "", total: "" };
              }
            });
          };

          const intervencaoOrganizada = organizarColunas(
            intervencao,
            intervencaoTotal
          );
          const controleOrganizada = organizarColunas(controle, controleTotal);

          const calcularMediaPonderada = (dados) => {
            const totalPopulacao = dados.reduce(
              (sum, row) => sum + (row.total || 0),
              0
            );
            const mediaPonderada =
              dados.reduce((sum, row) => sum + (row.mean * row.total || 0), 0) /
              totalPopulacao;
            return totalPopulacao > 0 ? mediaPonderada : "";
          };

          const mediaPonderadaIntervencao = calcularMediaPonderada(
            intervencaoOrganizada
          );
          const mediaPonderadaControle =
            calcularMediaPonderada(controleOrganizada);

          let organizada = intervencaoOrganizada.map((inter, idx) => {
            const controle = controleOrganizada[idx] || {};
            const linhaValida =
              inter.mean ||
              inter.sd ||
              inter.total ||
              controle.mean ||
              controle.sd ||
              controle.total;
            return linhaValida
              ? [
                  autores[idx] || "",
                  inter.mean,
                  inter.sd,
                  inter.total,
                  controle.mean || "",
                  controle.sd || "",
                  controle.total || "",
                ]
              : [
                  "",
                  inter.mean,
                  inter.sd,
                  inter.total,
                  controle.mean || "",
                  controle.sd || "",
                  controle.total || "",
                ];
          });

          organizada.push([
            "Weighted Mean",
            mediaPonderadaIntervencao
              ? mediaPonderadaIntervencao.toFixed(2)
              : "",
            "",
            "",
            mediaPonderadaControle ? mediaPonderadaControle.toFixed(2) : "",
          ]);

          setPlanilhaOrganizada(organizada);
          setIsRevManModalOpen(false);
        };

        const copiarPlanilha = () => {
          if (planilhaOrganizada) {
            const planilhaSemMediasPonderadas = planilhaOrganizada.slice(0, -1);
            const planilhaSemLinhasVazias = planilhaSemMediasPonderadas.filter(
              (row) => row.slice(1).some((cell) => cell !== "")
            );

            let textoParaCopiar = planilhaSemLinhasVazias
              .map((row) => row.slice(1).join("\t"))
              .join("\n");

            const tempTextArea = document.createElement("textarea");
            tempTextArea.value = textoParaCopiar;
            document.body.appendChild(tempTextArea);

            tempTextArea.select();
            try {
              document.execCommand("copy");
              setBotaoCopiado(true);
              setTimeout(() => setBotaoCopiado(false), 2000);
            } catch (err) {
              alert("Falha ao copiar os dados.");
            }

            document.body.removeChild(tempTextArea);
          }
        };

        useEffect(() => {
          const copyButton = document.querySelector(".copy-button");
          if (copyButton) {
            copyButton.addEventListener("click", copiarPlanilha);
          }
        }, [planilhaOrganizada]);

        return (
          <div className="w-full max-w-md relative z-10">
            {/* Switcher for Intervention/Comparison (only for double arm) */}
            {groupType === "intervention_comparison" && (
              <div className="mb-4">
                <label className="block text-sm font-bold mb-2">
                  Target Group:
                </label>
                <div className="flex space-x-2">
                  <button
                    onClick={() => setTargetGroup("intervention")}
                    className={`flex-1 py-2 px-4 rounded font-semibold transition ${
                      targetGroup === "intervention"
                        ? "bg-blue-600 text-white"
                        : "bg-gray-700 text-gray-300 hover:bg-gray-600"
                    }`}
                  >
                    Intervention
                  </button>
                  <button
                    onClick={() => setTargetGroup("comparison")}
                    className={`flex-1 py-2 px-4 rounded font-semibold transition ${
                      targetGroup === "comparison"
                        ? "bg-green-600 text-white"
                        : "bg-gray-700 text-gray-300 hover:bg-gray-600"
                    }`}
                  >
                    Comparison
                  </button>
                </div>
              </div>
            )}

            <div className="mb-4">
              <label className="block text-sm font-bold mb-2">
                Select Method:
              </label>
              <select
                value={metodo}
                onChange={(e) => setMetodo(e.target.value)}
                className="block w-full p-2 rounded"
              >
                <option value="Cenario1">
                  Scenario 1 (minimum, median, maximum)
                </option>
                <option value="Cenario2">
                  Scenario 2 (minimum, 1st quartile, median, 3rd quartile,
                  maximum)
                </option>
                <option value="Cenario3">
                  Scenario 3 (1st quartile, median, 3rd quartile)
                </option>
              </select>
            </div>

            {metodo === "Cenario1" && (
              <div>
                <input
                  type="number"
                  step="any"
                  name="min"
                  placeholder="Minimum"
                  onChange={handleInputChange}
                  onPaste={handlePaste}
                  value={inputs.min || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="median"
                  placeholder="Median"
                  onChange={handleInputChange}
                  value={inputs.median || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="max"
                  placeholder="Maximum"
                  onChange={handleInputChange}
                  value={inputs.max || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="n"
                  placeholder="Sample Size"
                  onChange={handleInputChange}
                  value={inputs.n || ""}
                  className="block w-full p-2 rounded mb-2"
                />
              </div>
            )}

            {metodo === "Cenario2" && (
              <div>
                <input
                  type="number"
                  step="any"
                  name="min"
                  placeholder="Minimum"
                  onChange={handleInputChange}
                  value={inputs.min || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="q1"
                  placeholder="1st quartile"
                  onChange={handleInputChange}
                  value={inputs.q1 || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="median"
                  placeholder="Median"
                  onChange={handleInputChange}
                  value={inputs.median || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="q3"
                  placeholder="3rd quartile"
                  onChange={handleInputChange}
                  value={inputs.q3 || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="max"
                  placeholder="Maximum"
                  onChange={handleInputChange}
                  value={inputs.max || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="n"
                  placeholder="Sample Size"
                  onChange={handleInputChange}
                  value={inputs.n || ""}
                  className="block w-full p-2 rounded mb-2"
                />
              </div>
            )}

            {metodo === "Cenario3" && (
              <div>
                <input
                  type="number"
                  step="any"
                  name="q1"
                  placeholder="1st quartile"
                  onChange={handleInputChange}
                  onPaste={handlePaste}
                  value={inputs.q1 || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="median"
                  placeholder="Median"
                  onChange={handleInputChange}
                  value={inputs.median || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="q3"
                  placeholder="3rd quartile"
                  onChange={handleInputChange}
                  value={inputs.q3 || ""}
                  className="block w-full p-2 rounded mb-2"
                />
                <input
                  type="number"
                  step="any"
                  name="n"
                  placeholder="Sample Size"
                  onChange={handleInputChange}
                  value={inputs.n || ""}
                  className="block w-full p-2 rounded mb-2"
                />
              </div>
            )}

            <div className="flex space-x-4 mt-4">
              <button
                onClick={calcular}
                className="bg-blue-500 text-white p-2 rounded"
              >
                Calculate
              </button>
              <button
                onClick={() => setIsFormattingModalOpen(true)}
                className="bg-yellow-500 text-white p-2 rounded"
              >
                Formatting
              </button>
              <button
                onClick={() => setIsRevManModalOpen(true)}
                className="bg-purple-500 text-white p-2 rounded"
              >
                RevMan
              </button>
            </div>
            <div className="mt-4 bg-gray-800 p-4 rounded-lg">
              <p>
                <strong>Result:</strong>
                <br />
                {resultado.meanOur.toFixed(4)} ± {resultado.sdOur.toFixed(4)}
              </p>
              <button
                onClick={copiarResultado}
                className="mt-2 bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded font-semibold transition w-full"
              >
                {resultadoCopiado ? "✓ Result Copied!" : "Copy Result"}
              </button>
            </div>

            <div className="flex space-x-4 mt-4">
              <button
                onClick={copiarReferencia}
                className="bg-green-500 text-white p-2 rounded"
              >
                {referenciaCopiada ? "Reference Copied!" : "Copy Reference"}
              </button>
              <button
                onClick={() => setIsModalOpen(true)}
                className="bg-purple-500 text-white p-2 rounded"
              >
                View History
              </button>
            </div>

            {isModalOpen && (
              <div className="fixed inset-0 flex items-start justify-center bg-black bg-opacity-50 modal-bg pt-8 overflow-y-auto">
                <div className="special-modal-container p-6 rounded-lg w-1/3">
                  <h2 className="special-modal-text text-lg font-bold mb-4">
                    Calculation History
                  </h2>
                  <ul className="max-h-96 overflow-y-auto">
                    {historico.map((item, index) => (
                      <li
                        key={index}
                        className="mb-2 flex items-center space-x-2"
                      >
                        <input
                          type="text"
                          placeholder="Name Result"
                          value={item.label}
                          onChange={(e) =>
                            handleLabelChange(index, e.target.value)
                          }
                          className="p-2 rounded flex-grow"
                        />
                        <span>
                          {item.formatted
                            ? item.result
                            : `${item.meanOur.toFixed(
                                4
                              )} ± ${item.sdOur.toFixed(4)}`}
                        </span>
                      </li>
                    ))}
                  </ul>
                  <button
                    onClick={() => setIsModalOpen(false)}
                    className="bg-red-500 text-white p-2 rounded mt-4 w-full"
                  >
                    Close
                  </button>
                </div>
              </div>
            )}

            {isFormattingModalOpen && (
              <div className="fixed inset-0 flex items-start justify-center bg-black bg-opacity-50 modal-bg pt-8 overflow-y-auto">
                <div className="special-modal-container p-6 rounded-lg w-1/3">
                  <h2 className="special-modal-text text-lg font-bold mb-4">Results Formatting</h2>
                  <div className="mb-4">
                    <label className="block text-sm font-bold mb-2">
                      Mean:
                    </label>
                    <input
                      type="number"
                      step="any"
                      value={mean}
                      onChange={(e) => setMean(e.target.value)}
                      onPaste={handleFormattingPaste}
                      className="block w-full p-2 rounded"
                    />
                  </div>
                  <div className="mb-4">
                    <label className="block text-sm font-bold mb-2">
                      Standard Deviation:
                    </label>
                    <input
                      type="number"
                      step="any"
                      value={sd}
                      onChange={(e) => setSd(e.target.value)}
                      onPaste={handleFormattingPaste}
                      className="block w-full p-2 rounded"
                    />
                  </div>
                  <button
                    onClick={formatar}
                    className="bg-blue-500 text-white p-2 rounded w-full mb-4"
                  >
                    Format
                  </button>
                  {formattedResult && (
                    <div className="bg-gray-700 p-4 rounded">
                      <p>
                        <strong>Format:</strong> {formattedResult}
                      </p>
                    </div>
                  )}
                  <button
                    onClick={() => setIsFormattingModalOpen(false)}
                    className="bg-red-500 text-white p-2 rounded w-full"
                  >
                    Close
                  </button>
                </div>
              </div>
            )}

            {isRevManModalOpen && (
              <div className="fixed inset-0 flex items-start justify-center bg-black bg-opacity-50 modal-bg pt-8 overflow-y-auto">
                <div className="special-modal-container p-6 rounded-lg w-3/4">
                  <h2 className="special-modal-text text-lg font-bold mb-4">RevMan</h2>
                  <div className="flex space-x-4">
                    <div className="w-1/2">
                      <h3 className="text-sm font-bold mb-2">
                        Intervention Group
                      </h3>
                      <textarea
                        value={intervencao.join("\n")}
                        onPaste={(e) => {
                          e.preventDefault();
                          const pasteData = e.clipboardData
                            .getData("text")
                            .split("\n")
                            .map((v) => v.trim());
                          setIntervencao(pasteData);
                        }}
                        onChange={(e) =>
                          setIntervencao(
                            e.target.value.split("\n").map((v) => v.trim())
                          )
                        }
                        placeholder="Paste the mean ± standard deviation values for the Intervention group."
                        className="w-full p-2 rounded mb-4 h-32"
                      />
                      <textarea
                        placeholder="Paste the total number of patients for Intervention."
                        value={intervencaoTotal.join("\n")}
                        onChange={(e) =>
                          setIntervencaoTotal(
                            e.target.value.split("\n").map((v) => v.trim())
                          )
                        }
                        className="w-full p-2 rounded mb-4 h-16"
                      />
                      <label className="block text-sm font-bold mb-2">
                        Study IDs
                      </label>
                      <textarea
                        placeholder="Author et al., Year"
                        value={autores.join("\n")}
                        onPaste={(e) => {
                          e.preventDefault();
                          const pasteData = e.clipboardData
                            .getData("text")
                            .split("\n")
                            .map((v) => v.trim());
                          setAutores(pasteData);
                        }}
                        onChange={(e) =>
                          setAutores(
                            e.target.value.split("\n").map((v) => v.trim())
                          )
                        }
                        className="w-full p-2 rounded mb-4 h-32"
                      />
                    </div>
                    <div className="w-1/2">
                      <h3 className="text-sm font-bold mb-2">Control Group</h3>
                      <textarea
                        value={controle.join("\n")}
                        onPaste={(e) => {
                          e.preventDefault();
                          const pasteData = e.clipboardData
                            .getData("text")
                            .split("\n")
                            .map((v) => v.trim());
                          setControle(pasteData);
                        }}
                        onChange={(e) =>
                          setControle(
                            e.target.value.split("\n").map((v) => v.trim())
                          )
                        }
                        placeholder="Paste the mean ± standard deviation values for the Control group."
                        className="w-full p-2 rounded mb-4 h-32"
                      />
                      <textarea
                        placeholder="Paste the total number of patients for Control."
                        value={controleTotal.join("\n")}
                        onChange={(e) =>
                          setControleTotal(
                            e.target.value.split("\n").map((v) => v.trim())
                          )
                        }
                        className="w-full p-2 rounded mb-4 h-16"
                      />
                    </div>
                  </div>
                  <button
                    onClick={organizarPlanilha}
                    className="bg-blue-500 text-white p-2 rounded w-full mb-4"
                  >
                    Organize
                  </button>
                  <button
                    onClick={() => setIsRevManModalOpen(false)}
                    className="bg-red-500 text-white p-2 rounded w-full"
                  >
                    Close
                  </button>
                </div>
              </div>
            )}

            {planilhaOrganizada && (
              <div className="fixed inset-0 flex items-start justify-center bg-black bg-opacity-50 modal-bg z-50 pt-8 overflow-y-auto">
                <div className="bg-gray-800 p-6 rounded-lg w-3/4 max-h-full overflow-auto">
                  <div className="flex justify-between items-center mb-4">
                    <h2 className="text-lg font-bold">
                      RevMan Continuous Variables Spreadsheet
                    </h2>
                    <button
                      onClick={copiarPlanilha}
                      className="bg-green-500 text-white p-2 rounded copy-button"
                    >
                      {botaoCopiado ? "Copied!" : "Copy"}
                    </button>
                  </div>
                  <table className="w-full">
                    <thead>
                      <tr>
                        {autores.length > 0 && (
                          <th className="p-2">Study ID</th>
                        )}
                        <th className="p-2">Mean (Intervention)</th>
                        <th className="p-2">
                          Standard Deviation (Intervention)
                        </th>
                        <th className="p-2">Total (Intervention)</th>
                        <th className="p-2">Mean (Control)</th>
                        <th className="p-2">Standard Deviation (Control)</th>
                        <th className="p-2">Total (Control)</th>
                      </tr>
                    </thead>
                    <tbody>
                      {planilhaOrganizada.map((row, index) => (
                        <tr key={index}>
                          {row.map((cell, cellIndex) => (
                            <td key={cellIndex} className="p-2">
                              {cell}
                            </td>
                          ))}
                        </tr>
                      ))}
                    </tbody>
                  </table>
                  <button
                    onClick={() => setPlanilhaOrganizada(null)}
                    className="bg-red-500 text-white p-2 rounded mt-4 w-full"
                  >
                    Close
                  </button>
                </div>
              </div>
            )}
          </div>
        );
      }
      // VariableInputScreen Component
      function VariableInputScreen({
        studyIds,
        baselineVariables,
        setBaselineVariables,
        outcomesVariables,
        setOutcomesVariables,
        groupType,
        groupNames,
        selectedOption,
        setSelectedOption,
        onPreview,
        onBack,
        inputValues,
        setInputValues,
        usedInterventions,
        setUsedInterventions,
      }) {
        const [showAlert, setShowAlert] = useState(false);
        const [editVariableId, setEditVariableId] = useState(null);

        // New state for Import Data modal
        const [isImportModalOpen, setIsImportModalOpen] = useState(false);
        const [importVariableType, setImportVariableType] =
          useState("dichotomous");
        const [importArmType, setImportArmType] = useState(
          groupType === "intervention_comparison" ? "double" : "single"
        );
        const [importDataText, setImportDataText] = useState("");
        // New state variables for Spreadsheet Mode
        const [isSpreadsheetMode, setIsSpreadsheetMode] = useState(false);
        const [spreadsheetData, setSpreadsheetData] = useState([]);
        // New state for delete confirmation modal
        const [focusedCell, setFocusedCell] = useState(null);
        const [hoveredRowIndex, setHoveredRowIndex] = useState(null);
        const [hoveredColIndex, setHoveredColIndex] = useState(null);
        // New state variables for PICO mode
        const [isPicoMode, setIsPicoMode] = useState(false);
        const [picoRawText, setPicoRawText] = useState("");
        const [picoOrientation, setPicoOrientation] = useState("rows"); // "rows" or "columns"
        const [picoTableData, setPicoTableData] = useState([]);
        const [picoShowPreview, setPicoShowPreview] = useState(false);
        const [picoVariableMappings, setPicoVariableMappings] = useState({});
        const [picoStudyMappings, setPicoStudyMappings] = useState({});
        const [picoInterventionName, setPicoInterventionName] = useState("");

        const variables =
          selectedOption === "baseline" ? baselineVariables : outcomesVariables;
        const setVariables =
          selectedOption === "baseline"
            ? setBaselineVariables
            : setOutcomesVariables;

        // Add these near your existing state declarations:
        const [isCalculadoraModalOpen, setIsCalculadoraModalOpen] =
          useState(false);
        const [interventionPopSize, setInterventionPopSize] = useState("");
        const [comparisonPopSize, setComparisonPopSize] = useState("");
        // --- SNIPPET 1: Add these near the top of VariableInputScreen ---
        const [isMultipleVarModalOpen, setIsMultipleVarModalOpen] =
          useState(false);
        const [multiVarChoice, setMultiVarChoice] = useState({
          dataOption: "baseline", // or 'outcomes'
          variableType: "dichotomous", // or 'continuous' / 'text'
          armType:
            groupType === "intervention_comparison" ? "double" : "single",
        });
        const [multiVarText, setMultiVarText] = useState("");
        const [allVariableSuggestions, setAllVariableSuggestions] = useState(
          []
        );

        // Handler to open/close the modal
        const openMultiVarModal = () => setIsMultipleVarModalOpen(true);
        const closeMultiVarModal = () => setIsMultipleVarModalOpen(false);

        // Function to handle dropdown changes (data option, variable type, arm type)
        const handleMultiVarChange = (field, value) => {
          setMultiVarChoice((prev) => ({ ...prev, [field]: value }));
        };

        // ...
        // This function parses the user's multiVarText and adds multiple variables at once
        const handleAddMultipleVariables = () => {
          if (!multiVarText.trim()) {
            alert("Please enter some variable names to add.");
            return;
          }

          // 1) Split on commas, tabs, or newlines
          const names = multiVarText
            .split(/[\n\t,]+/)
            .map((nm) => nm.trim())
            .filter(Boolean);

          // 2) Merge these new names into our 'allVariableSuggestions' array
          setAllVariableSuggestions((prev) => {
            const merged = [...prev, ...names];
            // Deduplicate
            return [...new Set(merged)];
          });

          // 3) Also store them in localStorage
          //    (for example, under the key 'multipleVarSuggestions')
          try {
            // Retrieve any existing suggestions from localStorage
            const oldData =
              JSON.parse(localStorage.getItem("multipleVarSuggestions")) || [];
            const mergedData = [...oldData, ...names];
            // Deduplicate
            const uniqueData = [...new Set(mergedData)];
            localStorage.setItem(
              "multipleVarSuggestions",
              JSON.stringify(uniqueData)
            );
          } catch (err) {
            console.error(
              "Failed to store multipleVarSuggestions in localStorage",
              err
            );
          }

          // 4) Clear the text and close
          setMultiVarText("");
          closeMultiVarModal();
        };

        useEffect(() => {
          // Retrieve suggestions from localStorage at startup
          const storedSuggestions =
            JSON.parse(localStorage.getItem("multipleVarSuggestions")) || [];
          if (storedSuggestions.length > 0) {
            setAllVariableSuggestions((prev) => {
              // Merge with any hardcoded or previously set suggestions
              const merged = [...prev, ...storedSuggestions];
              return [...new Set(merged)];
            });
          }
        }, []);

        // Functions to open/close the calculator modal
        const openCalculadoraModal = () => {
          setIsCalculadoraModalOpen(true);
        };
        const closeCalculadoraModal = () => {
          setIsCalculadoraModalOpen(false);
        };

        // New suggestions for single-arm or double-arm baseline data
        const additionalBaselineSuggestions = [
          "Population Size", // dichotomous
          "Male", // dichotomous
          "Female", // dichotomous
          "Age", // continuous
          "Follow-Up", // continuous
        ];

        const existingVariableLabelsSet = new Set();
        Object.values(variables).forEach((studyVars) => {
          studyVars.forEach((variable) => {
            existingVariableLabelsSet.add(variable.label);
          });
        });
        const existingVariableLabels = Array.from(existingVariableLabelsSet);

        // Merge user-supplied variable suggestions too
        let allLabels = [...existingVariableLabels, ...allVariableSuggestions];

        if (selectedOption === "baseline") {
          // Also merge the baseline suggestions
          allLabels = [
            ...allLabels,
            ...suggestedBaselineLabels,
            ...additionalBaselineSuggestions,
          ];
        }

        // Now remove duplicates
        allLabels = [...new Set(allLabels)];

        const allVariableLabels = allLabels;

        /***********************************************
         * HANDLE CHANGES IN THE VARIABLE LABEL FIELD
         ***********************************************/
        const handleVariableLabelChange = (e) => {
          const newLabel = e.target.value;
          const newLabelLower = newLabel.toLowerCase();

          // Update our inputValues with the new label text
          setInputValues((prevValues) => ({
            ...prevValues,
            variableLabel: newLabel,
          }));

          // Check if the user’s typed label matches any existing variable
          let matchedVariable = null;
          outerLoop: for (let studyVars of Object.values(variables)) {
            for (let variable of studyVars) {
              if (variable.label.toLowerCase() === newLabelLower) {
                matchedVariable = variable;
                break outerLoop;
              }
            }
          }

          if (matchedVariable) {
            // If it matches an existing variable, use the same type & arm
            setInputValues((prevValues) => ({
              ...prevValues,
              variableLabel: matchedVariable.label,
              variableType: matchedVariable.type,
              variableValue: {},
              variableArmType: matchedVariable.armType || "single",
            }));
          }
          // If user typed one of the built-in baseline labels (e.g. “Country”), treat as text
          else if (
            suggestedBaselineLabels
              .map((lbl) => lbl.toLowerCase())
              .includes(newLabelLower) &&
            selectedOption === "baseline"
          ) {
            const originalSuggestedLabel = suggestedBaselineLabels.find(
              (lbl) => lbl.toLowerCase() === newLabelLower
            );
            setInputValues((prevValues) => ({
              ...prevValues,
              variableLabel: originalSuggestedLabel,
              variableType: "text",
              variableValue: {},
              variableArmType: "single",
            }));
          }
          // If user typed something like “Population Size,” “Age,” or “Follow-Up”
          else if (
            selectedOption === "baseline" &&
            additionalBaselineSuggestions
              .map((lbl) => lbl.toLowerCase())
              .includes(newLabelLower)
          ) {
            let determinedType = "dichotomous";

            // For “Population Size,” we handle it as “population_size”
            if (newLabelLower === "population size") {
              determinedType = "population_size";
            }
            // For “Age” or “Follow-Up,” treat as continuous
            else if (newLabelLower === "age" || newLabelLower === "follow-up") {
              determinedType = "continuous";
            }

            // If we have two arms, treat as double; otherwise single
            const armType =
              groupType === "intervention_comparison" ? "double" : "single";

            setInputValues((prevValues) => ({
              ...prevValues,
              variableLabel: newLabel,
              variableType: determinedType,
              variableValue: {},
              variableArmType: armType,
            }));
          }
          // Otherwise default to a typical dichotomous variable
          else {
            const armType =
              groupType === "intervention_comparison" ? "double" : "single";

            setInputValues((prevValues) => ({
              ...prevValues,
              variableLabel: newLabel,
              variableType: "dichotomous",
              variableValue: {},
              variableArmType: armType,
            }));
          }
        };

        const isSinglePlaceholder =
          selectedOption === "baseline" &&
          suggestedBaselineLabels.includes(inputValues.variableLabel);

        // Ensure selectedStudyId is set to the first study ID if it's empty
        useEffect(() => {
          if (!inputValues.selectedStudyId && studyIds.length > 0) {
            setInputValues((prevValues) => ({
              ...prevValues,
              selectedStudyId: studyIds[0],
            }));
          }
        }, [inputValues.selectedStudyId, studyIds]);

        // Reset edit mode when selectedStudyId changes
        useEffect(() => {
          setEditVariableId(null);
        }, [inputValues.selectedStudyId]);

        // State variables for drag-and-drop
        const [draggedVariableId, setDraggedVariableId] = useState(null);
        const [variablesOrder, setVariablesOrder] = useState({});

        // Initialize variablesOrder when variables change
        useEffect(() => {
          const newOrder = {};
          studyIds.forEach((studyId) => {
            newOrder[studyId] = (variables[studyId] || []).map((v) => v.id);
          });
          setVariablesOrder(newOrder);
        }, [variables, studyIds]);

        const generateUniqueId = () => {
          return Date.now() + Math.random();
        };

        const handleAddVariable = () => {
          if (!inputValues.variableLabel) {
            alert("Please enter a label for the variable.");
            return;
          }

          // Validate intervention name for network mode
          if (groupType === "network" && !isSinglePlaceholder && !inputValues.interventionName.trim()) {
            alert("Please enter an intervention name for network mode.");
            return;
          }

          const selectedStudyId = inputValues.selectedStudyId || studyIds[0];
          const studyVars = variables[selectedStudyId]
            ? [...variables[selectedStudyId]]
            : [];

          let value = {};

          // --- If "single placeholder" baseline (like "Country") ---
          if (isSinglePlaceholder) {
            // just store as text
            value = inputValues.variableValue.singleValue || "";
          }

          // --- Otherwise handle groupType logic ---
          else if (groupType === "intervention_comparison") {
            if (inputValues.variableArmType === "double") {
              // For double-arm dichotomous, continuous, text, etc.
              if (inputValues.variableType === "dichotomous") {
                // 1) If there's a population var, auto-fill only if user left it blank
                const populationVar = findPopulationVar(selectedStudyId);
                const populationInterv =
                  populationVar?.value?.interventionPop ?? "";
                const populationCompar =
                  populationVar?.value?.comparisonPop ?? "";

                // Force inputValues if blank
                if (
                  !inputValues.variableValue.interventionTotal?.trim() &&
                  populationInterv
                ) {
                  inputValues.variableValue.interventionTotal =
                    populationInterv;
                }
                if (
                  !inputValues.variableValue.comparisonTotal?.trim() &&
                  populationCompar
                ) {
                  inputValues.variableValue.comparisonTotal = populationCompar;
                }

                value = {
                  intervention:
                    inputValues.variableValue.interventionEvents || "",
                  comparison: inputValues.variableValue.comparisonEvents || "",
                  interventionTotal:
                    inputValues.variableValue.interventionTotal || "",
                  comparisonTotal:
                    inputValues.variableValue.comparisonTotal || "",
                };
              } else if (inputValues.variableType === "continuous") {
                const populationVar = findPopulationVar(selectedStudyId);
                const populationInterv =
                  populationVar?.value?.interventionPop ?? "";
                const populationCompar =
                  populationVar?.value?.comparisonPop ?? "";

                // Force inputValues if blank
                if (
                  !inputValues.variableValue.interventionTotal?.trim() &&
                  populationInterv
                ) {
                  inputValues.variableValue.interventionTotal =
                    populationInterv;
                }
                if (
                  !inputValues.variableValue.comparisonTotal?.trim() &&
                  populationCompar
                ) {
                  inputValues.variableValue.comparisonTotal = populationCompar;
                }

                value = {
                  intervention: {
                    mean: inputValues.variableValue.interventionMean || "",
                    sd: inputValues.variableValue.interventionSd || "",
                  },
                  comparison: {
                    mean: inputValues.variableValue.comparisonMean || "",
                    sd: inputValues.variableValue.comparisonSd || "",
                  },
                  interventionTotal:
                    inputValues.variableValue.interventionTotal || "",
                  comparisonTotal:
                    inputValues.variableValue.comparisonTotal || "",
                };
              } else if (inputValues.variableType === "text") {
                const populationVar = findPopulationVar(selectedStudyId);
                const populationInterv =
                  populationVar?.value?.interventionPop ?? "";
                const populationCompar =
                  populationVar?.value?.comparisonPop ?? "";

                // Force inputValues if blank
                if (
                  !inputValues.variableValue.interventionTotal?.trim() &&
                  populationInterv
                ) {
                  inputValues.variableValue.interventionTotal =
                    populationInterv;
                }
                if (
                  !inputValues.variableValue.comparisonTotal?.trim() &&
                  populationCompar
                ) {
                  inputValues.variableValue.comparisonTotal = populationCompar;
                }

                value = {
                  intervention:
                    inputValues.variableValue.interventionText || "",
                  comparison: inputValues.variableValue.comparisonText || "",
                  interventionTotal:
                    inputValues.variableValue.interventionTotal || "",
                  comparisonTotal:
                    inputValues.variableValue.comparisonTotal || "",
                };
              } else if (inputValues.variableType === "population_size") {
                // Consistent handling for population_size across all group types
                if (groupType === "intervention_comparison") {
                  if (inputValues.variableArmType === "double") {
                    value = {
                      interventionPop:
                        inputValues.variableValue.interventionPop || "",
                      comparisonPop:
                        inputValues.variableValue.comparisonPop || "",
                    };
                  } else {
                    // Single-arm in intervention_comparison
                    value = {
                      population: inputValues.variableValue.population || "",
                    };
                  }
                } else {
                  // Single-arm intervention only
                  value = {
                    population: inputValues.variableValue.population || "",
                  };
                }
              }
            } else {
              // Single-arm data in an intervention+comparison environment
              if (inputValues.variableType === "dichotomous") {
                // If there's a population, only auto-fill if blank
                const populationVar = findPopulationVar(selectedStudyId);
                const singlePop = populationVar?.value?.population ?? "";

                if (!inputValues.variableValue.total?.trim() && singlePop) {
                  inputValues.variableValue.total = singlePop;
                }

                value = {
                  events: inputValues.variableValue.events || "",
                  total: inputValues.variableValue.total || "",
                };
              } else if (inputValues.variableType === "continuous") {
                const populationVar = findPopulationVar(selectedStudyId);
                const singlePop = populationVar?.value?.population ?? "";

                if (!inputValues.variableValue.total?.trim() && singlePop) {
                  inputValues.variableValue.total = singlePop;
                }

                value = {
                  mean: inputValues.variableValue.mean || "",
                  sd: inputValues.variableValue.sd || "",
                  total: inputValues.variableValue.total || "",
                };
              } else if (inputValues.variableType === "text") {
                const populationVar = findPopulationVar(selectedStudyId);
                const singlePop = populationVar?.value?.population ?? "";

                if (!inputValues.variableValue.total?.trim() && singlePop) {
                  inputValues.variableValue.total = singlePop;
                }

                value = {
                  text: inputValues.variableValue.text || "",
                  total: inputValues.variableValue.total || "",
                };
              } else if (inputValues.variableType === "population_size") {
                // Consistent handling for population_size
                if (groupType === "intervention_comparison") {
                  value = inputValues.variableValue.population || "";
                } else {
                  // Single-arm intervention only
                  value = {
                    population: inputValues.variableValue.population || "",
                  };
                }
              }
            }
          } else {
            // Single-arm (no comparison group) - applies to both 'intervention' and 'network' modes
            if (inputValues.variableType === "dichotomous") {
              let singlePop = "";

              if (groupType === "network") {
                // Network mode: get population for specific intervention
                singlePop = getPopulationForIntervention(
                  selectedStudyId,
                  inputValues.interventionName,
                  baselineVariables,
                  outcomesVariables
                );
              } else {
                // Regular intervention mode: get any population
                const populationVar = findPopulationVar(selectedStudyId);
                singlePop = populationVar?.value?.population ?? "";
              }

              if (!inputValues.variableValue.total?.trim() && singlePop) {
                inputValues.variableValue.total = singlePop;
              }

              value = {
                events: inputValues.variableValue.events || "",
                total: inputValues.variableValue.total || "",
              };
            } else if (inputValues.variableType === "continuous") {
              let singlePop = "";

              if (groupType === "network") {
                // Network mode: get population for specific intervention
                singlePop = getPopulationForIntervention(
                  selectedStudyId,
                  inputValues.interventionName,
                  baselineVariables,
                  outcomesVariables
                );
              } else {
                // Regular intervention mode: get any population
                const populationVar = findPopulationVar(selectedStudyId);
                singlePop = populationVar?.value?.population ?? "";
              }

              if (!inputValues.variableValue.total?.trim() && singlePop) {
                inputValues.variableValue.total = singlePop;
              }

              value = {
                mean: inputValues.variableValue.mean || "",
                sd: inputValues.variableValue.sd || "",
                total: inputValues.variableValue.total || "",
              };
            } else if (inputValues.variableType === "text") {
              let singlePop = "";

              if (groupType === "network") {
                // Network mode: get population for specific intervention
                singlePop = getPopulationForIntervention(
                  selectedStudyId,
                  inputValues.interventionName,
                  baselineVariables,
                  outcomesVariables
                );
              } else {
                // Regular intervention mode: get any population
                const populationVar = findPopulationVar(selectedStudyId);
                singlePop = populationVar?.value?.population ?? "";
              }

              if (!inputValues.variableValue.total?.trim() && singlePop) {
                inputValues.variableValue.total = singlePop;
              }

              value = {
                text: inputValues.variableValue.text || "",
                total: inputValues.variableValue.total || "",
              };
            } else if (inputValues.variableType === "population_size") {
              // Consistent handling for population_size
              if (groupType === "intervention_comparison") {
                value = inputValues.variableValue.population || "";
              } else {
                // Single-arm intervention or network
                value = {
                  population: inputValues.variableValue.population || "",
                };
              }
            }
          }

          // Build the new variable object
          const newVariable = {
            id:
              editVariableId !== null
                ? editVariableId
                : Date.now() + Math.random(),
            label: inputValues.variableLabel,
            type: inputValues.variableType,
            value: value,
            isSinglePlaceholder: isSinglePlaceholder,
            armType: inputValues.variableArmType,
          };

          // Add interventionName for network mode
          if (groupType === "network" && !isSinglePlaceholder) {
            newVariable.interventionName = inputValues.interventionName.trim();

            // Update usedInterventions list if this is a new intervention
            if (!usedInterventions.includes(newVariable.interventionName)) {
              setUsedInterventions([...usedInterventions, newVariable.interventionName]);
            }
          }

          // Insert or update
          const index = studyVars.findIndex((v) => v.id === editVariableId);
          if (editVariableId !== null && index !== -1) {
            studyVars[index] = newVariable;
          } else {
            studyVars.push(newVariable);
          }

          setVariables({ ...variables, [selectedStudyId]: studyVars });

          // Optionally re-sync your variablesOrder
          setVariablesOrder((prev) => {
            const newOrder = { ...prev };
            newOrder[selectedStudyId] = studyVars.map((v) => v.id);
            return newOrder;
          });

          // Reset
          setInputValues((prev) => ({
            ...prev,
            variableLabel: "",
            variableValue: {},
            variableType: "dichotomous",
            variableArmType:
              groupType === "intervention_comparison" ? "double" : "single",
            interventionName: "",
          }));

          setEditVariableId(null);
          setShowAlert(true);
          setTimeout(() => setShowAlert(false), 2000);
        };

        const handleVariableValueChange = (field, val) => {
          setInputValues({
            ...inputValues,
            variableValue: {
              ...inputValues.variableValue,
              [field]: val,
            },
          });
        };
        const fieldOrderMap = {
          dichotomous_single: ["events"],
          dichotomous_double: ["interventionEvents", "comparisonEvents"],
          continuous_single: ["mean", "sd"],
          continuous_double: [
            "interventionMean",
            "interventionSd",
            "comparisonMean",
            "comparisonSd",
          ],
          text_single: ["text"],
          text_double: ["interventionText", "comparisonText"],
        };

        function findPopulationVar(studyId) {
          const allVars = [
            ...(baselineVariables[studyId] || []),
            ...(outcomesVariables[studyId] || []),
          ];
          return allVars.find((v) => v.type === "population_size");
        }

        function handlePaste(
          e,
          variableType,
          variableArmType,
          setInputValues,
          fieldName,
          variableLabel,
          suggestedBaselineLabels
        ) {
          // If this variable label is one of the suggested baseline text variables, don't interfere
          if (suggestedBaselineLabels.includes(variableLabel)) {
            return; // Do not preventDefault, let normal paste happen
          }

          e.preventDefault();
          const pastedText = (e.clipboardData || window.clipboardData).getData(
            "text"
          );

          // Split by tabs or multiple spaces
          let columns = pastedText
            .trim()
            .split(/\t| {2,}/)
            .filter(Boolean);

          // Helper to parse continuous column:
          function parseContinuousColumn(colText) {
            // Extract all numeric values from the text
            const numbers = colText.match(/[-+]?\d*\.?\d+/g);

            if (!numbers) {
              return { mean: "", sd: "" };
            }

            if (numbers.length >= 2) {
              // First is mean, second is sd
              return { mean: numbers[0], sd: numbers[1] };
            } else if (numbers.length === 1) {
              // Only mean is available
              return { mean: numbers[0], sd: "" };
            } else {
              return { mean: "", sd: "" };
            }
          }

          const fieldOrderMap = {
            dichotomous_single: ["events"],
            dichotomous_double: ["interventionEvents", "comparisonEvents"],
            continuous_single: ["mean", "sd"],
            continuous_double: [
              "interventionMean",
              "interventionSd",
              "comparisonMean",
              "comparisonSd",
            ],
            text_single: ["text"],
            text_double: ["interventionText", "comparisonText"],
          };

          const key = `${variableType}_${variableArmType}`;
          const fieldOrder = fieldOrderMap[key];
          if (!fieldOrder) return; // Unknown configuration

          let parsedValues = [];
          if (variableType === "dichotomous" || variableType === "text") {
            // Each column is just a single value (number or text)
            parsedValues = columns;
          } else if (variableType === "continuous") {
            // Each column can represent "mean ± sd" or variants thereof
            parsedValues = columns.map(parseContinuousColumn);
          }

          // Find the index of the field that triggered the paste
          const startIndex = fieldOrder.indexOf(fieldName);
          if (startIndex === -1) return; // Field not found

          let newValues = {};

          if (variableType === "dichotomous" || variableType === "text") {
            // Place each column into subsequent fields if they are empty
            for (
              let i = 0;
              i < parsedValues.length && startIndex + i < fieldOrder.length;
              i++
            ) {
              const targetField = fieldOrder[startIndex + i];
              newValues[targetField] = parsedValues[i];
            }
          } else if (variableType === "continuous") {
            // Flatten continuous data (mean, sd pairs)
            let flatValues = [];
            for (const col of parsedValues) {
              flatValues.push(col.mean);
              if (col.sd !== undefined) {
                flatValues.push(col.sd);
              }
            }

            // Assign flattened values to fields starting from startIndex
            for (
              let i = 0;
              i < flatValues.length && startIndex + i < fieldOrder.length;
              i++
            ) {
              const targetField = fieldOrder[startIndex + i];
              newValues[targetField] = flatValues[i];
            }
          }

          // Update state, but do not overwrite fields that already have values
          setInputValues((prev) => {
            const updatedValues = { ...prev.variableValue };
            for (const [field, val] of Object.entries(newValues)) {
              // Only set if the field is currently empty
              if (!updatedValues[field]) {
                updatedValues[field] = val;
              }
            }
            return {
              ...prev,
              variableValue: updatedValues,
            };
          });
        }

        // Function to add a row at a specific index
        const addRow = (index) => {
          const newRow = Array(spreadsheetData[0]?.length || 1).fill("");
          const newSpreadsheetData = [...spreadsheetData];
          newSpreadsheetData.splice(index, 0, newRow);
          setSpreadsheetData(newSpreadsheetData);
        };

        // Function to remove a row at a specific index
        const removeRow = (index) => {
          if (spreadsheetData.length <= 1) return; // Prevent removing all rows
          const newSpreadsheetData = [...spreadsheetData];
          newSpreadsheetData.splice(index, 1);
          setSpreadsheetData(newSpreadsheetData);
        };

        // Function to add a column at a specific index
        const addColumn = (index) => {
          const newSpreadsheetData = spreadsheetData.map((row) => {
            const newRow = [...row];
            newRow.splice(index, 0, "");
            return newRow;
          });
          setSpreadsheetData(newSpreadsheetData);
        };

        // Function to remove a column at a specific index
        const removeColumn = (index) => {
          if (spreadsheetData[0]?.length <= 1) return; // Prevent removing all columns
          const newSpreadsheetData = spreadsheetData.map((row) => {
            const newRow = [...row];
            newRow.splice(index, 1);
            return newRow;
          });
          setSpreadsheetData(newSpreadsheetData);
        };

        const handleEditVariable = (variableId) => {
          const selectedStudyId = inputValues.selectedStudyId || studyIds[0];
          const studyVars = variables[selectedStudyId] || [];

          const index = studyVars.findIndex((v) => v.id === variableId);
          if (index === -1) return;

          const variable = studyVars[index];

          // Set inputValues to the variable's data
          setInputValues({
            ...inputValues,
            variableLabel: variable.label,
            variableType: variable.type,
            variableValue: {}, // We will populate this next
            variableArmType:
              variable.armType ||
              (groupType === "intervention_comparison" ? "double" : "single"),
          });

          let variableValue = {};

          if (variable.isSinglePlaceholder) {
            variableValue.singleValue = variable.value || "";
          } else if (groupType === "intervention_comparison") {
            if (variable.armType === "double") {
              if (variable.type === "dichotomous") {
                variableValue.interventionEvents =
                  variable.value.intervention || "";
                variableValue.comparisonEvents =
                  variable.value.comparison || "";
              } else if (variable.type === "continuous") {
                variableValue.interventionMean =
                  variable.value.intervention.mean || "";
                variableValue.interventionSd =
                  variable.value.intervention.sd || "";
                variableValue.comparisonMean =
                  variable.value.comparison.mean || "";
                variableValue.comparisonSd = variable.value.comparison.sd || "";
              } else if (variable.type === "text") {
                variableValue.interventionText =
                  variable.value.intervention || "";
                variableValue.comparisonText = variable.value.comparison || "";
              }
            } else {
              // Single arm data in intervention_comparison mode
              if (variable.type === "dichotomous") {
                variableValue.events = variable.value || "";
              } else if (variable.type === "continuous") {
                variableValue.mean = variable.value.mean || "";
                variableValue.sd = variable.value.sd || "";
              } else if (variable.type === "text") {
                variableValue.text = variable.value || "";
              }
            }
          } else {
            if (variable.type === "dichotomous") {
              variableValue.events = variable.value || "";
            } else if (variable.type === "continuous") {
              variableValue.mean = variable.value.mean || "";
              variableValue.sd = variable.value.sd || "";
            } else if (variable.type === "text") {
              variableValue.text = variable.value || "";
            }
          }

          setInputValues((prevValues) => ({
            ...prevValues,
            variableValue: variableValue,
          }));

          // Set editVariableId
          setEditVariableId(variable.id);
        };

        const handleCancelEdit = () => {
          setInputValues({
            ...inputValues,
            variableLabel: "",
            variableValue: {},
            variableType: "dichotomous",
            variableArmType:
              groupType === "intervention_comparison" ? "double" : "single",
          });
          setEditVariableId(null);
        };

        const handleDeleteVariable = (variableId) => {
          // Delete directly without confirmation modal
          const selectedStudyId = inputValues.selectedStudyId || studyIds[0];
          const studyVars = variables[selectedStudyId]
            ? [...variables[selectedStudyId]]
            : [];

          const index = studyVars.findIndex((v) => v.id === variableId);
          if (index === -1) return;

          // Remove the variable
          studyVars.splice(index, 1);

          setVariables({
            ...variables,
            [selectedStudyId]: studyVars,
          });

          // Update variablesOrder
          setVariablesOrder((prevOrder) => {
            const newOrder = { ...prevOrder };
            newOrder[selectedStudyId] = studyVars.map((v) => v.id);
            return newOrder;
          });

          // If currently editing this variable, cancel edit
          if (editVariableId === variableId) {
            handleCancelEdit();
          }
        };

        // Function to get displayed variables in the current order
        const getDisplayedVariables = () => {
          const selectedStudyId = inputValues.selectedStudyId || studyIds[0];
          const studyVars = variables[selectedStudyId] || [];
          const order = variablesOrder[selectedStudyId] || [];
          // Sort studyVars based on the current order
          const orderedVars = order
            .map((id) => studyVars.find((v) => v.id === id))
            .filter(Boolean);
          return orderedVars;
        };

        // Drag event handlers
        const handleDragStart = (e, variableId) => {
          setDraggedVariableId(variableId);
          e.dataTransfer.effectAllowed = "move";
          e.currentTarget.classList.add("dragging");
        };

        const handleDragOver = (e, overVariableId) => {
          e.preventDefault();
          if (
            draggedVariableId === null ||
            overVariableId === draggedVariableId
          )
            return;

          const selectedStudyId = inputValues.selectedStudyId || studyIds[0];
          const order = variablesOrder[selectedStudyId] || [];
          const draggedIndex = order.indexOf(draggedVariableId);
          const overIndex = order.indexOf(overVariableId);

          if (draggedIndex === -1 || overIndex === -1) return;

          const newOrder = [...order];
          newOrder.splice(draggedIndex, 1);
          newOrder.splice(overIndex, 0, draggedVariableId);

          setVariablesOrder({
            ...variablesOrder,
            [selectedStudyId]: newOrder,
          });
        };

        const handleDrop = (e) => {
          e.preventDefault();
          if (draggedVariableId === null) return;

          const selectedStudyId = inputValues.selectedStudyId || studyIds[0];
          const order = variablesOrder[selectedStudyId] || [];
          const studyVars = variables[selectedStudyId] || [];

          // Reorder the variables based on the current order
          const orderedVars = order
            .map((id) => studyVars.find((v) => v.id === id))
            .filter(Boolean);

          setVariables({
            ...variables,
            [selectedStudyId]: orderedVars,
          });

          setDraggedVariableId(null);
          e.currentTarget.classList.remove("dragging");
        };

        const handleDragEnd = (e) => {
          e.currentTarget.classList.remove("dragging");
          setDraggedVariableId(null);
        };

        // Handle Import Data functionality
        const openImportModal = () => {
          setImportVariableType("dichotomous");
          setImportArmType(
            groupType === "intervention_comparison" ? "double" : "single"
          );
          setImportDataText("");

          // Auto-fill population size from existing Population Size variable
          // Get the currently selected study
          const currentStudyId = inputValues.selectedStudyId || studyIds[0];

          // First, check if current inputValues is a population_size type
          if (inputValues && inputValues.variableType === "population_size" && inputValues.variableValue) {
            if (groupType === "intervention_comparison") {
              if (inputValues.variableValue.interventionPop) {
                setInterventionPopSize(inputValues.variableValue.interventionPop);
              }
              if (inputValues.variableValue.comparisonPop) {
                setComparisonPopSize(inputValues.variableValue.comparisonPop);
              }
            } else {
              if (inputValues.variableValue.population) {
                setInterventionPopSize(inputValues.variableValue.population);
              }
            }
          } else {
            // If not in current input, search in saved variables FOR THE SELECTED STUDY
            const baselineVarsForStudy = baselineVariables?.[currentStudyId] || [];
            const outcomesVarsForStudy = outcomesVariables?.[currentStudyId] || [];
            const allVars = [...baselineVarsForStudy, ...outcomesVarsForStudy];

            const popVar = allVars.find((v) => v.type === "population_size");

            if (popVar && popVar.value) {
              if (groupType === "intervention_comparison") {
                // Double arm mode
                if (popVar.value.interventionPop) {
                  setInterventionPopSize(popVar.value.interventionPop);
                }
                if (popVar.value.comparisonPop) {
                  setComparisonPopSize(popVar.value.comparisonPop);
                }
              } else {
                // Single arm mode
                if (popVar.value.population) {
                  setInterventionPopSize(popVar.value.population);
                }
              }
            }
          }

          setIsImportModalOpen(true);
        };

        const closeImportModal = () => {
          setIsImportModalOpen(false);
        };

        const handleImportVariableTypeChange = (e) => {
          setImportVariableType(e.target.value);
        };

        const handleImportArmTypeChange = (e) => {
          setImportArmType(e.target.value);
        };

        // PICO Table Processing Functions
        const handlePicoProcess = () => {
          try {
            // Extract markdown table from raw text
            const lines = picoRawText.split('\n');
            const tableLines = [];
            let inTable = false;

            for (const line of lines) {
              const trimmed = line.trim();
              if (trimmed.startsWith('|')) {
                inTable = true;
                tableLines.push(trimmed);
              } else if (inTable && !trimmed.startsWith('|')) {
                break;
              }
            }

            if (tableLines.length === 0) {
              alert('No markdown table found in the pasted text. Please ensure the table uses pipe (|) delimiters.');
              return;
            }

            // Helper function to remove markdown formatting
            const cleanMarkdown = (text) => {
              return text
                .replace(/\*\*(.+?)\*\*/g, '$1')  // Remove bold **text**
                .replace(/\*(.+?)\*/g, '$1')      // Remove italic *text*
                .replace(/_(.+?)_/g, '$1')        // Remove italic _text_
                .replace(/~~(.+?)~~/g, '$1')      // Remove strikethrough ~~text~~
                .replace(/`(.+?)`/g, '$1')        // Remove code `text`
                .trim();
            };

            // Parse table rows
            const parsedRows = tableLines
              .filter(line => !line.match(/^\|[\s:-]+\|/)) // Remove separator lines
              .map(line => {
                return line
                  .split('|')
                  .slice(1, -1) // Remove first and last empty elements
                  .map(cell => cleanMarkdown(cell));
              });

            if (parsedRows.length < 2) {
              alert('Table must have at least a header row and one data row.');
              return;
            }

            setPicoTableData(parsedRows);
            setPicoShowPreview(true);
          } catch (error) {
            alert('Error processing PICO table: ' + error.message);
            console.error(error);
          }
        };

        const handlePicoConfirm = () => {
          // Validate that all study IDs are mapped
          const unmappedStudies = [];
          const studyHeaders = picoOrientation === 'rows'
            ? picoTableData.slice(1).map((row, idx) => ({ value: row[0], index: idx + 1 }))
            : picoTableData[0].slice(1).map((col, idx) => ({ value: col, index: idx + 1 }));

          for (const study of studyHeaders) {
            const mappedValue = picoStudyMappings[study.value] || study.value;
            if (!studyIds.includes(mappedValue)) {
              unmappedStudies.push(study.value);
            }
          }

          if (unmappedStudies.length > 0) {
            alert(`The following Study IDs are not recognized and must be mapped:\n${unmappedStudies.join(', ')}\n\nPlease click on the red Study IDs to map them to existing studies.`);
            return;
          }

          // Validate intervention name for Network mode (only for outcomes, not baseline)
          if (groupType === 'network' && selectedOption === 'outcomes' && !picoInterventionName.trim()) {
            alert('Please enter an intervention name for Network mode outcomes.');
            return;
          }

          // Process and create variables
          try {
            const newVars = {};

            if (picoOrientation === 'rows') {
              // Studies as rows: first column is study IDs, first row is variable labels
              const variableLabels = picoTableData[0].slice(1); // Skip first cell

              picoTableData.slice(1).forEach(row => {
                const studyId = picoStudyMappings[row[0]] || row[0];
                const values = row.slice(1);

                if (!newVars[studyId]) {
                  newVars[studyId] = [];
                }

                variableLabels.forEach((label, idx) => {
                  const mappedLabel = picoVariableMappings[label] || label;
                  const cellValue = values[idx] || '';

                  if (cellValue.trim()) {
                    const newVar = {
                      id: Date.now() + Math.random(),
                      label: mappedLabel,
                      type: 'text',
                      value: cellValue,
                      isSinglePlaceholder: true,
                      armType: 'single'
                    };

                    // Add interventionName for Network mode (only for outcomes)
                    if (groupType === 'network' && selectedOption === 'outcomes') {
                      newVar.interventionName = picoInterventionName.trim();
                    }

                    newVars[studyId].push(newVar);
                  }
                });
              });
            } else {
              // Studies as columns: first row is study IDs, first column is variable labels
              const studyIdHeaders = picoTableData[0].slice(1);

              picoTableData.slice(1).forEach(row => {
                const variableLabel = picoVariableMappings[row[0]] || row[0];
                const values = row.slice(1);

                values.forEach((cellValue, idx) => {
                  const studyId = picoStudyMappings[studyIdHeaders[idx]] || studyIdHeaders[idx];

                  if (!newVars[studyId]) {
                    newVars[studyId] = [];
                  }

                  if (cellValue.trim()) {
                    const newVar = {
                      id: Date.now() + Math.random(),
                      label: variableLabel,
                      type: 'text',
                      value: cellValue,
                      isSinglePlaceholder: true,
                      armType: 'single'
                    };

                    // Add interventionName for Network mode (only for outcomes)
                    if (groupType === 'network' && selectedOption === 'outcomes') {
                      newVar.interventionName = picoInterventionName.trim();
                    }

                    newVars[studyId].push(newVar);
                  }
                });
              });
            }

            // Merge with existing baseline or outcomes variables based on selectedOption
            const existingVars = selectedOption === 'baseline' ? baselineVariables : outcomesVariables;
            const updated = { ...existingVars };
            Object.keys(newVars).forEach(studyId => {
              if (!updated[studyId]) {
                updated[studyId] = [];
              }
              // Remove duplicates by label and add new ones
              const existingLabels = updated[studyId].map(v => v.label);
              newVars[studyId].forEach(newVar => {
                const existingIdx = updated[studyId].findIndex(v => v.label === newVar.label);
                if (existingIdx >= 0) {
                  updated[studyId][existingIdx] = newVar;
                } else {
                  updated[studyId].push(newVar);
                }
              });
            });

            // Update the correct state based on selectedOption
            if (selectedOption === 'baseline') {
              setBaselineVariables(updated);
            } else {
              setOutcomesVariables(updated);
            }

            // Add variable labels to suggestions
            const allLabels = new Set(allVariableSuggestions);
            Object.values(newVars).forEach(vars => {
              vars.forEach(v => allLabels.add(v.label));
            });
            setAllVariableSuggestions(Array.from(allLabels));

            // Reset PICO state
            setIsPicoMode(false);
            setPicoShowPreview(false);
            setPicoRawText('');
            setPicoTableData([]);
            setPicoVariableMappings({});
            setPicoStudyMappings({});
            setPicoInterventionName('');

            alert('PICO variables added successfully!');
          } catch (error) {
            alert('Error creating variables: ' + error.message);
            console.error(error);
          }
        };

        const handleAddDataset = () => {
          let dataLines = [];

          if (isSpreadsheetMode) {
            dataLines = spreadsheetData;
          } else {
            if (!importDataText.trim()) {
              alert("Please enter data into the textarea.");
              return;
            }
            dataLines = importDataText
              .trim()
              .split("\n")
              .map((line) => {
                // Split by tab, " ± " (with spaces), or "±" (without spaces)
                const cells = line.split(/\t|\s*±\s*/).map((cell) => cell.trim());
                return cells;
              });
          }

          const selectedStudyId = inputValues.selectedStudyId || studyIds[0];
          const studyVars = variables[selectedStudyId]
            ? [...variables[selectedStudyId]]
            : [];

          dataLines.forEach((cells) => {
            const label = cells[0];
            if (!label) return;

            let value = {};

            if (
              importVariableType === "dichotomous" &&
              importArmType === "double" &&
              cells.length === 3
            ) {
              cells.splice(
                2,
                0,
                interventionPopSize || "",
                comparisonPopSize || ""
              );
            } else if (
              importVariableType === "continuous" &&
              importArmType === "double" &&
              cells.length === 5
            ) {
              cells.splice(3, 0, interventionPopSize || "");
              cells.push(comparisonPopSize || "");
            } else if (
              importVariableType === "continuous" &&
              importArmType === "double" &&
              cells.length === 3
            ) {
              cells.splice(2, 0, "");
              cells.splice(3, 0, interventionPopSize || "");
              cells.splice(5, 0, "");
              cells.splice(6, 0, comparisonPopSize || "");
            }

            if (
              importVariableType === "dichotomous" &&
              importArmType === "single" &&
              cells.length === 2
            ) {
              cells.push(interventionPopSize || "");
            } else if (
              importVariableType === "continuous" &&
              importArmType === "single" &&
              cells.length === 3
            ) {
              cells.push(interventionPopSize || "");
            }

            if (importVariableType === "dichotomous") {
              if (importArmType === "double") {
                value = {
                  intervention: cells[1] || "",
                  interventionTotal: cells[2] || "",
                  comparisonTotal: cells[3] || "",
                  comparison: cells[4] || "",
                };
              } else {
                const events = cells[1] || "";
                const total = cells[2] || "";
                value = { events, total };
              }
            } else if (importVariableType === "continuous") {
              if (importArmType === "double") {
                value = {
                  intervention: {
                    mean: cells[1] || "",
                    sd: cells[2] || "",
                  },
                  comparison: {
                    mean: cells[4] || "",
                    sd: cells[5] || "",
                  },
                  interventionTotal: cells[3] || "",
                  comparisonTotal: cells[6] || "",
                };
              } else {
                value = {
                  mean: cells[1] || "",
                  sd: cells[2] || "",
                  total: cells[3] || "",
                };
              }
            } else if (importVariableType === "text") {
              if (importArmType === "double") {
                value = {
                  intervention: cells[1] || "",
                  interventionTotal: cells[2] || "",
                  comparisonTotal: cells[3] || "",
                  comparison: cells[4] || "",
                };
              } else {
                value = cells[1] || "";
              }
            } else if (importVariableType === "population_size") {
              if (importArmType === "double") {
                value = {
                  interventionPop: interventionPopSize.trim() || "",
                  comparisonPop: comparisonPopSize.trim() || "",
                };
              } else {
                value = {
                  population: interventionPopSize.trim() || "",
                };
              }
            }

            const existingIndex = studyVars.findIndex((v) => v.label === label);
            const newVariable = {
              id: generateUniqueId(),
              label,
              type: importVariableType,
              value,
              isSinglePlaceholder: false,
              armType: importArmType,
            };

            if (existingIndex !== -1) {
              studyVars[existingIndex] = newVariable;
            } else {
              studyVars.push(newVariable);
            }
          });

          setVariables({
            ...variables,
            [selectedStudyId]: studyVars,
          });

          setVariablesOrder((prevOrder) => {
            const newOrder = { ...prevOrder };
            newOrder[selectedStudyId] = studyVars.map((v) => v.id);
            return newOrder;
          });

          closeImportModal();
        };

        function getPopulationForArm(studyId, arm, baselineVars, outcomesVars) {
          // we can search in baselineVars[studyId] or outcomesVars[studyId]
          // combine them for convenience:
          const combined = [
            ...(baselineVars[studyId] || []),
            ...(outcomesVars[studyId] || []),
          ];

          // find a variable with type === 'population_size'
          for (let variable of combined) {
            if (variable.type === "population_size") {
              // check if double or single
              if (variable.armType === "double") {
                if (arm === "intervention")
                  return variable.value.interventionPop || "";
                if (arm === "comparison")
                  return variable.value.comparisonPop || "";
              } else {
                // single or 'single'
                return variable.value.population || "";
              }
            }
          }

          return ""; // no population data found
        }

        // Get population for a specific intervention (Network mode)
        function getPopulationForIntervention(studyId, interventionName, baselineVars, outcomesVars) {
          const combined = [
            ...(baselineVars[studyId] || []),
            ...(outcomesVars[studyId] || []),
          ];

          // find population_size variable with the same interventionName
          for (let variable of combined) {
            if (variable.type === "population_size" &&
                variable.interventionName === interventionName) {
              return variable.value.population || "";
            }
          }

          return ""; // no population data found for this intervention
        }

        // New version of swapInterventionComparisonValues
        const swapInterventionComparisonValues = () => {
          // Make a shallow copy to avoid mutating state directly.
          const variableValue = { ...inputValues.variableValue };

          if (inputValues.variableType === "dichotomous") {
            // Swap events & totals
            const tempEvents = variableValue.interventionEvents;
            variableValue.interventionEvents = variableValue.comparisonEvents;
            variableValue.comparisonEvents = tempEvents;

            const tempTotal = variableValue.interventionTotal;
            variableValue.interventionTotal = variableValue.comparisonTotal;
            variableValue.comparisonTotal = tempTotal;
          } else if (inputValues.variableType === "continuous") {
            // Swap mean, sd & totals
            const tempMean = variableValue.interventionMean;
            variableValue.interventionMean = variableValue.comparisonMean;
            variableValue.comparisonMean = tempMean;

            const tempSd = variableValue.interventionSd;
            variableValue.interventionSd = variableValue.comparisonSd;
            variableValue.comparisonSd = tempSd;

            const tempTotal = variableValue.interventionTotal;
            variableValue.interventionTotal = variableValue.comparisonTotal;
            variableValue.comparisonTotal = tempTotal;
          } else if (inputValues.variableType === "text") {
            // Swap text (and any totals if you’ve stored them)
            const tempText = variableValue.interventionText;
            variableValue.interventionText = variableValue.comparisonText;
            variableValue.comparisonText = tempText;

            const tempTotal = variableValue.interventionTotal;
            variableValue.interventionTotal = variableValue.comparisonTotal;
            variableValue.comparisonTotal = tempTotal;
          } else if (inputValues.variableType === "population_size") {
            if (groupType === "intervention_comparison") {
              // Swap interventionPop & comparisonPop (only for intervention_comparison)
              const tempPop = variableValue.interventionPop;
              variableValue.interventionPop = variableValue.comparisonPop;
              variableValue.comparisonPop = tempPop;
            } // No else needed, as this function is only relevant for intervention_comparison
          }

          // Update state with the swapped values
          setInputValues({
            ...inputValues,
            variableValue,
          });
        };

        return (
          <div className="space-y-6">
            <h1 className="text-2xl font-bold">Add Variables</h1>
            <div className="flex flex-col md:flex-row justify-between items-center">
              <div className="flex space-x-4 mb-4 md:mb-0">
                <button
                  onClick={() => setSelectedOption("baseline")}
                  className={`font-semibold py-2 px-4 rounded-lg transition duration-300 ${
                    selectedOption === "baseline"
                      ? "bg-blue-600"
                      : "bg-gray-700 hover:bg-gray-600"
                  }`}
                >
                  Baseline
                </button>
                <button
                  onClick={() => setSelectedOption("outcomes")}
                  className={`font-semibold py-2 px-4 rounded-lg transition duration-300 ${
                    selectedOption === "outcomes"
                      ? "bg-blue-600"
                      : "bg-gray-700 hover:bg-gray-600"
                  }`}
                >
                  Outcomes
                </button>
              </div>
              <div className="text-sm text-gray-400">
                Selected Study ID:{" "}
                <span className="font-semibold text-gray-200">
                  {inputValues.selectedStudyId || studyIds[0]}
                </span>
              </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              <div>
                <label className="block font-semibold mb-2">
                  Select Study ID
                </label>
                <select
                  value={inputValues.selectedStudyId || studyIds[0]}
                  onChange={(e) =>
                    setInputValues({
                      ...inputValues,
                      selectedStudyId: e.target.value,
                    })
                  }
                  className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  {studyIds.map((id) => (
                    <option key={id} value={id}>
                      {id}
                    </option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block font-semibold mb-2">
                  Variable Label
                </label>
                <input
                  type="text"
                  value={inputValues.variableLabel}
                  onChange={handleVariableLabelChange}
                  list="variable-labels"
                  className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="e.g., Age, Gender"
                />
                <datalist id="variable-labels">
                  {allVariableLabels.map((label) => (
                    <option key={label} value={label} />
                  ))}
                </datalist>
              </div>
              {!isSinglePlaceholder && (
                <div>
                  <label className="block font-semibold mb-2">
                    Variable Type
                  </label>
                  <select
                    value={inputValues.variableType}
                    onChange={(e) =>
                      setInputValues({
                        ...inputValues,
                        variableType: e.target.value,
                      })
                    }
                    className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    <option value="dichotomous">Dichotomous</option>
                    <option value="continuous">Continuous</option>
                    <option value="text">Text</option>
                  </select>
                </div>
              )}
            </div>

            {groupType === "network" && !isSinglePlaceholder && (
              <div className="mt-4">
                <label className="block font-semibold mb-2">
                  Intervention Name
                </label>
                <input
                  type="text"
                  value={inputValues.interventionName}
                  onChange={(e) =>
                    setInputValues({
                      ...inputValues,
                      interventionName: e.target.value,
                    })
                  }
                  list="intervention-names"
                  className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="e.g., Placebo, Drug A, Control"
                />
                <datalist id="intervention-names">
                  {usedInterventions.map((name) => (
                    <option key={name} value={name} />
                  ))}
                </datalist>
              </div>
            )}

            {groupType === "intervention_comparison" &&
              !isSinglePlaceholder && (
                <div className="mt-4">
                  <label className="block font-semibold mb-2">
                    Data Entry Mode
                  </label>
                  <select
                    value={inputValues.variableArmType}
                    onChange={(e) =>
                      setInputValues({
                        ...inputValues,
                        variableArmType: e.target.value,
                      })
                    }
                    className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    <option value="double">Double Arm Data</option>
                    <option value="single">Single Arm Data</option>
                  </select>
                </div>
              )}

            <div className="mt-6">
              {isSinglePlaceholder ? (
                // --- SINGLE-PLACEHOLDER BASELINE TEXT ---
                <div>
                  <label className="block font-semibold mb-2">Value</label>
                  <input
                    type="text"
                    value={inputValues.variableValue.singleValue || ""}
                    onChange={(e) =>
                      handleVariableValueChange("singleValue", e.target.value)
                    }
                    onPaste={(e) =>
                      handlePaste(
                        e,
                        "text",
                        "single",
                        setInputValues,
                        "singleValue",
                        inputValues.variableLabel,
                        suggestedBaselineLabels
                      )
                    }
                    className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="Enter value"
                  />
                </div>
              ) : (groupType === "intervention_comparison") ? (
                inputValues.variableArmType === "double" ? (
                  <>
                    {/* ========== DOUBLE-ARM + DICHOTOMOUS ========== */}
                    {inputValues.variableType === "dichotomous" && (
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-8 items-start">
                        {/* Intervention Column */}
                        <div className="space-y-4">
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.interventionName} Events
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.interventionEvents ||
                                ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange(
                                  "interventionEvents",
                                  val
                                );
                              }}
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "dichotomous",
                                  "double",
                                  setInputValues,
                                  "interventionEvents",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`e.g., Events in ${groupNames.interventionName}`}
                            />
                          </div>
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.interventionName} Total
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.interventionTotal?.trim()
                                  ? inputValues.variableValue.interventionTotal
                                  : getPopulationForArm(
                                      inputValues.selectedStudyId ||
                                        studyIds[0],
                                      "intervention",
                                      baselineVariables,
                                      outcomesVariables
                                    ) || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange(
                                  "interventionTotal",
                                  val
                                );
                              }}
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`Total in ${groupNames.interventionName}`}
                            />
                          </div>
                        </div>

                        {/* Swap Button (centered) */}
                        <div className="flex flex-col items-center justify-center h-full">
                          <button
                            onClick={swapInterventionComparisonValues}
                            className="text-white text-2xl font-semibold transition duration-300 hover:text-blue-500"
                          >
                            ⇌
                          </button>
                        </div>

                        {/* Comparison Column */}
                        <div className="space-y-4">
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.comparisonName} Events
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.comparisonEvents || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange(
                                  "comparisonEvents",
                                  val
                                );
                              }}
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "dichotomous",
                                  "double",
                                  setInputValues,
                                  "comparisonEvents",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`e.g., Events in ${groupNames.comparisonName}`}
                            />
                          </div>
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.comparisonName} Total
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.comparisonTotal?.trim()
                                  ? inputValues.variableValue.comparisonTotal
                                  : getPopulationForArm(
                                      inputValues.selectedStudyId ||
                                        studyIds[0],
                                      "comparison",
                                      baselineVariables,
                                      outcomesVariables
                                    ) || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange(
                                  "comparisonTotal",
                                  val
                                );
                              }}
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`Total in ${groupNames.comparisonName}`}
                            />
                          </div>
                        </div>
                      </div>
                    )}

                    {/* ========== DOUBLE-ARM + CONTINUOUS ========== */}
                    {inputValues.variableType === "continuous" && (
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-8 items-start">
                        {/* Intervention Column */}
                        <div className="space-y-4">
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.interventionName} Mean
                            </label>
                            <input
                              type="text"
                              inputMode="decimal"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.interventionMean || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(
                                  /[^0-9.\-]/g,
                                  ""
                                );
                                handleVariableValueChange(
                                  "interventionMean",
                                  val
                                );
                              }}
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "continuous",
                                  "double",
                                  setInputValues,
                                  "interventionMean",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`Mean ${groupNames.interventionName}`}
                            />
                          </div>
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.interventionName} SD
                            </label>
                            <input
                              type="text"
                              inputMode="decimal"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.interventionSd || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(
                                  /[^0-9.\-]/g,
                                  ""
                                );
                                handleVariableValueChange(
                                  "interventionSd",
                                  val
                                );
                              }}
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "continuous",
                                  "double",
                                  setInputValues,
                                  "interventionSd",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`SD ${groupNames.interventionName}`}
                            />
                          </div>
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.interventionName} Total
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.interventionTotal?.trim()
                                  ? inputValues.variableValue.interventionTotal
                                  : getPopulationForArm(
                                      inputValues.selectedStudyId ||
                                        studyIds[0],
                                      "intervention",
                                      baselineVariables,
                                      outcomesVariables
                                    ) || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange(
                                  "interventionTotal",
                                  val
                                );
                              }}
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`Total in ${groupNames.interventionName}`}
                            />
                          </div>
                        </div>

                        {/* Swap Button (centered) */}
                        <div className="flex flex-col items-center justify-center h-full">
                          <button
                            onClick={swapInterventionComparisonValues}
                            className="text-white text-2xl font-semibold transition duration-300 hover:text-blue-500"
                          >
                            ⇌
                          </button>
                        </div>

                        {/* Comparison Column */}
                        <div className="space-y-4">
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.comparisonName} Mean
                            </label>
                            <input
                              type="text"
                              inputMode="decimal"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.comparisonMean || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(
                                  /[^0-9.\-]/g,
                                  ""
                                );
                                handleVariableValueChange(
                                  "comparisonMean",
                                  val
                                );
                              }}
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "continuous",
                                  "double",
                                  setInputValues,
                                  "comparisonMean",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`Mean ${groupNames.comparisonName}`}
                            />
                          </div>
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.comparisonName} SD
                            </label>
                            <input
                              type="text"
                              inputMode="decimal"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.comparisonSd || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(
                                  /[^0-9.\-]/g,
                                  ""
                                );
                                handleVariableValueChange("comparisonSd", val);
                              }}
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "continuous",
                                  "double",
                                  setInputValues,
                                  "comparisonSd",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`SD ${groupNames.comparisonName}`}
                            />
                          </div>
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.comparisonName} Total
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.comparisonTotal?.trim()
                                  ? inputValues.variableValue.comparisonTotal
                                  : getPopulationForArm(
                                      inputValues.selectedStudyId ||
                                        studyIds[0],
                                      "comparison",
                                      baselineVariables,
                                      outcomesVariables
                                    ) || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange(
                                  "comparisonTotal",
                                  val
                                );
                              }}
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`Total in ${groupNames.comparisonName}`}
                            />
                          </div>
                        </div>
                      </div>
                    )}

                    {/* ========== DOUBLE-ARM + TEXT (NO TOTAL) ========== */}
                    {inputValues.variableType === "text" && (
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-8 items-start">
                        {/* Intervention Column */}
                        <div className="space-y-4">
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.interventionName} Text
                            </label>
                            <input
                              type="text"
                              value={
                                inputValues.variableValue.interventionText || ""
                              }
                              onChange={(e) =>
                                handleVariableValueChange(
                                  "interventionText",
                                  e.target.value
                                )
                              }
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "text",
                                  "double",
                                  setInputValues,
                                  "interventionText",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`e.g., Text for ${groupNames.interventionName}`}
                            />
                          </div>
                          {/* NOTE: No "InterventionName Total" field for text */}
                        </div>

                        {/* Swap Button (centered) */}
                        <div className="flex flex-col items-center justify-center h-full">
                          <button
                            onClick={swapInterventionComparisonValues}
                            className="text-white text-2xl font-semibold transition duration-300 hover:text-blue-500"
                          >
                            ⇌
                          </button>
                        </div>

                        {/* Comparison Column */}
                        <div className="space-y-4">
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.comparisonName} Text
                            </label>
                            <input
                              type="text"
                              value={
                                inputValues.variableValue.comparisonText || ""
                              }
                              onChange={(e) =>
                                handleVariableValueChange(
                                  "comparisonText",
                                  e.target.value
                                )
                              }
                              onPaste={(e) =>
                                handlePaste(
                                  e,
                                  "text",
                                  "double",
                                  setInputValues,
                                  "comparisonText",
                                  inputValues.variableLabel,
                                  suggestedBaselineLabels
                                )
                              }
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`e.g., Text for ${groupNames.comparisonName}`}
                            />
                          </div>
                          {/* NOTE: No "ComparisonName Total" field for text */}
                        </div>
                      </div>
                    )}

                    {/* ========== DOUBLE-ARM + POPULATION_SIZE ========== */}
                    {inputValues.variableType === "population_size" &&
                      inputValues.variableArmType === "double" && (
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-8 items-start">
                          {/* Intervention Column */}
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.interventionName} Population
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.interventionPop || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange(
                                  "interventionPop",
                                  val
                                );
                              }}
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`e.g., 100 in ${groupNames.interventionName}`}
                            />
                          </div>

                          {/* Swap Button (centered) */}
                          <div className="flex flex-col items-center justify-center h-full">
                            <button
                              onClick={swapInterventionComparisonValues}
                              className="text-white text-2xl font-semibold transition duration-300 hover:text-blue-500"
                            >
                              ⇌
                            </button>
                          </div>

                          {/* Comparison Column */}
                          <div>
                            <label className="block font-semibold mb-2">
                              {groupNames.comparisonName} Population
                            </label>
                            <input
                              type="text"
                              inputMode="numeric"
                              pattern="[0-9]*"
                              onWheel={(e) => e.preventDefault()}
                              value={
                                inputValues.variableValue.comparisonPop || ""
                              }
                              onChange={(e) => {
                                const val = e.target.value.replace(/\D/g, "");
                                handleVariableValueChange("comparisonPop", val);
                              }}
                              className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                              placeholder={`e.g., 120 in ${groupNames.comparisonName}`}
                            />
                          </div>
                        </div>
                      )}
                  </>
                ) : (
                  // --- SINGLE-ARM DATA IN INTERVENTION_COMPARISON MODE ---
                  <>
                    {/* ========== SINGLE-ARM + DICHOTOMOUS ========== */}
                    {inputValues.variableType === "dichotomous" && (
                      <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                        <div>
                          <label className="block font-semibold mb-2">
                            Events
                          </label>
                          <input
                            type="text"
                            inputMode="numeric"
                            pattern="[0-9]*"
                            onWheel={(e) => e.preventDefault()}
                            value={inputValues.variableValue.events || ""}
                            onChange={(e) => {
                              const val = e.target.value.replace(/\D/g, "");
                              handleVariableValueChange("events", val);
                            }}
                            onPaste={(e) =>
                              handlePaste(
                                e,
                                "dichotomous",
                                "single",
                                setInputValues,
                                "events",
                                inputValues.variableLabel,
                                suggestedBaselineLabels
                              )
                            }
                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="e.g., 50"
                          />
                        </div>

                        <div>
                          <label className="block font-semibold mb-2">
                            Total
                          </label>
                          <input
                            type="text"
                            inputMode="numeric"
                            pattern="[0-9]*"
                            onWheel={(e) => e.preventDefault()}
                            value={
                              inputValues.variableValue.total?.trim()
                                ? inputValues.variableValue.total
                                : getPopulationForArm(
                                    inputValues.selectedStudyId || studyIds[0],
                                    "single",
                                    baselineVariables,
                                    outcomesVariables
                                  ) || ""
                            }
                            onChange={(e) => {
                              const val = e.target.value.replace(/\D/g, "");
                              handleVariableValueChange("total", val);
                            }}
                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="e.g., 60"
                          />
                        </div>
                      </div>
                    )}

                    {/* ========== SINGLE-ARM + CONTINUOUS ========== */}
                    {inputValues.variableType === "continuous" && (
                      <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                        <div>
                          <label className="block font-semibold mb-2">
                            Mean
                          </label>
                          <input
                            type="text"
                            inputMode="decimal"
                            onWheel={(e) => e.preventDefault()}
                            value={inputValues.variableValue.mean || ""}
                            onChange={(e) => {
                              const val = e.target.value.replace(
                                /[^0-9.\-]/g,
                                ""
                              );
                              handleVariableValueChange("mean", val);
                            }}
                            onPaste={(e) =>
                              handlePaste(
                                e,
                                "continuous",
                                "single",
                                setInputValues,
                                "mean",
                                inputValues.variableLabel,
                                suggestedBaselineLabels
                              )
                            }
                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="e.g., 5.6"
                          />
                        </div>

                        <div>
                          <label className="block font-semibold mb-2">SD</label>
                          <input
                            type="text"
                            inputMode="decimal"
                            onWheel={(e) => e.preventDefault()}
                            value={inputValues.variableValue.sd || ""}
                            onChange={(e) => {
                              const val = e.target.value.replace(
                                /[^0-9.\-]/g,
                                ""
                              );
                              handleVariableValueChange("sd", val);
                            }}
                            onPaste={(e) =>
                              handlePaste(
                                e,
                                "continuous",
                                "single",
                                setInputValues,
                                "sd",
                                inputValues.variableLabel,
                                suggestedBaselineLabels
                              )
                            }
                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="e.g., 1.2"
                          />
                        </div>

                        <div>
                          <label className="block font-semibold mb-2">
                            Total
                          </label>
                          <input
                            type="text"
                            inputMode="numeric"
                            pattern="[0-9]*"
                            onWheel={(e) => e.preventDefault()}
                            value={
                              inputValues.variableValue.total?.trim()
                                ? inputValues.variableValue.total
                                : getPopulationForArm(
                                    inputValues.selectedStudyId || studyIds[0],
                                    "single",
                                    baselineVariables,
                                    outcomesVariables
                                  ) || ""
                            }
                            onChange={(e) => {
                              const val = e.target.value.replace(/\D/g, "");
                              handleVariableValueChange("total", val);
                            }}
                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="e.g., 60"
                          />
                        </div>
                      </div>
                    )}

                    {/* ========== SINGLE-ARM + TEXT (NO TOTAL) ========== */}
                    {inputValues.variableType === "text" && (
                      <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                        <div>
                          <label className="block font-semibold mb-2">
                            Text Value
                          </label>
                          <input
                            type="text"
                            value={inputValues.variableValue.text || ""}
                            onChange={(e) =>
                              handleVariableValueChange("text", e.target.value)
                            }
                            onPaste={(e) =>
                              handlePaste(
                                e,
                                "text",
                                "single",
                                setInputValues,
                                "text",
                                inputValues.variableLabel,
                                suggestedBaselineLabels
                              )
                            }
                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="e.g., Yes"
                          />
                        </div>
                        {/* NOTE: No additional "Total" field for text here */}
                      </div>
                    )}

                    {/* ========== SINGLE-ARM + POPULATION_SIZE ========== */}
                    {inputValues.variableType === "population_size" && (
                      <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                        <div>
                          <label className="block font-semibold mb-2">
                            Population Size
                          </label>
                          <input
                            type="text"
                            inputMode="numeric"
                            pattern="[0-9]*"
                            onWheel={(e) => e.preventDefault()}
                            value={inputValues.variableValue.population || ""}
                            onChange={(e) => {
                              const val = e.target.value.replace(/\D/g, "");
                              handleVariableValueChange("population", val);
                            }}
                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="e.g., 1000"
                          />
                        </div>
                      </div>
                    )}
                  </>
                )
              ) : (
                // --- SINGLE-ARM INTERVENTION OR NETWORK ---
                <>
                  {/* ========== SINGLE-ARM + DICHOTOMOUS ========== */}
                  {inputValues.variableType === "dichotomous" && (
                    <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                      <div>
                        <label className="block font-semibold mb-2">
                          Events
                        </label>
                        <input
                          type="text"
                          inputMode="numeric"
                          pattern="[0-9]*"
                          onWheel={(e) => e.preventDefault()}
                          value={inputValues.variableValue.events || ""}
                          onChange={(e) => {
                            const val = e.target.value.replace(/\D/g, "");
                            handleVariableValueChange("events", val);
                          }}
                          onPaste={(e) =>
                            handlePaste(
                              e,
                              "dichotomous",
                              "single",
                              setInputValues,
                              "events",
                              inputValues.variableLabel,
                              suggestedBaselineLabels
                            )
                          }
                          className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., 50"
                        />
                      </div>
                      <div>
                        <label className="block font-semibold mb-2">
                          Total
                        </label>
                        <input
                          type="text"
                          inputMode="numeric"
                          pattern="[0-9]*"
                          onWheel={(e) => e.preventDefault()}
                          value={
                            inputValues.variableValue.total?.trim()
                              ? inputValues.variableValue.total
                              : (groupType === "network"
                                  ? getPopulationForIntervention(
                                      inputValues.selectedStudyId || studyIds[0],
                                      inputValues.interventionName,
                                      baselineVariables,
                                      outcomesVariables
                                    )
                                  : getPopulationForArm(
                                      inputValues.selectedStudyId || studyIds[0],
                                      "single",
                                      baselineVariables,
                                      outcomesVariables
                                    )) || ""
                          }
                          onChange={(e) => {
                            const val = e.target.value.replace(/\D/g, "");
                            handleVariableValueChange("total", val);
                          }}
                          className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., 60"
                        />
                      </div>
                    </div>
                  )}

                  {/* ========== SINGLE-ARM + CONTINUOUS ========== */}
                  {inputValues.variableType === "continuous" && (
                    <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                      <div>
                        <label className="block font-semibold mb-2">Mean</label>
                        <input
                          type="text"
                          inputMode="decimal"
                          onWheel={(e) => e.preventDefault()}
                          value={inputValues.variableValue.mean || ""}
                          onChange={(e) => {
                            const val = e.target.value.replace(
                              /[^0-9.\-]/g,
                              ""
                            );
                            handleVariableValueChange("mean", val);
                          }}
                          onPaste={(e) =>
                            handlePaste(
                              e,
                              "continuous",
                              "single",
                              setInputValues,
                              "mean",
                              inputValues.variableLabel,
                              suggestedBaselineLabels
                            )
                          }
                          className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., 5.6"
                        />
                      </div>
                      <div>
                        <label className="block font-semibold mb-2">SD</label>
                        <input
                          type="text"
                          inputMode="decimal"
                          onWheel={(e) => e.preventDefault()}
                          value={inputValues.variableValue.sd || ""}
                          onChange={(e) => {
                            const val = e.target.value.replace(
                              /[^0-9.\-]/g,
                              ""
                            );
                            handleVariableValueChange("sd", val);
                          }}
                          onPaste={(e) =>
                            handlePaste(
                              e,
                              "continuous",
                              "single",
                              setInputValues,
                              "sd",
                              inputValues.variableLabel,
                              suggestedBaselineLabels
                            )
                          }
                          className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., 1.2"
                        />
                      </div>
                      <div>
                        <label className="block font-semibold mb-2">
                          Total
                        </label>
                        <input
                          type="text"
                          inputMode="numeric"
                          pattern="[0-9]*"
                          onWheel={(e) => e.preventDefault()}
                          value={
                            inputValues.variableValue.total?.trim()
                              ? inputValues.variableValue.total
                              : (groupType === "network"
                                  ? getPopulationForIntervention(
                                      inputValues.selectedStudyId || studyIds[0],
                                      inputValues.interventionName,
                                      baselineVariables,
                                      outcomesVariables
                                    )
                                  : getPopulationForArm(
                                      inputValues.selectedStudyId || studyIds[0],
                                      "single",
                                      baselineVariables,
                                      outcomesVariables
                                    )) || ""
                          }
                          onChange={(e) => {
                            const val = e.target.value.replace(/\D/g, "");
                            handleVariableValueChange("total", val);
                          }}
                          className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., 60"
                        />
                      </div>
                    </div>
                  )}

                  {/* ========== SINGLE-ARM + TEXT (NO TOTAL) ========== */}
                  {inputValues.variableType === "text" && (
                    <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                      <div>
                        <label className="block font-semibold mb-2">
                          Text Value
                        </label>
                        <input
                          type="text"
                          value={inputValues.variableValue.text || ""}
                          onChange={(e) =>
                            handleVariableValueChange("text", e.target.value)
                          }
                          onPaste={(e) =>
                            handlePaste(
                              e,
                              "text",
                              "single",
                              setInputValues,
                              "text",
                              inputValues.variableLabel,
                              suggestedBaselineLabels
                            )
                          }
                          className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., Yes"
                        />
                      </div>
                      {/* NOTE: No "Total" field for single-arm text */}
                    </div>
                  )}

                  {/* ========== SINGLE-ARM + POPULATION_SIZE ========== */}
                  {inputValues.variableType === "population_size" && (
                    <div className="grid grid-cols-1 md:grid-cols-1 gap-6">
                      <div>
                        <label className="block font-semibold mb-2">
                          Population Size
                        </label>
                        <input
                          type="text"
                          inputMode="numeric"
                          pattern="[0-9]*"
                          onWheel={(e) => e.preventDefault()}
                          value={inputValues.variableValue.population || ""}
                          onChange={(e) => {
                            const val = e.target.value.replace(/\D/g, "");
                            handleVariableValueChange("population", val);
                          }}
                          className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                          placeholder="e.g., 1000"
                        />
                      </div>
                    </div>
                  )}
                </>
              )}
            </div>

            <div className="mt-6 flex items-center">
              <button
                onClick={handleAddVariable}
                className="bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-300 flex items-center"
              >
                <i
                  className={`fas ${
                    editVariableId !== null ? "fa-save" : "fa-plus"
                  } mr-2`}
                ></i>
                {editVariableId !== null ? "Update Variable" : "Add Variable"}
              </button>
              {editVariableId !== null && (
                <>
                  <button
                    onClick={handleCancelEdit}
                    className="ml-4 bg-gray-600 hover:bg-gray-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-300 flex items-center"
                  >
                    <i className="fas fa-times mr-2"></i> Cancel
                  </button>
                  <button
                    onClick={() => handleDeleteVariable(editVariableId)}
                    className="ml-4 bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-300 flex items-center"
                  >
                    <i className="fas fa-trash-alt mr-2"></i> Delete
                  </button>
                </>
              )}
              <button
                onClick={openImportModal}
                className="ml-4 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-300 flex items-center"
              >
                <i className="fas fa-file-import mr-2"></i> Import Data
              </button>
              <button
                onClick={openCalculadoraModal}
                className="ml-4 bg-gray-600 hover:bg-gray-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-300 flex items-center"
              >
                {/* Here is your custom SVG icon */}
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 384 512"
                  className="w-5 h-5 fill-current"
                >
                  <path d="M64 0C28.7 0 0 28.7 0 64L0 448c0 35.3 28.7 64 64 64l256 0c35.3 0 64-28.7 64-64l0-384c0-35.3-28.7-64-64-64L64 0zM96 64l192 0c17.7 0 32 14.3 32 32l0 32c0 17.7-14.3 32-32 32L96 160c-17.7 0-32-14.3-32-32l0-32c0-17.7 14.3-32 32-32zm32 160a32 32 0 1 1 -64 0 32 32 0 1 1 64 0zM96 352a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM64 416c0-17.7 14.3-32 32-32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-96 0c-17.7 0-32-14.3-32-32zM192 256a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm32 64a32 32 0 1 1 -64 0 32 32 0 1 1 64 0zm64-64a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm32 64a32 32 0 1 1 -64 0 32 32 0 1 1 64 0zM288 448a32 32 0 1 1 0-64 32 32 0 1 1 0 64z" />
                </svg>
              </button>
            </div>

            {showAlert && (
              <div className="mt-4 bg-green-600 text-white py-2 px-4 rounded-lg flex items-center">
                <i className="fas fa-check-circle mr-2"></i> Variable{" "}
                {editVariableId !== null ? "updated" : "added"} successfully!
              </div>
            )}
            {/* Calculator Modal */}
            {isCalculadoraModalOpen && (
              <div className="fixed inset-0 flex items-start justify-center z-50 pt-8 overflow-y-auto">
                {/* Dim Background with Blur */}
                <div className="absolute inset-0 bg-black/80 backdrop-blur-sm"></div>

                {/* Modal Container */}
                <div className="special-modal-container relative z-50 w-11/12 md:w-1/2 lg:w-2/5 max-h-[90vh] overflow-auto rounded-2xl p-6 mb-8">
                  {/* Header with Icon */}
                  <div className="flex items-center justify-between mb-6 pb-4 special-modal-border border-b">
                    <div className="flex items-center gap-3">
                      <div className="special-modal-header-icon w-10 h-10 rounded-lg flex items-center justify-center">
                        <svg className="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                        </svg>
                      </div>
                      <h2 className="special-modal-title text-2xl font-bold">
                        MEAN ± SD Calculator
                      </h2>
                    </div>
                    <button
                      onClick={closeCalculadoraModal}
                      className="text-gray-400 hover:text-white transition-colors"
                    >
                      <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>

                  {/* Calculator Content */}
                  <CalculadoraEstimativas
                    groupType={groupType}
                    baselineVariables={baselineVariables}
                    outcomesVariables={outcomesVariables}
                    inputValues={inputValues}
                    setInputValues={setInputValues}
                    selectedStudyId={inputValues.selectedStudyId || studyIds[0]}
                  />

                  {/* Footer */}
                  <div className="mt-6 pt-4 border-t border-gray-700 flex justify-end gap-3">
                    <button
                      onClick={closeCalculadoraModal}
                      className="bg-gradient-to-r from-gray-700 to-gray-600 hover:from-gray-600 hover:to-gray-500 text-white font-semibold py-2.5 px-6 rounded-lg transition-all duration-300 shadow-lg hover:shadow-xl"
                    >
                      Close
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* Import Data Modal */}
            {isImportModalOpen && (
              <div className="fixed inset-0 flex items-start justify-center z-50 pt-8 overflow-y-auto">
                {/* Dim Background with Blur */}
                <div className="absolute inset-0 bg-black/80 backdrop-blur-sm"></div>

                {/* Modal Container */}
                <div className="special-modal-container relative z-50 w-11/12 md:w-2/3 lg:w-1/2 max-h-screen overflow-auto rounded-2xl p-6 mb-8">
                  {/* Header with Icon */}
                  <div className="flex items-center justify-between mb-6 pb-4 special-modal-border border-b">
                    <div className="flex items-center gap-3">
                      <div className="special-modal-header-icon w-10 h-10 rounded-lg flex items-center justify-center">
                        <svg className="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                        </svg>
                      </div>
                      <h2 className="special-modal-title text-2xl font-bold">
                        Import Data
                      </h2>
                    </div>
                    <button
                      onClick={closeImportModal}
                      className="text-gray-400 hover:text-white transition-colors"
                    >
                      <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>

                  {/* Select Variable Type & Data Entry Mode */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                      <label className="block font-semibold mb-2 text-gray-300">
                        Variable Type
                      </label>
                      <select
                        value={importVariableType}
                        onChange={handleImportVariableTypeChange}
                        className="
              w-full p-3
              bg-gray-800/50
              border border-gray-600
              rounded-lg
              focus:outline-none focus:ring-2 focus:ring-green-500/50
              text-gray-100
              hover:bg-gray-800
              transition duration-300
            "
                      >
                        <option value="dichotomous">Dichotomous</option>
                        <option value="continuous">Continuous</option>
                        <option value="text">Text</option>
                        {/* Optionally add population_size here if needed:
            <option value="population_size">Population Size</option> */}
                      </select>
                    </div>

                    {groupType === "intervention_comparison" && (
                      <div>
                        <label className="block font-semibold mb-2 text-gray-300">
                          Data Entry Mode
                        </label>
                        <select
                          value={importArmType}
                          onChange={handleImportArmTypeChange}
                          className="
                w-full p-3
                bg-gray-800/50
                border border-gray-600
                rounded-lg
                focus:outline-none focus:ring-2 focus:ring-green-500/50
                text-gray-100
                hover:bg-gray-800
                transition duration-300
              "
                        >
                          <option value="double">Double Arm Data</option>
                          <option value="single">Single Arm Data</option>
                        </select>
                      </div>
                    )}
                  </div>

                  {/* PICO Import Button */}
                  <div className="mt-6">
                    <button
                      onClick={() => setIsPicoMode(!isPicoMode)}
                      className={`w-full py-3 px-4 rounded-lg font-semibold transition duration-300 flex items-center justify-center gap-2 ${
                        isPicoMode
                          ? "bg-purple-600 hover:bg-purple-700 text-white"
                          : "bg-gray-700 hover:bg-gray-600 text-gray-100"
                      }`}
                    >
                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                      </svg>
                      {isPicoMode ? "Exit PICO Mode" : "Import PICO Table"}
                    </button>
                  </div>

                  {/*
        NEW FIELDS:
        For double-arm, user can place population sizes
        that we will treat as "Total" for Intervention or Comparison
      */}
                  {groupType === "intervention_comparison" &&
                    importArmType === "double" && (
                      <div className="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                          <label className="block font-semibold mb-2 text-gray-300">
                            Intervention Population Size
                          </label>
                          <input
                            type="number"
                            value={interventionPopSize}
                            onChange={(e) =>
                              setInterventionPopSize(e.target.value)
                            }
                            className="
                w-full p-3
                bg-gray-800/50
                border border-gray-600
                rounded-lg
                focus:outline-none focus:ring-2 focus:ring-green-500/50
                text-gray-100
                hover:bg-gray-800
                transition duration-300
              "
                            placeholder="Enter intervention population size"
                          />
                        </div>
                        <div>
                          <label className="block font-semibold mb-2 text-gray-300">
                            Comparison Population Size
                          </label>
                          <input
                            type="number"
                            value={comparisonPopSize}
                            onChange={(e) =>
                              setComparisonPopSize(e.target.value)
                            }
                            className="
                w-full p-3
                bg-gray-800/50
                border border-gray-600
                rounded-lg
                focus:outline-none focus:ring-2 focus:ring-green-500/50
                text-gray-100
                hover:bg-gray-800
                transition duration-300
              "
                            placeholder="Enter comparison population size"
                          />
                        </div>
                      </div>
                    )}
                  {groupType === "intervention_comparison" &&
                    importArmType === "single" && (
                      <div className="mt-6">
                        <label className="block font-semibold mb-2 text-gray-300">
                          Intervention Population Size
                        </label>
                        <input
                          type="number"
                          value={interventionPopSize}
                          onChange={(e) =>
                            setInterventionPopSize(e.target.value)
                          }
                          className="
        w-full p-3
        bg-gray-800/50
        border border-gray-600
        rounded-lg
        focus:outline-none focus:ring-2 focus:ring-green-500/50
        text-gray-100
        hover:bg-gray-800
        transition duration-300
      "
                          placeholder="Enter intervention population size"
                        />
                      </div>
                    )}

                  {/* Population Size for Single Arm mode (not intervention_comparison) */}
                  {groupType !== "intervention_comparison" && (
                    <div className="mt-6">
                      <label className="block font-semibold mb-2 text-gray-300">
                        Population Size
                      </label>
                      <input
                        type="number"
                        value={interventionPopSize}
                        onChange={(e) =>
                          setInterventionPopSize(e.target.value)
                        }
                        className="
                          w-full p-3
                          bg-gray-800/50
                          border border-gray-600
                          rounded-lg
                          focus:outline-none focus:ring-2 focus:ring-green-500/50
                          text-gray-100
                          hover:bg-gray-800
                          transition duration-300
                        "
                        placeholder="Enter population size"
                      />
                    </div>
                  )}

                  {/* PICO Input Interface */}
                  {isPicoMode && (
                    <div className="mt-6 p-6 bg-gray-800/50 rounded-lg border border-purple-500/30">
                      <h3 className="text-lg font-bold text-purple-400 mb-4">PICO Table Import</h3>

                      {!picoShowPreview ? (
                        <>
                          {/* Orientation Selector */}
                          <div className="mb-4">
                            <label className="block font-semibold mb-2 text-gray-300">
                              Table Orientation
                            </label>
                            <select
                              value={picoOrientation}
                              onChange={(e) => setPicoOrientation(e.target.value)}
                              className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-gray-100"
                            >
                              <option value="rows">Studies as Rows</option>
                              <option value="columns">Studies as Columns</option>
                            </select>
                          </div>

                          {/* Paste Area */}
                          <div className="mb-4">
                            <label className="block font-semibold mb-2 text-gray-300">
                              Paste PICO Table
                              <span className="text-sm text-gray-400 ml-2">(Can include text before/after table)</span>
                            </label>
                            <textarea
                              value={picoRawText}
                              onChange={(e) => setPicoRawText(e.target.value)}
                              rows={12}
                              placeholder="Paste your PICO table here... (e.g., from Claude with markdown table format)"
                              className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-gray-100 font-mono text-sm"
                            />
                          </div>

                          {/* Intervention Name for Network Mode (only for outcomes) */}
                          {groupType === 'network' && selectedOption === 'outcomes' && (
                            <div className="mb-4">
                              <label className="block font-semibold mb-2 text-gray-300">
                                Intervention Name <span className="text-red-400">*</span>
                                <span className="text-sm text-gray-400 ml-2">(Required for Network mode outcomes)</span>
                              </label>
                              <input
                                type="text"
                                value={picoInterventionName}
                                onChange={(e) => setPicoInterventionName(e.target.value)}
                                placeholder="Enter intervention name (e.g., Drug A, Placebo, etc.)"
                                className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-gray-100"
                              />
                            </div>
                          )}

                          {/* Process Button */}
                          <button
                            onClick={handlePicoProcess}
                            disabled={!picoRawText.trim()}
                            className="w-full py-3 px-4 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-semibold rounded-lg transition duration-300"
                          >
                            Process PICO Table
                          </button>
                        </>
                      ) : (
                        <div>
                          {/* Editable Table Preview with Highlighting */}
                          <PicoTablePreview
                            data={picoTableData}
                            orientation={picoOrientation}
                            studyIds={studyIds}
                            suggestedLabels={suggestedBaselineLabels}
                            variableMappings={picoVariableMappings}
                            studyMappings={picoStudyMappings}
                            onDataChange={setPicoTableData}
                            onVariableMappingChange={setPicoVariableMappings}
                            onStudyMappingChange={setPicoStudyMappings}
                          />

                          {/* Action Buttons */}
                          <div className="mt-6 flex gap-4">
                            <button
                              onClick={() => {
                                setPicoShowPreview(false);
                                setPicoTableData([]);
                                setPicoVariableMappings({});
                                setPicoStudyMappings({});
                              }}
                              className="flex-1 py-3 px-4 bg-gray-600 hover:bg-gray-500 text-white font-semibold rounded-lg transition duration-300"
                            >
                              Back to Edit
                            </button>
                            <button
                              onClick={handlePicoConfirm}
                              className="flex-1 py-3 px-4 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-lg transition duration-300"
                            >
                              Confirm & Add Variables
                            </button>
                          </div>
                        </div>
                      )}
                    </div>
                  )}

                  {/* Text/Paste area for the user's tab-separated data */}
                  {!isPicoMode && (
                  <div className="mt-4">
                    <div className="flex items-center justify-between">
                      <label className="block font-semibold text-gray-300">
                        Enter Data (Tab or ± Separated)
                      </label>

                      {!isSpreadsheetMode ? (
                        <button
                          onClick={() => {
                            const rows = importDataText
                              .trim()
                              .split("\n")
                              .map((line) => line.split(/\t|\s*±\s*/));
                            setSpreadsheetData(rows);
                            setIsSpreadsheetMode(true);
                          }}
                          className="
                bg-gradient-to-r from-blue-600 to-blue-500 hover:from-blue-500 hover:to-blue-400 text-white font-semibold
                py-2 px-4 rounded-lg transition-all duration-300 shadow-lg hover:shadow-xl
              "
                        >
                          Turn into Spreadsheet
                        </button>
                      ) : (
                        <button
                          onClick={() => {
                            const textData = spreadsheetData
                              .map((row) => row.join("\t"))
                              .join("\n");
                            setImportDataText(textData);
                            setIsSpreadsheetMode(false);
                          }}
                          className="
                bg-gradient-to-r from-purple-600 to-purple-500 hover:from-purple-500 hover:to-purple-400 text-white font-semibold
                py-2 px-4 rounded-lg transition-all duration-300 shadow-lg hover:shadow-xl
              "
                        >
                          Switch to Text
                        </button>
                      )}
                    </div>

                    {!isSpreadsheetMode ? (
                      <>
                        <textarea
                          value={importDataText}
                          onChange={(e) => setImportDataText(e.target.value)}
                          onKeyDown={(e) => {
                            // Allow Tab key to insert tab character instead of changing focus
                            if (e.key === 'Tab') {
                              e.preventDefault();
                              const start = e.target.selectionStart;
                              const end = e.target.selectionEnd;
                              const value = e.target.value;

                              // Insert tab at cursor position
                              const newValue = value.substring(0, start) + '\t' + value.substring(end);
                              setImportDataText(newValue);

                              // Move cursor after the inserted tab
                              setTimeout(() => {
                                e.target.selectionStart = e.target.selectionEnd = start + 1;
                              }, 0);
                            }
                          }}
                          rows="5"
                          className="
                w-full mt-2 p-3
                bg-gray-800/50
                border border-gray-600
                rounded-lg
                focus:outline-none focus:ring-2 focus:ring-green-500/50
                text-gray-100
                hover:bg-gray-800
                transition duration-300
                font-mono text-sm
              "
                          placeholder="Enter your data here (e.g.: label, eventIntervention, eventComparison for dichotomous)..."
                        ></textarea>
                        <p className="text-gray-400 mt-2 text-sm">
                          Please enter your data separated by tab or <strong>±</strong> symbol. Each
                          line represents a variable. Examples:
                          <br />
                          <code className="bg-gray-700 px-2 py-1 rounded text-green-400 mr-2">MyOutcome&nbsp;&nbsp;25&nbsp;&nbsp;30</code>
                          or
                          <code className="bg-gray-700 px-2 py-1 rounded text-green-400 ml-2">Age ± 55.3 ± 12.1</code>
                          <br />
                          <span className="text-blue-400 mt-1 inline-block">
                            💡 Tip: Press <kbd className="bg-gray-600 px-2 py-0.5 rounded text-xs">Tab</kbd> key to insert tab character
                          </span>
                        </p>
                      </>
                    ) : (
                      /* If in Spreadsheet Mode, render a table-based editor */
                      <div className="overflow-auto mt-4 max-h-64 border border-[#303030] rounded-lg">
                        <table className="w-full border-collapse relative bg-black bg-opacity-40">
                          <thead className="sticky top-0 bg-[#303030]">
                            <tr>
                              <th className="border border-[#303030] p-1"></th>
                              {spreadsheetData[0] &&
                                spreadsheetData[0].map((_, colIndex) => (
                                  <th
                                    key={colIndex}
                                    className="
                          border border-[#303030] p-1 
                          text-[#303030] relative
                        "
                                    onMouseEnter={() =>
                                      setHoveredColIndex(colIndex)
                                    }
                                    onMouseLeave={() =>
                                      setHoveredColIndex(null)
                                    }
                                  >
                                    {hoveredColIndex === colIndex && (
                                      <div className="absolute inset-0 flex items-center justify-center z-10 space-x-1">
                                        <button
                                          onClick={() => addColumn(colIndex)}
                                          className="bg-green-700 text-white p-1 rounded hover:bg-green-800 pointer-events-auto text-base"
                                          title="Add Column Left"
                                        >
                                          +
                                        </button>
                                        <button
                                          onClick={() => removeColumn(colIndex)}
                                          className="bg-red-700 text-white p-1 rounded hover:bg-red-800 pointer-events-auto text-base"
                                          title="Remove Column"
                                        >
                                          &times;
                                        </button>
                                        <button
                                          onClick={() =>
                                            addColumn(colIndex + 1)
                                          }
                                          className="bg-green-700 text-white p-1 rounded hover:bg-green-800 pointer-events-auto text-base"
                                          title="Add Column Right"
                                        >
                                          +
                                        </button>
                                      </div>
                                    )}
                                  </th>
                                ))}
                            </tr>
                          </thead>
                          <tbody>
                            {spreadsheetData.map((row, rowIndex) => (
                              <tr key={rowIndex}>
                                <td
                                  className="border border-[#303030] p-1 bg-[#303030] relative text-[#303030]"
                                  onMouseEnter={() =>
                                    setHoveredRowIndex(rowIndex)
                                  }
                                  onMouseLeave={() => setHoveredRowIndex(null)}
                                >
                                  {hoveredRowIndex === rowIndex && (
                                    <div className="absolute inset-0 flex flex-col items-center justify-center z-10 space-y-1">
                                      <button
                                        onClick={() => addRow(rowIndex)}
                                        className="bg-green-700 text-white p-1 rounded hover:bg-green-800 pointer-events-auto text-base"
                                        title="Add Row Above"
                                      >
                                        +
                                      </button>
                                      <button
                                        onClick={() => removeRow(rowIndex)}
                                        className="bg-red-700 text-white p-1 rounded hover:bg-red-800 pointer-events-auto text-base"
                                        title="Remove Row"
                                      >
                                        &times;
                                      </button>
                                      <button
                                        onClick={() => addRow(rowIndex + 1)}
                                        className="bg-green-700 text-white p-1 rounded hover:bg-green-800 pointer-events-auto text-base"
                                        title="Add Row Below"
                                      >
                                        +
                                      </button>
                                    </div>
                                  )}
                                </td>
                                {row.map((cell, colIndex) => (
                                  <td
                                    key={colIndex}
                                    className="border border-[#303030] p-1 hover:bg-[#303030] transition duration-150"
                                  >
                                    <input
                                      type="text"
                                      value={cell}
                                      onClick={(e) => e.stopPropagation()}
                                      onFocus={() => {
                                        setFocusedCell({
                                          rowIndex,
                                          colIndex,
                                          value: cell,
                                        });
                                      }}
                                      readOnly
                                      className="
                            w-full bg-black bg-opacity-50 rounded-lg p-2 
                            text-[#303030]
                            focus:outline-none cursor-pointer
                            hover:bg-black hover:bg-opacity-60
                            transition duration-300
                          "
                                    />
                                  </td>
                                ))}
                              </tr>
                            ))}
                          </tbody>
                        </table>

                        {/* Cell Overlay Editor */}
                        {focusedCell && (
                          <div className="fixed inset-0 flex items-start justify-center z-50 pt-8 overflow-y-auto">
                            <div
                              className="absolute inset-0 bg-black opacity-80"
                              onClick={() => setFocusedCell(null)}
                            ></div>
                            <div
                              className="
                    bg-gradient-to-br from-gray-900 via-[#303030] to-gray-900
                    text-[#303030] p-6 rounded-xl z-50 w-11/12 md:w-2/3 lg:w-1/2
                    border border-[#303030] shadow-xl
                  "
                            >
                              <h2 className="text-2xl font-bold mb-4 text-[#303030] uppercase">
                                Edit Cell
                              </h2>
                              <textarea
                                value={focusedCell.value}
                                onChange={(e) => {
                                  const newValue = e.target.value;
                                  setFocusedCell({
                                    ...focusedCell,
                                    value: newValue,
                                  });
                                  const newSpreadsheetData = [
                                    ...spreadsheetData,
                                  ];
                                  newSpreadsheetData[focusedCell.rowIndex][
                                    focusedCell.colIndex
                                  ] = newValue;
                                  setSpreadsheetData(newSpreadsheetData);
                                }}
                                rows="6"
                                className="
                      w-full p-3 
                      bg-black bg-opacity-50
                      border border-[#303030]
                      rounded-lg 
                      focus:outline-none focus:ring-2 focus:ring-[#303030]
                      text-[#303030]
                      hover:bg-opacity-70
                      transition duration-300
                    "
                              ></textarea>
                              <div className="mt-6 flex justify-end space-x-4">
                                <button
                                  onClick={() => setFocusedCell(null)}
                                  className="
                        bg-[#303030] hover:bg-[#303030] text-white font-semibold 
                        py-2 px-4 rounded-lg transition duration-300
                        neon-button
                      "
                                >
                                  Close
                                </button>
                              </div>
                            </div>
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                  )}

                  {/* Footer Buttons: Close & Add Dataset */}
                  <div className="mt-6 pt-4 border-t border-gray-700 flex justify-end gap-3">
                    <button
                      onClick={closeImportModal}
                      className="bg-gradient-to-r from-gray-700 to-gray-600 hover:from-gray-600 hover:to-gray-500 text-white font-semibold py-2.5 px-6 rounded-lg transition-all duration-300 shadow-lg hover:shadow-xl"
                    >
                      Close
                    </button>
                    <button
                      onClick={handleAddDataset}
                      className="bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 text-white font-semibold py-2.5 px-6 rounded-lg transition-all duration-300 flex items-center gap-2 shadow-lg hover:shadow-xl"
                    >
                      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                      </svg>
                      Add Dataset
                    </button>
                  </div>
                </div>
              </div>
            )}


            <div className="mt-8">
              <h2 className="text-xl font-bold mb-4">
                Variables for {inputValues.selectedStudyId || studyIds[0]}
              </h2>
              {getDisplayedVariables().length > 0 ? (
                <div className="overflow-x-auto">
                  <table className="w-full table-auto border-collapse">
                    <thead>
                      <tr>
                        <th className="border-b-2 border-gray-700 px-4 py-2 text-left">
                          Label
                        </th>
                        <th className="border-b-2 border-gray-700 px-4 py-2 text-left">
                          Type
                        </th>
                        {groupType === "network" && (
                          <th className="border-b-2 border-gray-700 px-4 py-2 text-left">
                            Intervention
                          </th>
                        )}
                        <th className="border-b-2 border-gray-700 px-4 py-2 text-left">
                          Value
                        </th>
                        <th className="border-b-2 border-gray-700 px-4 py-2 text-left"></th>
                      </tr>
                    </thead>
                    <tbody>
                      {getDisplayedVariables().map((variable, index) => (
                        <tr
                          key={variable.id}
                          className={`hover:bg-gray-800 ${
                            index % 2 === 0 ? "bg-gray-900" : "bg-gray-800"
                          } cursor-pointer`}
                          draggable="true"
                          onDragStart={(e) => handleDragStart(e, variable.id)}
                          onDragOver={(e) => handleDragOver(e, variable.id)}
                          onDrop={handleDrop}
                          onDragEnd={handleDragEnd}
                          onClick={() => handleEditVariable(variable.id)}
                        >
                          <td className="px-4 py-2">{variable.label}</td>
                          <td className="px-4 py-2 capitalize">
                            {variable.type || "Text"}
                          </td>
                          {groupType === "network" && (
                            <td className="px-4 py-2">
                              {variable.interventionName || (
                                <span className="text-gray-500 italic">
                                  Baseline
                                </span>
                              )}
                            </td>
                          )}
                          <td className="px-4 py-2 whitespace-pre-wrap break-all max-w-xs">
                            {(() => {
                              // SINGLE placeholder baseline variable
                              if (variable.isSinglePlaceholder) {
                                return (
                                  variable.value || (
                                    <span className="text-gray-500">
                                      Missing
                                    </span>
                                  )
                                );
                              }

                              // INTERVENTION + COMPARISON LOGIC
                              if (groupType === "intervention_comparison") {
                                if (variable.armType === "double") {
                                  // ---------- DOUBLE-ARM ----------
                                  if (variable.type === "dichotomous") {
                                    // Show "Intervention: events / total", "Comparison: events / total"
                                    const iEvents =
                                      variable.value.intervention || "";
                                    const iTotal =
                                      variable.value.interventionTotal || "";
                                    const cEvents =
                                      variable.value.comparison || "";
                                    const cTotal =
                                      variable.value.comparisonTotal || "";

                                    return (
                                      <>
                                        <span className="font-semibold">
                                          {groupNames.interventionName}:
                                        </span>{" "}
                                        {iEvents !== "" ? (
                                          iEvents
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {" / "}
                                        {iTotal !== "" ? (
                                          iTotal
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        ,{" "}
                                        <span className="font-semibold">
                                          {groupNames.comparisonName}:
                                        </span>{" "}
                                        {cEvents !== "" ? (
                                          cEvents
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {" / "}
                                        {cTotal !== "" ? (
                                          cTotal
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                      </>
                                    );
                                  } else if (variable.type === "continuous") {
                                    // Show "Intervention: mean / sd / total", "Comparison: mean / sd / total"
                                    const iMean =
                                      variable.value.intervention.mean || "";
                                    const iSd =
                                      variable.value.intervention.sd || "";
                                    const iTotal =
                                      variable.value.interventionTotal || "";
                                    const cMean =
                                      variable.value.comparison.mean || "";
                                    const cSd =
                                      variable.value.comparison.sd || "";
                                    const cTotal =
                                      variable.value.comparisonTotal || "";

                                    return (
                                      <>
                                        <span className="font-semibold">
                                          {groupNames.interventionName}:
                                        </span>{" "}
                                        {iMean !== "" ? (
                                          `Mean=${iMean}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {iSd !== "" ? (
                                          `SD=${iSd}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {iTotal !== "" ? (
                                          `Total=${iTotal}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        ;{" "}
                                        <span className="font-semibold">
                                          {groupNames.comparisonName}:
                                        </span>{" "}
                                        {cMean !== "" ? (
                                          `Mean=${cMean}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {cSd !== "" ? (
                                          `SD=${cSd}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {cTotal !== "" ? (
                                          `Total=${cTotal}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                      </>
                                    );
                                  } else if (variable.type === "text") {
                                    // Show "Intervention: text / total", "Comparison: text / total"
                                    const iText =
                                      variable.value.intervention || "";
                                    const iTotal =
                                      variable.value.interventionTotal || "";
                                    const cText =
                                      variable.value.comparison || "";
                                    const cTotal =
                                      variable.value.comparisonTotal || "";

                                    return (
                                      <>
                                        <span className="font-semibold">
                                          {groupNames.interventionName}:
                                        </span>{" "}
                                        {iText !== "" ? (
                                          iText
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {iTotal !== "" ? (
                                          `Total=${iTotal}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        ;{" "}
                                        <span className="font-semibold">
                                          {groupNames.comparisonName}:
                                        </span>{" "}
                                        {cText !== "" ? (
                                          cText
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {cTotal !== "" ? (
                                          `Total=${cTotal}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                      </>
                                    );
                                  } else if (
                                    variable.type === "population_size"
                                  ) {
                                    // Double-arm population => Intervention vs. Comparison
                                    const iPop =
                                      variable.value.interventionPop || "";
                                    const cPop =
                                      variable.value.comparisonPop || "";
                                    return (
                                      <>
                                        <span className="font-semibold">
                                          {groupNames.interventionName}:
                                        </span>{" "}
                                        {iPop !== "" ? (
                                          iPop
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        ,{" "}
                                        <span className="font-semibold">
                                          {groupNames.comparisonName}:
                                        </span>{" "}
                                        {cPop !== "" ? (
                                          cPop
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                      </>
                                    );
                                  }
                                } else {
                                  // ---------- SINGLE-ARM in an intervention+comparison environment ----------
                                  if (variable.type === "dichotomous") {
                                    // events / total
                                    const e = variable.value.events || "";
                                    const t = variable.value.total || "";
                                    return (
                                      <>
                                        {e !== "" ? (
                                          e
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {" / "}
                                        {t !== "" ? (
                                          t
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                      </>
                                    );
                                  } else if (variable.type === "continuous") {
                                    const m = variable.value.mean || "";
                                    const s = variable.value.sd || "";
                                    const t = variable.value.total || "";
                                    return (
                                      <>
                                        {m !== "" ? (
                                          `Mean=${m}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {s !== "" ? (
                                          `SD=${s}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {", "}
                                        {t !== "" ? (
                                          `Total=${t}`
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                      </>
                                    );
                                  } else if (variable.type === "text") {
                                    // text, total
                                    const txt = variable.value.text || "";
                                    const t = variable.value.total || "";
                                    return (
                                      <>
                                        {txt !== "" ? (
                                          txt
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                        {t !== "" ? `, Total=${t}` : null}
                                      </>
                                    );
                                  } else if (
                                    variable.type === "population_size"
                                  ) {
                                    // Single-arm population
                                    const pop = variable.value.population || "";
                                    return (
                                      <>
                                        <span className="font-semibold">
                                          Population:
                                        </span>{" "}
                                        {pop !== "" ? (
                                          pop
                                        ) : (
                                          <span className="text-gray-500">
                                            Missing
                                          </span>
                                        )}
                                      </>
                                    );
                                  }
                                }
                              } else {
                                // ---------- SINGLE-ARM (Intervention only) ----------
                                if (variable.type === "dichotomous") {
                                  // events / total
                                  const e = variable.value.events || "";
                                  const t = variable.value.total || "";
                                  return (
                                    <>
                                      {e !== "" ? (
                                        e
                                      ) : (
                                        <span className="text-gray-500">
                                          Missing
                                        </span>
                                      )}
                                      {" / "}
                                      {t !== "" ? (
                                        t
                                      ) : (
                                        <span className="text-gray-500">
                                          Missing
                                        </span>
                                      )}
                                    </>
                                  );
                                } else if (variable.type === "continuous") {
                                  const m = variable.value.mean || "";
                                  const s = variable.value.sd || "";
                                  const t = variable.value.total || "";
                                  return (
                                    <>
                                      {m !== "" ? (
                                        `Mean=${m}`
                                      ) : (
                                        <span className="text-gray-500">
                                          Missing
                                        </span>
                                      )}
                                      {", "}
                                      {s !== "" ? (
                                        `SD=${s}`
                                      ) : (
                                        <span className="text-gray-500">
                                          Missing
                                        </span>
                                      )}
                                      {", "}
                                      {t !== "" ? (
                                        `Total=${t}`
                                      ) : (
                                        <span className="text-gray-500">
                                          Missing
                                        </span>
                                      )}
                                    </>
                                  );
                                } else if (variable.type === "text") {
                                  const txt = variable.value.text || "";
                                  const t = variable.value.total || "";
                                  return (
                                    <>
                                      {txt !== "" ? (
                                        txt
                                      ) : (
                                        <span className="text-gray-500">
                                          Missing
                                        </span>
                                      )}
                                      {t !== "" ? `, Total=${t}` : null}
                                    </>
                                  );
                                } else if (
                                  variable.type === "population_size"
                                ) {
                                  const pop = variable.value.population || "";
                                  return (
                                    <>
                                      <span className="font-semibold">
                                        Population:
                                      </span>{" "}
                                      {pop !== "" ? (
                                        pop
                                      ) : (
                                        <span className="text-gray-500">
                                          Missing
                                        </span>
                                      )}
                                    </>
                                  );
                                }
                              }

                              // fallback if nothing else matched
                              return (
                                <span className="text-gray-500">Missing</span>
                              );
                            })()}
                          </td>
                          <td className="px-4 py-2 text-center w-20 whitespace-nowrap">
                            {/* EDIT BUTTON (SVG) */}
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                handleEditVariable(variable.id);
                              }}
                              // Shrink margin and add a bit of padding if you want smaller clickable space
                              className="text-blue-500 hover:text-blue-700 mr-1 p-1"
                            >
                              <svg
                                xmlns="http://www.w3.org/2000/svg"
                                viewBox="0 0 512 512"
                                // Change from w-5 h-5 to w-4 h-4 (or even w-3 h-3 if you prefer)
                                className="w-4 h-4 fill-current"
                              >
                                <path d="M471.6 21.7c-21.9-21.9-57.3-21.9-79.2 0L362.3 51.7l97.9 97.9 30.1-30.1c21.9-21.9 21.9-57.3 0-79.2L471.6 21.7zm-299.2 220c-6.1 6.1-10.8 13.6-13.5 21.9l-29.6 88.8c-2.9 8.6-.6 18.1 5.8 24.6s15.9 8.7 24.6 5.8l88.8-29.6c8.2-2.7 15.7-7.4 21.9-13.5L437.7 172.3 339.7 74.3 172.4 241.7zM96 64C43 64 0 107 0 160L0 416c0 53 43 96 96 96l256 0c53 0 96-43 96-96l0-96c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7-14.3 32-32 32L96 448c-17.7 0-32-14.3-32-32l0-256c0-17.7 14.3-32 32-32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L96 64z" />
                              </svg>
                            </button>

                            {/* DELETE BUTTON (SVG) */}
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                handleDeleteVariable(variable.id);
                              }}
                              // Again, shrink spacing and/or padding as needed
                              className="text-red-500 hover:text-red-700 p-1"
                            >
                              <svg
                                xmlns="http://www.w3.org/2000/svg"
                                viewBox="0 0 448 512"
                                className="w-4 h-4 fill-current"
                              >
                                <path d="M135.2 17.7L128 32 32 32C14.3 32 0 46.3 0 64S14.3 96 32 96l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0-7.2-14.3C307.4 6.8 296.3 0 284.2 0L163.8 0c-12.1 0-23.2 6.8-28.6 17.7zM416 128L32 128 53.2 467c1.6 25.3 22.6 45 47.9 45l245.8 0c25.3 0 46.3-19.7 47.9-45L416 128z" />
                              </svg>
                            </button>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              ) : (
                <p className="text-gray-400">
                  No variables added for this study.
                </p>
              )}
            </div>

            <div className="flex flex-col md:flex-row justify-between mt-8 space-y-4 md:space-y-0">
              <button
                onClick={onBack}
                className="w-full md:w-auto bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
              >
                <i className="fas fa-arrow-left mr-2"></i> Back
              </button>
              <button
                onClick={onPreview}
                className="w-full md:w-auto bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
              >
                Preview <i className="fas fa-eye ml-2"></i>
              </button>
            </div>
          </div>
        );
      }

      // Existing suggestions
      const suggestedBaselineLabels = [
        "Population",
        "Intervention #1",
        "Intervention #2/Control group",
        "All outcomes",
        "Primary outcomes",
        "Secondary outcomes",
        "Outcome assessment dates",
        "Timing (Start to End Date)",
        "Type of Study/Study design",
        "Setting (Ambulatory, Inpatient...)",
        "Institution and department",
        "Country",
      ];

      function PreviewScreen({
        studyIds,
        baselineVariables,
        outcomesVariables,
        groupType,
        groupNames,
        onBack,
        onBackupDownload,
      }) {
        const [previewOption, setPreviewOption] = useState("baseline");
        const [missingDataRepresentation, setMissingDataRepresentation] =
          useState("");
        const [customMissingValue, setCustomMissingValue] = useState("");
        const [weightVariable, setWeightVariable] = useState("");
        const [isWeightOpen, setIsWeightOpen] = useState(false);
        const [sortOrder, setSortOrder] = useState("fixed_alphabetical");
        // NEW CODE START: State and logic for Google Drive modal
        const [isDriveModalOpen, setIsDriveModalOpen] = useState(false);
        const [driveLinks, setDriveLinks] = useState({
          "Backup Files": [],
          "Spreadsheet Files": [],
          "Variable Files": [],
        });
        const [selectedDriveCategory, setSelectedDriveCategory] =
          useState("Backup Files");
        const [newDriveLink, setNewDriveLink] = useState("");

        useEffect(() => {
          const handleClickOutside = (event) => {
            if (isWeightOpen && !event.target.closest(".relative")) {
              setIsWeightOpen(false);
            }
          };
          document.addEventListener("click", handleClickOutside);
          return () =>
            document.removeEventListener("click", handleClickOutside);
        }, [isWeightOpen]);

        // Load links from localStorage on mount
        useEffect(() => {
          const storedLinks = JSON.parse(
            localStorage.getItem("driveLinks")
          ) || {
            "Backup Files": [],
            "Spreadsheet Files": [],
            "Variable Files": [],
          };
          setDriveLinks(storedLinks);
        }, []);

        const openDriveModal = () => {
          setIsDriveModalOpen(true);
        };

        const closeDriveModal = () => {
          setIsDriveModalOpen(false);
        };

        const handleAddDriveLink = () => {
          if (!newDriveLink.trim()) return;
          const updatedLinks = { ...driveLinks };
          updatedLinks[selectedDriveCategory].push(newDriveLink.trim());
          setDriveLinks(updatedLinks);
          setNewDriveLink("");

          // Save to localStorage
          localStorage.setItem("driveLinks", JSON.stringify(updatedLinks));
        };

const handlePicoDownload = () => {
  // Combine suggested labels, ensuring no duplicates
  const allBaselineLabels = [...new Set([...suggestedBaselineLabels, ...additionalBaselineSuggestions])];

  // Special labels for outcomes parsing
  const specialOutcomeLabels = ["All outcomes", "Primary Outcomes", "Secondary Outcomes"];

  // Prepare worksheet data
  const ws_data = [];

  // Row 1: Study # and numbers 1 to n
  const row1 = ["Study #"];
  studyIds.forEach((_, idx) => row1.push(idx + 1));
  ws_data.push(row1);

  // Row 2: Study ID and the IDs
  const row2 = ["Study ID", ...studyIds];
  ws_data.push(row2);

  // Helper to check if a label has data in at least one study
  const hasDataForLabel = (label) => {
    return studyIds.some((studyId) => {
      const studyVars = baselineVariables[studyId] || [];
      const variable = studyVars.find((v) => v.label === label);
      if (!variable) return false;
      const formattedValue = formatVariableValue(variable);
      return formattedValue && formattedValue !== getMissingValue();
    });
  };

  // Filter normal labels (exclude special outcomes for now, and omit if no data)
  const normalLabels = allBaselineLabels
    .filter(label => !specialOutcomeLabels.includes(label))
    .filter(hasDataForLabel);

  // Add rows for normal baseline labels (length 1 + studyIds.length)
  normalLabels.forEach((label) => {
    const row = [label];
    studyIds.forEach((studyId) => {
      const studyVars = baselineVariables[studyId] || [];
      const variable = studyVars.find((v) => v.label === label);
      const formattedValue = variable ? formatVariableValue(variable) : getMissingValue();
      row.push(formattedValue);
    });
    ws_data.push(row);
  });

  // Now add the special outcome labels at the bottom, only if they have data
  specialOutcomeLabels.forEach((label, idx) => {
    // Check if this special label has data in at least one study
    const hasData = studyIds.some((studyId) => {
      const textValue = getTextValue(studyId, label, baselineVariables);
      return textValue && textValue.trim() !== "";
    });

    if (!hasData) return; // Omit if no data for this label

    // First, add the full text row for the label (length 1 + studyIds.length)
    const fullRow = [label];
    studyIds.forEach((studyId) => {
      const textValue = getTextValue(studyId, label, baselineVariables);
      fullRow.push(textValue || getMissingValue());
    });
    ws_data.push(fullRow);

    // Add the "COUNTING [LABEL] RECURRENCE:" header row in the last column
    const headerRow = Array(1 + studyIds.length).fill(""); // Empties for col1 and study columns
    headerRow.push(`COUNTING ${label.toUpperCase()} RECURRENCE:`); // Place in count column
    ws_data.push(headerRow);

    // Collect unique outcomes across all studies for this label
    const uniqueOutcomes = new Set();
    studyIds.forEach((studyId) => {
      const textValue = getTextValue(studyId, label, baselineVariables);
      if (textValue) {
        const outcomes = textValue.split(/,\s*/).map((o) => o.trim()).filter(Boolean);
        outcomes.forEach((o) => uniqueOutcomes.add(o));
      }
    });

    // Sort unique outcomes alphabetically
    const sortedUnique = Array.from(uniqueOutcomes).sort((a, b) => a.localeCompare(b));

    // For each unique outcome, add a row with TRUE/FALSE and count at end (length 1 + studyIds.length + 1)
    sortedUnique.forEach((outcome) => {
      const outcomeRow = [outcome];
      let trueCount = 0;
      studyIds.forEach((studyId) => {
        const textValue = getTextValue(studyId, label, baselineVariables);
        let hasOutcome = false;
        if (textValue) {
          const outcomes = textValue.split(/,\s*/).map((o) => o.trim());
          hasOutcome = outcomes.includes(outcome);
        }
        outcomeRow.push(hasOutcome ? "TRUE" : "FALSE");
        if (hasOutcome) trueCount++;
      });
      outcomeRow.push(trueCount); // Add count at end
      ws_data.push(outcomeRow);
    });

    // Add an empty row after this outcomes type block (except after the last one, but since user said after types, add after each)
    const emptyRow = Array(1 + studyIds.length + 1).fill(""); // Full empty row including count column
    ws_data.push(emptyRow);
  });

  // Create workbook and sheet
  const wb = XLSX.utils.book_new();
  const ws = XLSX.utils.aoa_to_sheet(ws_data);
  XLSX.utils.book_append_sheet(wb, ws, "PICO Table");

  // Generate filename with timestamp
  const timestamp = new Date().toISOString().slice(0, 19).replace("T", "_").replace(/:/g, "-");
  const filename = `PICO_Table_${timestamp}.xlsx`;

  // Download
  XLSX.writeFile(wb, filename);
};

const formatVariableValue = (variable) => {
  if (!variable) return getMissingValue();

  if (variable.isSinglePlaceholder || variable.type === "text") {
    return variable.value || getMissingValue();
  } else if (variable.type === "dichotomous") {
    if (groupType === "intervention_comparison" && variable.armType === "double") {
      return `${variable.value.intervention || getMissingValue()}/${variable.value.interventionTotal || getMissingValue()} / ${variable.value.comparison || getMissingValue()}/${variable.value.comparisonTotal || getMissingValue()}`;
    } else {
      return `${variable.value.events || getMissingValue()}/${variable.value.total || getMissingValue()}`;
    }
  } else if (variable.type === "continuous") {
    if (groupType === "intervention_comparison" && variable.armType === "double") {
      return `${variable.value.intervention.mean || getMissingValue()} ± ${variable.value.intervention.sd || getMissingValue()} / ${variable.value.comparison.mean || getMissingValue()} ± ${variable.value.comparison.sd || getMissingValue()}`;
    } else {
      return `${variable.value.mean || getMissingValue()} ± ${variable.value.sd || getMissingValue()}`;
    }
  } else if (variable.type === "population_size") {
    if (groupType === "intervention_comparison" && variable.armType === "double") {
      return `${variable.value.interventionPop || getMissingValue()} / ${variable.value.comparisonPop || getMissingValue()}`;
    } else {
      return variable.value.population || getMissingValue();
    }
  }
  return getMissingValue();
};

const getTextValue = (studyId, label, variablesToUse) => {
  const studyVars = variablesToUse[studyId] || [];
  const variable = studyVars.find((v) => v.label === label);
  return variable && variable.type === "text" ? variable.value : "";
};
        // New state variables for the modal and options
        const [isDownloadModalOpen, setIsDownloadModalOpen] = useState(false);
        const [selectedFormat, setSelectedFormat] = useState("RevMan");
        const [selectedPopulationVariable, setSelectedPopulationVariable] =
          useState("");
        const [onlyCompleteStudies, setOnlyCompleteStudies] = useState(false);
        const [selectedCovariate, setSelectedCovariate] = useState(""); // For NETWORK mode MetaInsight covariate

        function getMissingValue() {
          if (missingDataRepresentation === "custom") {
            return customMissingValue;
          }
          return missingDataRepresentation;
        }

        function copyDataAsList() {
          // Build the data based on current preview option
          let baselineDataset = null;
          let outcomesDataset = null;

          if (previewOption === "baseline" || previewOption === "both" || previewOption === "recurrent") {
            baselineDataset = buildDataRows(baselineVariables, previewOption === "recurrent", sortOrder, true);
          }
          if (previewOption === "outcomes" || previewOption === "both" || previewOption === "recurrent") {
            outcomesDataset = buildDataRows(outcomesVariables, previewOption === "recurrent", sortOrder, false);
          }

          let outputText = "";

          // Helper function to format a single value for list output
          const formatValueForList = (variable, columnName, value) => {
            if (!value || value === getMissingValue()) return null;

            // For network mode, columnName doesn't include intervention name
            if (groupType === "network") {
              if (variable.type === "dichotomous") {
                const events = variable.value.events;
                const total = variable.value.total;
                return `${events || getMissingValue()}/${total || getMissingValue()}`;
              } else if (variable.type === "continuous") {
                const mean = variable.value.mean;
                const sd = variable.value.sd;
                const total = variable.value.total;
                return `Mean=${mean || getMissingValue()}, SD=${sd || getMissingValue()}, N=${total || getMissingValue()}`;
              } else if (variable.type === "text") {
                return variable.value || getMissingValue();
              } else if (variable.type === "population_size") {
                return `N=${variable.value.population || getMissingValue()}`;
              }
            }

            return value;
          };

          // Helper function to format a row of data for a study
          const formatStudyData = (studyId, variableLabel, variablesToUse, isNetwork = false) => {
            const studyVars = variablesToUse[studyId] || [];
            const variables = studyVars.filter(v => v.label === variableLabel);

            if (variables.length === 0) return null;

            const parts = [];

            if (isNetwork) {
              // Network mode: group by intervention
              variables.forEach(variable => {
                if (!variable.interventionName) return;

                let valueStr = "";
                if (variable.type === "dichotomous") {
                  valueStr = `${variable.value.events || getMissingValue()}/${variable.value.total || getMissingValue()}`;
                } else if (variable.type === "continuous") {
                  const mean = variable.value.mean || getMissingValue();
                  const sd = variable.value.sd || getMissingValue();
                  const total = variable.value.total || getMissingValue();
                  valueStr = `${mean}±${sd}, N=${total}`;
                } else if (variable.type === "text") {
                  valueStr = variable.value || getMissingValue();
                } else if (variable.type === "population_size") {
                  valueStr = `N=${variable.value.population || getMissingValue()}`;
                }

                parts.push(`${valueStr} (${variable.interventionName})`);
              });
            } else if (groupType === "intervention_comparison") {
              // Double arm mode
              variables.forEach(variable => {
                if (variable.armType === "double") {
                  if (variable.type === "dichotomous") {
                    const intEvents = variable.value.intervention || getMissingValue();
                    const intTotal = variable.value.interventionTotal || getMissingValue();
                    const compEvents = variable.value.comparison || getMissingValue();
                    const compTotal = variable.value.comparisonTotal || getMissingValue();
                    parts.push(`${intEvents}/${intTotal} (${groupNames.interventionName}); ${compEvents}/${compTotal} (${groupNames.comparisonName})`);
                  } else if (variable.type === "continuous") {
                    const intMean = variable.value.intervention.mean || getMissingValue();
                    const intSD = variable.value.intervention.sd || getMissingValue();
                    const intTotal = variable.value.interventionTotal || getMissingValue();
                    const compMean = variable.value.comparison.mean || getMissingValue();
                    const compSD = variable.value.comparison.sd || getMissingValue();
                    const compTotal = variable.value.comparisonTotal || getMissingValue();
                    parts.push(`${intMean}±${intSD}, N=${intTotal} (${groupNames.interventionName}); ${compMean}±${compSD}, N=${compTotal} (${groupNames.comparisonName})`);
                  } else if (variable.type === "text") {
                    const intText = variable.value.intervention || getMissingValue();
                    const compText = variable.value.comparison || getMissingValue();
                    parts.push(`${intText} (${groupNames.interventionName}); ${compText} (${groupNames.comparisonName})`);
                  } else if (variable.type === "population_size") {
                    const intPop = variable.value.interventionPop || getMissingValue();
                    const compPop = variable.value.comparisonPop || getMissingValue();
                    parts.push(`N=${intPop} (${groupNames.interventionName}); N=${compPop} (${groupNames.comparisonName})`);
                  }
                } else if (variable.armType === "single") {
                  // Single arm within double arm mode
                  if (variable.type === "dichotomous") {
                    parts.push(`${variable.value.events || getMissingValue()}/${variable.value.total || getMissingValue()}`);
                  } else if (variable.type === "continuous") {
                    const mean = variable.value.mean || getMissingValue();
                    const sd = variable.value.sd || getMissingValue();
                    const total = variable.value.total || getMissingValue();
                    parts.push(`${mean}±${sd}, N=${total}`);
                  } else if (variable.type === "text") {
                    parts.push(variable.value || getMissingValue());
                  } else if (variable.type === "population_size") {
                    parts.push(`N=${variable.value.population || getMissingValue()}`);
                  }
                }
              });
            } else {
              // Single arm mode (intervention only)
              variables.forEach(variable => {
                if (variable.type === "dichotomous") {
                  parts.push(`${variable.value.events || getMissingValue()}/${variable.value.total || getMissingValue()}`);
                } else if (variable.type === "continuous") {
                  const mean = variable.value.mean || getMissingValue();
                  const sd = variable.value.sd || getMissingValue();
                  const total = variable.value.total || getMissingValue();
                  parts.push(`${mean}±${sd}, N=${total}`);
                } else if (variable.type === "text") {
                  parts.push(variable.value || getMissingValue());
                } else if (variable.type === "population_size") {
                  parts.push(`N=${variable.value.population || getMissingValue()}`);
                }
              });
            }

            return parts.length > 0 ? parts.join("; ") : null;
          };

          // Process baseline data
          if (baselineDataset && baselineDataset.allVariableLabels.length > 0) {
            baselineDataset.allVariableLabels.forEach(label => {
              outputText += `${label} (BASELINE):\n`;
              studyIds.forEach(studyId => {
                const studyData = formatStudyData(studyId, label, baselineVariables, groupType === "network");
                if (studyData) {
                  outputText += `- ${studyId}: ${studyData}\n`;
                }
              });
              outputText += "\n";
            });
          }

          // Process outcomes data
          if (outcomesDataset && outcomesDataset.allVariableLabels.length > 0) {
            outcomesDataset.allVariableLabels.forEach(label => {
              outputText += `${label} (OUTCOME):\n`;
              studyIds.forEach(studyId => {
                const studyData = formatStudyData(studyId, label, outcomesVariables, groupType === "network");
                if (studyData) {
                  outputText += `- ${studyId}: ${studyData}\n`;
                }
              });
              outputText += "\n";
            });
          }

          // Copy to clipboard
          if (outputText) {
            navigator.clipboard.writeText(outputText).then(() => {
              alert("Data copied to clipboard as list format!");
            }).catch(err => {
              console.error("Failed to copy to clipboard:", err);
              alert("Failed to copy to clipboard. Please check browser permissions.");
            });
          } else {
            alert("No data to copy!");
          }
        }

        function getWeightVariableOptions() {
          const variableLabelsSet = new Set();

          const variablesList = [baselineVariables, outcomesVariables];

          variablesList.forEach((variablesToUse) => {
            Object.values(variablesToUse).forEach((studyVars) => {
              studyVars.forEach((variable) => {
                // Only consider numerical variables, *including population_size*
                if (
                  variable.type === "dichotomous" ||
                  variable.type === "continuous" ||
                  variable.type === "population_size" // ADDED population_size HERE
                ) {
                  variableLabelsSet.add(variable.label);
                }
              });
            });
          });

          return Array.from(variableLabelsSet);
        }

        const removeDriveLink = (category, linkIndex) => {
          const updatedLinks = { ...driveLinks };
          updatedLinks[category].splice(linkIndex, 1); // Remove the link at that index
          setDriveLinks(updatedLinks);
          localStorage.setItem("driveLinks", JSON.stringify(updatedLinks)); // Re-save to localStorage
        };

        function getPopulationVariableOptions() {
          const variableLabelsSet = new Set();

          // Collect the relevant datasets based on previewOption
          let datasets = [];
          if (previewOption === "baseline") {
            datasets.push(baselineVariables);
          } else if (previewOption === "outcomes") {
            datasets.push(outcomesVariables);
          } else if (
            previewOption === "both" ||
            previewOption === "recurrent"
          ) {
            datasets.push(baselineVariables, outcomesVariables);
          }

          // Gather variable labels for dichotomous, continuous, or population_size
          datasets.forEach((variablesToUse) => {
            Object.values(variablesToUse).forEach((studyVars) => {
              studyVars.forEach((variable) => {
                if (
                  variable.type === "dichotomous" ||
                  variable.type === "continuous" ||
                  variable.type === "population_size"
                ) {
                  variableLabelsSet.add(variable.label);
                }
              });
            });
          });

          // Convert to an array
          let allLabels = Array.from(variableLabelsSet);

          // If "Total Patients" already exists, remove it
          const indexTP = allLabels.indexOf("Total Patients");
          if (indexTP !== -1) {
            allLabels.splice(indexTP, 1);
          }

          // Insert "Total Patients" at the front
          allLabels.unshift("Total Patients");

          return allLabels;
        }

        function getAllVariableLabels() {
          const variableLabelsSet = new Set();

          // If user selected Baseline tab
          if (selectedOption === "baseline") {
            // Gather all baseline variables
            Object.values(baselineVariables).forEach((studyVars) => {
              studyVars.forEach((variable) => {
                variableLabelsSet.add(variable.label);
              });
            });

            // Include the built-in suggestions for baseline
            suggestedBaselineLabels.forEach((lbl) =>
              variableLabelsSet.add(lbl)
            );
            additionalBaselineSuggestions.forEach((lbl) =>
              variableLabelsSet.add(lbl)
            );
          } else if (selectedOption === "outcomes") {
            // Gather all outcomes variables
            Object.values(outcomesVariables).forEach((studyVars) => {
              studyVars.forEach((variable) => {
                variableLabelsSet.add(variable.label);
              });
            });
          }

          // Convert our Set to an array and return
          return Array.from(variableLabelsSet);
        }

        const openDownloadFolderModal = () => {
          setIsDownloadModalOpen(true);
          const options = getPopulationVariableOptions();
          if (options.length > 0) {
            setSelectedPopulationVariable(options[0]);
          } else {
            setSelectedPopulationVariable("");
          }
        };

        const closeDownloadFolderModal = () => {
          setIsDownloadModalOpen(false);
        };
        const additionalBaselineSuggestions = [
          "Population Size", // dichotomous
          "Male", // dichotomous
          "Female", // dichotomous
          "Age", // continuous
          "Follow-Up", // continuous
        ];
        // Snippet 2: Modify buildDataRows to support sorting
        function buildDataRows(
          variablesToUse,
          filterRecurrent = false,
          sortOrder = "addition",
          isBaseline = false
        ) {
          const variableLabelsOrdered = [];
          const addLabelIfNew = (label) => {
            if (!variableLabelsOrdered.includes(label)) {
              variableLabelsOrdered.push(label);
            }
          };
          const variableSubgroups = {};

          // Collect variable definitions and counts
          const variableDefinitions = {};
          const variableCounts = {};

          // Count occurrences of each variable label
          studyIds.forEach((studyId) => {
            const studyVars = variablesToUse[studyId] || [];
            const labelsInStudy = new Set();

            studyVars.forEach((variable) => {
              addLabelIfNew(variable.label);
              labelsInStudy.add(variable.label);

              if (!variableDefinitions[variable.label]) {
                variableDefinitions[variable.label] = {
                  types: new Set(),
                  armTypes: new Set(),
                  subgroups: new Set(),
                };
              }
              variableDefinitions[variable.label].types.add(variable.type);
              variableDefinitions[variable.label].armTypes.add(
                variable.armType
              );
            });

            labelsInStudy.forEach((label) => {
              variableCounts[label] = (variableCounts[label] || 0) + 1;
            });
          });

          // Filter variables if 'filterRecurrent' = true
          let filteredVariableLabels = variableLabelsOrdered;
          if (filterRecurrent) {
            filteredVariableLabels = filteredVariableLabels.filter(
              (label) => variableCounts[label] >= 2
            );
          }

          if (sortOrder === "alphabetical") {
            filteredVariableLabels.sort((a, b) => a.localeCompare(b));
          } else if (sortOrder === "fixed_alphabetical" && isBaseline) {
            const allFixed = [
              ...suggestedBaselineLabels,
              ...additionalBaselineSuggestions,
            ];
            const fixedLabels = allFixed.filter((label) =>
              filteredVariableLabels.includes(label)
            );
            const otherLabels = filteredVariableLabels
              .filter((label) => !allFixed.includes(label))
              .sort((a, b) => a.localeCompare(b));
            filteredVariableLabels = [...fixedLabels, ...otherLabels];
          } else if (sortOrder === "fixed_alphabetical" && !isBaseline) {
            filteredVariableLabels.sort((a, b) => a.localeCompare(b));
          }

          // Build subgroups for each label (the "column headings")
          filteredVariableLabels.forEach((label) => {
            const definition = variableDefinitions[label];
            const types = Array.from(definition.types);
            const armTypes = Array.from(definition.armTypes);
            const subgroups = new Set();

            types.forEach((type) => {
              if (type === "dichotomous") {
                if (groupType === "intervention_comparison") {
                  if (armTypes.includes("double")) {
                    // double-arm => events + total for both arms
                    subgroups.add(`${groupNames.interventionName} Events`);
                    subgroups.add(`${groupNames.interventionName} Total`);
                    subgroups.add(`${groupNames.comparisonName} Events`);
                    subgroups.add(`${groupNames.comparisonName} Total`);
                  }
                  if (armTypes.includes("single")) {
                    // single-arm => events + total
                    subgroups.add("Events");
                    subgroups.add("Total");
                  }
                } else if (groupType === "network") {
                  // Network mode: events + total (Intervention is a data column, not a subgroup)
                  subgroups.add("Events");
                  subgroups.add("Total");
                } else {
                  // single-arm only (groupType === 'intervention'): events + total
                  subgroups.add("Events");
                  subgroups.add("Total");
                }
              } else if (type === "continuous") {
                if (groupType === "intervention_comparison") {
                  if (armTypes.includes("double")) {
                    // double-arm => mean / sd / total for both arms
                    subgroups.add(`${groupNames.interventionName} Mean`);
                    subgroups.add(`${groupNames.interventionName} SD`);
                    subgroups.add(`${groupNames.interventionName} Total`);
                    subgroups.add(`${groupNames.comparisonName} Mean`);
                    subgroups.add(`${groupNames.comparisonName} SD`);
                    subgroups.add(`${groupNames.comparisonName} Total`);
                  }
                  if (armTypes.includes("single")) {
                    // single-arm => mean / sd / total
                    subgroups.add("Mean");
                    subgroups.add("SD");
                    subgroups.add("Total");
                  }
                } else if (groupType === "network") {
                  // Network mode: mean / sd / total (Intervention is a data column, not a subgroup)
                  subgroups.add("Mean");
                  subgroups.add("SD");
                  subgroups.add("Total");
                } else {
                  // single-arm only => mean / sd / total
                  subgroups.add("Mean");
                  subgroups.add("SD");
                  subgroups.add("Total");
                }
              } else if (type === "text") {
                // No "total" column for text
                if (suggestedBaselineLabels.includes(label)) {
                  // single column => label
                  subgroups.add("");
                } else {
                  if (groupType === "intervention_comparison") {
                    if (armTypes.includes("double")) {
                      subgroups.add(`${groupNames.interventionName} Text`);
                      subgroups.add(`${groupNames.comparisonName} Text`);
                    }
                    if (armTypes.includes("single")) {
                      // single-arm text => "Text Value"
                      subgroups.add("Text Value");
                    }
                  } else if (groupType === "network") {
                    // Network mode: text value (Intervention is a data column, not a subgroup)
                    subgroups.add("");
                  } else {
                    // single-arm only => single column => label
                    subgroups.add("");
                  }
                }
              } else if (type === "population_size") {
                // for sample sizes
                if (groupType === "intervention_comparison") {
                  if (armTypes.includes("double")) {
                    subgroups.add(`${groupNames.interventionName} Pop`);
                    subgroups.add(`${groupNames.comparisonName} Pop`);
                  }
                  if (armTypes.includes("single")) {
                    subgroups.add("Population");
                  }
                } else if (groupType === "network") {
                  // Network mode: population (Intervention is a data column, not a subgroup)
                  subgroups.add("Population");
                } else {
                  subgroups.add("Population");
                }
              }

              // ignore any other custom types not shown
            });

            variableSubgroups[label] = Array.from(subgroups);
          });

          const allVariableLabels = filteredVariableLabels;
          // ---------------------------------------------------
          // Build the data rows
          // ---------------------------------------------------
          let dataRows = [];

          // NETWORK MODE: Create multiple rows per study (one per intervention)
          if (groupType === "network") {
            studyIds.forEach((studyId) => {
              const studyVars = variablesToUse[studyId] || [];

              // Group variables by intervention name
              const interventionGroups = {};
              const baselineVars = {}; // Variables without intervention (baseline)

              studyVars.forEach((variable) => {
                const label = variable.label;
                if (!filteredVariableLabels.includes(label)) return;

                // Single placeholder or variables without intervention name
                if (variable.isSinglePlaceholder || !variable.interventionName) {
                  baselineVars[label] = variable;
                } else {
                  const intName = variable.interventionName;
                  if (!interventionGroups[intName]) {
                    interventionGroups[intName] = {};
                  }
                  interventionGroups[intName][label] = variable;
                }
              });

              // Create one row per intervention
              Object.keys(interventionGroups).forEach((intName) => {
                const varData = {};

                // Add baseline variables to this row
                Object.keys(baselineVars).forEach((label) => {
                  const variable = baselineVars[label];
                  if (variable.isSinglePlaceholder) {
                    varData[label] = variable.value || getMissingValue();
                  } else if (variable.type === "text") {
                    varData[label] = variable.value.text || variable.value || getMissingValue();
                  } else if (variable.type === "population_size") {
                    varData[`${label}_Population`] = variable.value.population || getMissingValue();
                  }
                });

                // Add intervention-specific variables
                Object.keys(interventionGroups[intName]).forEach((label) => {
                  const variable = interventionGroups[intName][label];

                  if (variable.type === "dichotomous") {
                    varData[`${label}_Events`] = variable.value.events || getMissingValue();
                    varData[`${label}_Total`] = variable.value.total || getMissingValue();
                  } else if (variable.type === "continuous") {
                    varData[`${label}_Mean`] = variable.value.mean || getMissingValue();
                    varData[`${label}_SD`] = variable.value.sd || getMissingValue();
                    varData[`${label}_Total`] = variable.value.total || getMissingValue();
                  } else if (variable.type === "text") {
                    varData[label] = variable.value.text || variable.value || getMissingValue();
                  } else if (variable.type === "population_size") {
                    varData[`${label}_Population`] = variable.value.population || getMissingValue();
                  }
                });

                dataRows.push({
                  studyId,
                  intervention: intName,
                  variables: varData
                });
              });
            });
          }
          // INTERVENTION & INTERVENTION_COMPARISON MODES: Keep original logic (one row per study)
          else {
            dataRows = studyIds.map((studyId) => {
              const studyVars = variablesToUse[studyId] || [];
              const varData = {};

              studyVars.forEach((variable) => {
                const label = variable.label;
                if (!filteredVariableLabels.includes(label)) return;

                const subs = variableSubgroups[label];

                // Handle single placeholder
                if (variable.isSinglePlaceholder) {
                  varData[label] = variable.value || getMissingValue();
                  return;
                }

                // If we are in an intervention_comparison setup:
                if (groupType === "intervention_comparison") {
                if (variable.armType === "double") {
                  // ---------- DOUBLE-ARM ----------
                  if (variable.type === "dichotomous") {
                    varData[`${label}_${groupNames.interventionName} Events`] =
                      variable.value.intervention || getMissingValue();
                    varData[`${label}_${groupNames.interventionName} Total`] =
                      variable.value.interventionTotal || getMissingValue();
                    varData[`${label}_${groupNames.comparisonName} Events`] =
                      variable.value.comparison || getMissingValue();
                    varData[`${label}_${groupNames.comparisonName} Total`] =
                      variable.value.comparisonTotal || getMissingValue();
                  } else if (variable.type === "continuous") {
                    varData[`${label}_${groupNames.interventionName} Mean`] =
                      variable.value.intervention.mean || getMissingValue();
                    varData[`${label}_${groupNames.interventionName} SD`] =
                      variable.value.intervention.sd || getMissingValue();
                    varData[`${label}_${groupNames.interventionName} Total`] =
                      variable.value.interventionTotal || getMissingValue();

                    varData[`${label}_${groupNames.comparisonName} Mean`] =
                      variable.value.comparison.mean || getMissingValue();
                    varData[`${label}_${groupNames.comparisonName} SD`] =
                      variable.value.comparison.sd || getMissingValue();
                    varData[`${label}_${groupNames.comparisonName} Total`] =
                      variable.value.comparisonTotal || getMissingValue();
                  } else if (variable.type === "text") {
                    varData[`${label}_${groupNames.interventionName} Text`] =
                      variable.value.intervention || getMissingValue();
                    varData[`${label}_${groupNames.comparisonName} Text`] =
                      variable.value.comparison || getMissingValue();
                  } else if (variable.type === "population_size") {
                    varData[`${label}_${groupNames.interventionName} Pop`] =
                      variable.value.interventionPop || getMissingValue();
                    varData[`${label}_${groupNames.comparisonName} Pop`] =
                      variable.value.comparisonPop || getMissingValue();
                  }
                } else {
                  // ---------- SINGLE-ARM in an intervention+comparison environment ----------
                  if (variable.type === "dichotomous") {
                    // we expect variable.value = { events, total }
                    varData[`${label}_Events`] =
                      variable.value.events || getMissingValue();
                    varData[`${label}_Total`] =
                      variable.value.total || getMissingValue();
                  } else if (variable.type === "continuous") {
                    varData[`${label}_Mean`] =
                      variable.value.mean || getMissingValue();
                    varData[`${label}_SD`] =
                      variable.value.sd || getMissingValue();
                    varData[`${label}_Total`] =
                      variable.value.total || getMissingValue();
                  } else if (variable.type === "text") {
                    // single-arm text => variable.value = { text } (or just a string)
                    varData[`${label}_Text Value`] =
                      variable.value.text ||
                      variable.value ||
                      getMissingValue();
                  } else if (variable.type === "population_size") {
                    // single-arm population => variable.value = { population }
                    varData[`${label}_Population`] =
                      variable.value.population || getMissingValue();
                  }
                }
              } else {
                // ---------- SINGLE-ARM INTERVENTION MODE ----------
                if (variable.type === "dichotomous") {
                  varData[`${label}_Events`] = variable.value.events || getMissingValue();
                  varData[`${label}_Total`] = variable.value.total || getMissingValue();
                } else if (variable.type === "continuous") {
                  varData[`${label}_Mean`] = variable.value.mean || getMissingValue();
                  varData[`${label}_SD`] = variable.value.sd || getMissingValue();
                  varData[`${label}_Total`] = variable.value.total || getMissingValue();
                } else if (variable.type === "text") {
                  varData[label] = variable.value.text || variable.value || getMissingValue();
                } else if (variable.type === "population_size") {
                  varData[`${label}_Population`] = variable.value.population || getMissingValue();
                }
              }
              });

              return { studyId, variables: varData };
            });
          } // End of else (non-network modes)

          // Flatten out all subgroups => create final column names
          const allVariableColumns = [];
          allVariableLabels.forEach((label) => {
            const subs = variableSubgroups[label];
            if (subs.length > 0) {
              subs.forEach((sub) => {
                allVariableColumns.push(sub ? `${label}_${sub}` : label);
              });
            } else {
              // if no subgroups, just label
              allVariableColumns.push(label);
            }
          });

          return {
            dataRows,
            allVariableLabels,
            allVariableColumns,
            variableSubgroups,
          };
        }
        function computeWeightedAverages(
          dataRows,
          variableSubgroups,
          weightVariable
        ) {
          const weightedAverages = {};

          // Early return if no weight variable
          if (!weightVariable) {
            return weightedAverages;
          }

          // Check if user specifically picked "Population Size" as the weight
          const isPopulationSizeWeight =
            weightVariable.toLowerCase() === "population size";

          // If not population-size weighting, fall back to your old subgroups approach
          const weightSubgroups =
            !isPopulationSizeWeight && variableSubgroups[weightVariable]
              ? variableSubgroups[weightVariable]
              : [""];

          // Build a fallback list of weight columns for the "old" approach
          const weightColumnNames = weightSubgroups.map((subgroup) => {
            return subgroup ? `${weightVariable}_${subgroup}` : weightVariable;
          });

          const columnSums = {};
          const columnWeightSums = {};

          dataRows.forEach((row) => {
            // If NOT population-size weighting, gather 'weights'
            let weights = {};
            if (!isPopulationSizeWeight) {
              weightColumnNames.forEach((weightColumn) => {
                const weightValue = parseFloat(row.variables[weightColumn]);
                weights[weightColumn] = isNaN(weightValue) ? null : weightValue;
              });
            }

            // Accumulate sums for each numeric column
            Object.keys(row.variables).forEach((columnName) => {
              const value = parseFloat(row.variables[columnName]);
              if (isNaN(value)) return; // Skip non-numerical

              let weight = null;

              if (isPopulationSizeWeight) {
                // "Population Size" weighting logic:
                // We try to look up the matching "..._Total" column
                const parts = columnName.split("_");
                const labelPart = parts[0];
                let subgroupPart = parts.slice(1).join("_");
                subgroupPart = subgroupPart.replace(
                  /(mean|sd|events|text)/i,
                  "Total"
                );
                const totalColumnName = subgroupPart.trim()
                  ? `${labelPart}_${subgroupPart}`
                  : `${labelPart}_Total`;
                const weightRaw = parseFloat(row.variables[totalColumnName]);
                if (!isNaN(weightRaw)) {
                  weight = weightRaw;
                }
              } else {
                // Subgroup-based weighting logic
                let subgroup = "";
                const labelParts = columnName.split("_");
                if (labelParts.length > 1) {
                  subgroup = labelParts.slice(1).join("_");
                }

                let weightColumn = "";
                if (weightSubgroups.includes(subgroup)) {
                  weightColumn = subgroup
                    ? `${weightVariable}_${subgroup}`
                    : weightVariable;
                } else if (weightSubgroups.includes("Total")) {
                  weightColumn = `${weightVariable}_Total`;
                } else {
                  weightColumn = weightColumnNames[0];
                }
                weight = weights[weightColumn];
              }

              if (weight !== null && !isNaN(weight)) {
                columnSums[columnName] =
                  (columnSums[columnName] || 0) + value * weight;
                columnWeightSums[columnName] =
                  (columnWeightSums[columnName] || 0) + weight;
              }
            });
          });

          // Now compute the actual weighted averages, skipping unwanted columns
          Object.keys(columnSums).forEach((columnName) => {
            // 1) Skip if it’s one of the weight columns themselves
            if (weightColumnNames.includes(columnName)) {
              weightedAverages[columnName] = getMissingValue();
              return;
            }

            // 2) Skip if the column name contains "Total"
            if (columnName.toLowerCase().includes("total")) {
              weightedAverages[columnName] = getMissingValue();
              return;
            }

            // 3) Skip if the column starts with the label of the weight variable
            //    (e.g. weightVariable="Population Size" => skip "Population Size_Intervention" columns)
            if (
              columnName.toLowerCase().startsWith(weightVariable.toLowerCase())
            ) {
              weightedAverages[columnName] = getMissingValue();
              return;
            }

            // Compute average if there's a non-zero weight sum
            const sum = columnSums[columnName];
            const wSum = columnWeightSums[columnName];
            if (wSum > 0) {
              weightedAverages[columnName] = sum / wSum;
            }
          });

          return weightedAverages;
        }

        let combinedDataRows = [];
        let baselineDataset = null;
        let outcomesDataset = null;
        let weightedAverages = {};

        if (
          previewOption === "baseline" ||
          previewOption === "both" ||
          previewOption === "recurrent"
        ) {
          baselineDataset = buildDataRows(
            baselineVariables,
            previewOption === "recurrent",
            sortOrder,
            true // isBaseline=true
          );
        }
        if (
          previewOption === "outcomes" ||
          previewOption === "both" ||
          previewOption === "recurrent"
        ) {
          outcomesDataset = buildDataRows(
            outcomesVariables,
            previewOption === "recurrent",
            sortOrder,
            false // isBaseline=false
          );
        }
        if (previewOption === "both" || previewOption === "recurrent") {
          combinedDataRows = studyIds.map((studyId) => {
            const baselineRow = baselineDataset.dataRows.find(
              (row) => row.studyId === studyId
            ) || { variables: {} };
            const outcomesRow = outcomesDataset.dataRows.find(
              (row) => row.studyId === studyId
            ) || { variables: {} };
            return {
              studyId,
              variables: {
                ...baselineRow.variables,
                ...outcomesRow.variables,
              },
            };
          });

          if (weightVariable) {
            weightedAverages = computeWeightedAverages(
              combinedDataRows,
              {
                ...baselineDataset.variableSubgroups,
                ...outcomesDataset.variableSubgroups,
              },
              weightVariable
            );
          }
        } else {
          const dataset =
            previewOption === "baseline" ? baselineDataset : outcomesDataset;
          if (dataset && weightVariable) {
            weightedAverages = computeWeightedAverages(
              dataset.dataRows,
              dataset.variableSubgroups,
              weightVariable
            );
          }
        }

        const handleSave = () => {
          // Determine naming based on groupType and groupNames
          let groupPart;
          if (groupType === "intervention") {
            groupPart = groupNames.interventionName;
          } else if (groupType === "intervention_comparison") {
            groupPart = `${groupNames.interventionName}_x_${groupNames.comparisonName}`;
          } else {
            groupPart = "Data"; // Fallback if unexpected groupType
          }

          if (previewOption === "both" || previewOption === "recurrent") {
            const wb = XLSX.utils.book_new();

            // Create data array for the sheet
            const ws_data = [];

            // Extract label arrays and subgroups from baseline/outcomes
            const baselineLabels = baselineDataset.allVariableLabels;
            const outcomesLabels = outcomesDataset.allVariableLabels;
            const baselineSubgroups = baselineDataset.variableSubgroups;
            const outcomesSubgroups = outcomesDataset.variableSubgroups;

            // 1) FIRST HEADER ROW — for "Study ID", "Intervention" (if network), and then "BASELINE" and "OUTCOMES"
            const header1 = groupType === "network" ? ["Study ID", "Intervention"] : ["Study ID"];
            const header1Merges = [];
            let colIndex = groupType === "network" ? 2 : 1;

            // Count total columns for Baseline
            let totalBaselineColumns = 0;
            baselineLabels.forEach((label) => {
              const subgroups = baselineSubgroups[label];
              const colspan = subgroups.length || 1;
              totalBaselineColumns += colspan;
            });

            // Count total columns for Outcomes
            let totalOutcomesColumns = 0;
            outcomesLabels.forEach((label) => {
              const subgroups = outcomesSubgroups[label];
              const colspan = subgroups.length || 1;
              totalOutcomesColumns += colspan;
            });

            // If baseline has columns, add “BASELINE” spanning those columns
            if (baselineLabels.length > 0) {
              header1.push("BASELINE");
              const startCol = colIndex;
              const endCol = startCol + totalBaselineColumns - 1;
              header1Merges.push({
                s: { r: 0, c: startCol },
                e: { r: 0, c: endCol },
              });
              // Fill with null placeholders
              for (let i = 1; i < totalBaselineColumns; i++) {
                header1.push(null);
              }
              colIndex = endCol + 1;
            }

            // If outcomes has columns, add “OUTCOMES” spanning those columns
            if (outcomesLabels.length > 0) {
              header1.push("OUTCOMES");
              const startCol = colIndex;
              const endCol = startCol + totalOutcomesColumns - 1;
              header1Merges.push({
                s: { r: 0, c: startCol },
                e: { r: 0, c: endCol },
              });
              // Fill with null placeholders
              for (let i = 1; i < totalOutcomesColumns; i++) {
                header1.push(null);
              }
              colIndex = endCol + 1;
            }
            ws_data.push(header1);

            // 2) SECOND HEADER ROW — variable labels
            const header2 = groupType === "network" ? ["", ""] : [""];
            const header2Merges = [];
            colIndex = groupType === "network" ? 2 : 1;

            // Baseline variable labels
            baselineLabels.forEach((label) => {
              const subgroups = baselineSubgroups[label];
              const colspan = subgroups.length || 1;
              header2.push(label);
              if (colspan > 1) {
                header2Merges.push({
                  s: { r: 1, c: colIndex },
                  e: { r: 1, c: colIndex + colspan - 1 },
                });
                // Fill with null placeholders
                for (let i = 1; i < colspan; i++) {
                  header2.push(null);
                }
              }
              colIndex += colspan;
            });

            // Outcomes variable labels
            outcomesLabels.forEach((label) => {
              const subgroups = outcomesSubgroups[label];
              const colspan = subgroups.length || 1;
              header2.push(label);
              if (colspan > 1) {
                header2Merges.push({
                  s: { r: 1, c: colIndex },
                  e: { r: 1, c: colIndex + colspan - 1 },
                });
                // Fill with null placeholders
                for (let i = 1; i < colspan; i++) {
                  header2.push(null);
                }
              }
              colIndex += colspan;
            });
            ws_data.push(header2);

            // 3) THIRD HEADER ROW — subgroups
            const header3 = groupType === "network" ? ["", ""] : [""];
            const variableColumns = [];

            // Build subgroups for Baseline
            baselineLabels.forEach((label) => {
              const subgroups = baselineSubgroups[label];
              if (subgroups.length > 0) {
                subgroups.forEach((sub) => {
                  header3.push(sub);
                  variableColumns.push(sub ? `${label}_${sub}` : label);
                });
              } else {
                header3.push("");
                variableColumns.push(label);
              }
            });

            // Build subgroups for Outcomes
            outcomesLabels.forEach((label) => {
              const subgroups = outcomesSubgroups[label];
              if (subgroups.length > 0) {
                subgroups.forEach((sub) => {
                  header3.push(sub);
                  variableColumns.push(sub ? `${label}_${sub}` : label);
                });
              } else {
                header3.push("");
                variableColumns.push(label);
              }
            });
            ws_data.push(header3);

            // 4) DATA ROWS
            combinedDataRows.forEach((row) => {
              const rowValues = groupType === "network"
                ? [row.studyId, row.intervention || ""]
                : [row.studyId];
              variableColumns.forEach((columnName) => {
                const cellValue =
                  row.variables[columnName] || getMissingValue();
                rowValues.push(cellValue);
              });
              ws_data.push(rowValues);
            });

            // 5) WEIGHTED AVERAGES ROW
            if (Object.keys(weightedAverages).length > 0) {
              const avgRow = groupType === "network"
                ? ["Weighted Averages", ""]
                : ["Weighted Averages"];
              variableColumns.forEach((columnName) => {
                const avgValue = weightedAverages[columnName];
                avgRow.push(
                  avgValue !== undefined ? avgValue : getMissingValue()
                );
              });
              ws_data.push(avgRow);
            }

            // Convert the array-of-arrays (AOA) to a Sheet
            const ws = XLSX.utils.aoa_to_sheet(ws_data);

            // Merge 'Study ID' and 'Intervention' (if network) across the three header rows
            const combinedMerges = [
              ...header1Merges,
              ...header2Merges,
              { s: { r: 0, c: 0 }, e: { r: 2, c: 0 } },
            ];

            // If network mode, also merge "Intervention" column
            if (groupType === "network") {
              combinedMerges.push({ s: { r: 0, c: 1 }, e: { r: 2, c: 1 } });
            }

            ws["!merges"] = combinedMerges;

            // Append to Workbook
            XLSX.utils.book_append_sheet(wb, ws, "Combined_Data");

            // Create filename with date/time + groupPart
            const timestamp = new Date();
            const formattedTimestamp = timestamp
              .toISOString()
              .slice(0, 19)
              .replace("T", "_")
              .replace(/:/g, "-");

            const filename = `Combined_Data_${groupPart}_${formattedTimestamp}.xlsx`;
            XLSX.writeFile(wb, filename);
          } else {
            // Handling just baseline OR outcomes
            const dataset =
              previewOption === "baseline" ? baselineDataset : outcomesDataset;
            const dataLabel =
              previewOption === "baseline" ? "Baseline_Data" : "Outcomes_Data";

            const wb = XLSX.utils.book_new();
            const ws_data = [];

            // 1) FIRST HEADER ROW
            const header1 = groupType === "network" ? ["Study ID", "Intervention"] : ["Study ID"];
            const header1Merges = [];
            let colIndex = groupType === "network" ? 2 : 1;

            // Count total columns
            let totalColumns = 0;
            dataset.allVariableLabels.forEach((label) => {
              const subgroups = dataset.variableSubgroups[label];
              const colspan = subgroups.length || 1;
              totalColumns += colspan;
            });

            if (dataset.allVariableLabels.length > 0) {
              // E.g. “BASELINE” or “OUTCOMES” spanning the columns
              header1.push(previewOption.toUpperCase());
              const startCol = colIndex;
              const endCol = startCol + totalColumns - 1;
              header1Merges.push({
                s: { r: 0, c: startCol },
                e: { r: 0, c: endCol },
              });
              // Fill with null placeholders
              for (let i = 1; i < totalColumns; i++) {
                header1.push(null);
              }
            } else {
              // If no columns, just merge “Study ID”
              header1Merges.push({ s: { r: 0, c: 0 }, e: { r: 2, c: 0 } });
            }
            ws_data.push(header1);

            // 2) SECOND HEADER ROW — variable labels
            const header2 = groupType === "network" ? ["", ""] : [""];
            const header2Merges = [];
            colIndex = groupType === "network" ? 2 : 1;

            dataset.allVariableLabels.forEach((label) => {
              const subgroups = dataset.variableSubgroups[label];
              const colspan = subgroups.length || 1;
              header2.push(label);
              if (colspan > 1) {
                header2Merges.push({
                  s: { r: 1, c: colIndex },
                  e: { r: 1, c: colIndex + colspan - 1 },
                });
                for (let i = 1; i < colspan; i++) {
                  header2.push(null);
                }
              }
              colIndex += colspan;
            });
            ws_data.push(header2);

            // 3) THIRD HEADER ROW — subgroups
            const header3 = groupType === "network" ? ["", ""] : [""];
            const variableColumns = [];

            dataset.allVariableLabels.forEach((label) => {
              const subgroups = dataset.variableSubgroups[label];
              if (subgroups.length > 0) {
                subgroups.forEach((sub) => {
                  header3.push(sub);
                  variableColumns.push(sub ? `${label}_${sub}` : label);
                });
              } else {
                header3.push("");
                variableColumns.push(label);
              }
            });
            ws_data.push(header3);

            // 4) DATA ROWS
            dataset.dataRows.forEach((row) => {
              const rowValues = groupType === "network"
                ? [row.studyId, row.intervention || ""]
                : [row.studyId];
              variableColumns.forEach((columnName) => {
                const cellValue =
                  row.variables[columnName] || getMissingValue();
                rowValues.push(cellValue);
              });
              ws_data.push(rowValues);
            });

            // 5) WEIGHTED AVERAGES ROW
            if (Object.keys(weightedAverages).length > 0) {
              const avgRow = groupType === "network"
                ? ["Weighted Averages", ""]
                : ["Weighted Averages"];
              variableColumns.forEach((columnName) => {
                const avgValue = weightedAverages[columnName];
                avgRow.push(
                  avgValue !== undefined ? avgValue : getMissingValue()
                );
              });
              ws_data.push(avgRow);
            }

            // Convert to a sheet and merge "Study ID" and "Intervention" (if network)
            const ws = XLSX.utils.aoa_to_sheet(ws_data);
            const baseMerges = [
              ...header1Merges,
              ...header2Merges,
              { s: { r: 0, c: 0 }, e: { r: 2, c: 0 } },
            ];

            // If network mode, also merge "Intervention" column
            if (groupType === "network") {
              baseMerges.push({ s: { r: 0, c: 1 }, e: { r: 2, c: 1 } });
            }

            ws["!merges"] = baseMerges;

            XLSX.utils.book_append_sheet(wb, ws, dataLabel);

            // Construct filename (e.g. “Baseline_Data_Intervention_YYYY-MM-DD_HH-MM-SS.xlsx”)
            const timestamp = new Date();
            const formattedTimestamp = timestamp
              .toISOString()
              .slice(0, 19)
              .replace("T", "_")
              .replace(/:/g, "-");

            const filename = `${dataLabel}_${groupPart}_${formattedTimestamp}.xlsx`;
            XLSX.writeFile(wb, filename);
          }

          // Finally, try opening any "Spreadsheet Files" links in localStorage
          try {
            const storedData =
              JSON.parse(localStorage.getItem("driveLinks")) || {};
            const spreadsheetLinks = storedData["Spreadsheet Files"] || [];
            spreadsheetLinks.forEach((link) => {
              window.open(link, "_blank");
            });
          } catch (err) {
            console.error("Error opening Spreadsheet Files links:", err);
          }
        };

        function getVariableCountsFromDatasets(datasets) {
          const variableCounts = {};

          studyIds.forEach((studyId) => {
            let studyVars = [];

            datasets.forEach((dataset) => {
              studyVars = studyVars.concat(dataset[studyId] || []);
            });

            const labelsInStudy = new Set();

            studyVars.forEach((variable) => {
              labelsInStudy.add(variable.label);
            });

            labelsInStudy.forEach((label) => {
              variableCounts[label] = (variableCounts[label] || 0) + 1;
            });
          });

          return variableCounts;
        }

        function buildRowUsingVariableTotals(
          studyId,
          targetVar,
          format,
          groupNames,
          groupType
        ) {
          // 'row' will store the resulting CSV fields for this study
          let row = {};

          // Always store the Study ID
          if (format === "RevMan") {
            row["Study ID"] = studyId;
          } else {
            // For RStudio and Stata, often the column is 'study'
            row.study = studyId;
          }

          // Distinguish by type + arm
          if (
            groupType === "intervention_comparison" &&
            targetVar.armType === "double"
          ) {
            // DOUBLE-ARM
            if (targetVar.type === "dichotomous") {
              const iEvents = targetVar.value.intervention || "";
              const iTotal = targetVar.value.interventionTotal || "";
              const cEvents = targetVar.value.comparison || "";
              const cTotal = targetVar.value.comparisonTotal || "";

              if (format === "RevMan") {
                row["Intervention Events"] = iEvents;
                row["Intervention Total"] = iTotal;
                row["Comparison Events"] = cEvents;
                row["Comparison Total"] = cTotal;
              } else if (format === "RStudio") {
                row.events_inter = iEvents;
                row.n_inter = iTotal;
                row.events_control = cEvents;
                row.n_control = cTotal;
              } else if (format === "Stata") {
                // For Stata, typical approach is yes/no
                const interYes = parseFloat(iEvents) || 0;
                const interTot = parseFloat(iTotal) || 0;
                const interNo = interTot - interYes;

                const compYes = parseFloat(cEvents) || 0;
                const compTot = parseFloat(cTotal) || 0;
                const compNo = compTot - compYes;

                row.yes_inter = interYes;
                row.no_inter = interNo;
                row.yes_control = compYes;
                row.no_control = compNo;
              }
            } else if (targetVar.type === "continuous") {
              const iMean = (targetVar.value.intervention || {}).mean || "";
              const iSd = (targetVar.value.intervention || {}).sd || "";
              const iTotal = targetVar.value.interventionTotal || "";

              const cMean = (targetVar.value.comparison || {}).mean || "";
              const cSd = (targetVar.value.comparison || {}).sd || "";
              const cTotal = targetVar.value.comparisonTotal || "";

              if (format === "RevMan") {
                row["Intervention Mean"] = iMean;
                row["Intervention SD"] = iSd;
                row["Intervention Total"] = iTotal;
                row["Comparison Mean"] = cMean;
                row["Comparison SD"] = cSd;
                row["Comparison Total"] = cTotal;
              } else if (format === "RStudio") {
                row.mean_inter = iMean;
                row.sd_inter = iSd;
                row.n_inter = iTotal;
                row.mean_control = cMean;
                row.sd_control = cSd;
                row.n_control = cTotal;
              } else if (format === "Stata") {
                row.n_inter = iTotal;
                row.mean_inter = iMean;
                row.sd_inter = iSd;
                row.n_control = cTotal;
                row.mean_control = cMean;
                row.sd_control = cSd;
              }
            } else if (targetVar.type === "text") {
              const iText = targetVar.value.intervention || "";
              const iTotal = targetVar.value.interventionTotal || "";
              const cText = targetVar.value.comparison || "";
              const cTotal = targetVar.value.comparisonTotal || "";

              if (format === "RevMan") {
                row["Intervention Text"] = iText;
                row["Intervention Total"] = iTotal;
                row["Comparison Text"] = cText;
                row["Comparison Total"] = cTotal;
              } else if (format === "RStudio") {
                row.intervention_text = iText;
                row.intervention_total = iTotal;
                row.comparison_text = cText;
                row.comparison_total = cTotal;
              } else if (format === "Stata") {
                row.intervention_text = iText;
                row.intervention_total = iTotal;
                row.comparison_text = cText;
                row.comparison_total = cTotal;
              }
            } else if (targetVar.type === "population_size") {
              const iPop = targetVar.value.interventionPop || "";
              const cPop = targetVar.value.comparisonPop || "";

              if (format === "RevMan") {
                row["Intervention Population Size"] = iPop;
                row["Comparison Population Size"] = cPop;
              } else if (format === "RStudio") {
                row.population_inter = iPop;
                row.population_control = cPop;
              } else if (format === "Stata") {
                row.population_inter = iPop;
                row.population_control = cPop;
              }
            }
          } else if (
            groupType === "intervention_comparison" &&
            targetVar.armType === "single"
          ) {
            // SINGLE-ARM in an intervention+comparison environment
            if (targetVar.type === "dichotomous") {
              const e = targetVar.value.events || "";
              const t = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Events"] = e;
                row["Intervention Total"] = t;
              } else if (format === "RStudio") {
                row.events_inter = e;
                row.n_inter = t;
              } else if (format === "Stata") {
                const yes = parseFloat(e) || 0;
                const tot = parseFloat(t) || 0;
                const no = tot - yes;
                row.yes_inter = yes;
                row.no_inter = no;
                row.total_inter = tot;
              }
            } else if (targetVar.type === "continuous") {
              const m = targetVar.value.mean || "";
              const s = targetVar.value.sd || "";
              const t = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Mean"] = m;
                row["Intervention SD"] = s;
                row["Intervention Total"] = t;
              } else if (format === "RStudio") {
                row.mean_inter = m;
                row.sd_inter = s;
                row.n_inter = t;
              } else if (format === "Stata") {
                row.n_inter = t;
                row.mean_inter = m;
                row.sd_inter = s;
              }
            } else if (targetVar.type === "text") {
              const txt = targetVar.value.text || "";
              const t = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Text"] = txt;
                row["Intervention Total"] = t;
              } else if (format === "RStudio") {
                row.text = txt;
                row.total = t;
              } else if (format === "Stata") {
                row.text = txt;
                row.total = t;
              }
            } else if (targetVar.type === "population_size") {
              const pop = targetVar.value.population || "";
              if (format === "RevMan") {
                row["Population Size"] = pop;
              } else if (format === "RStudio") {
                row.population = pop;
              } else if (format === "Stata") {
                row.population = pop;
              }
            }
          } else {
            // SINGLE-ARM, SINGLE GROUP (groupType === 'intervention')
            if (targetVar.type === "dichotomous") {
              const e = targetVar.value.events || "";
              const t = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Events"] = e;
                row["Intervention Total"] = t;
              } else if (format === "RStudio") {
                row.events_inter = e;
                row.n_inter = t;
              } else if (format === "Stata") {
                const yes = parseFloat(e) || 0;
                const tot = parseFloat(t) || 0;
                const no = tot - yes;
                row.yes_inter = yes;
                row.no_inter = no;
                row.total_inter = tot;
              }
            } else if (targetVar.type === "continuous") {
              const m = targetVar.value.mean || "";
              const s = targetVar.value.sd || "";
              const t = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Mean"] = m;
                row["Intervention SD"] = s;
                row["Intervention Total"] = t;
              } else if (format === "RStudio") {
                row.mean_inter = m;
                row.sd_inter = s;
                row.n_inter = t;
              } else if (format === "Stata") {
                row.n_inter = t;
                row.mean_inter = m;
                row.sd_inter = s;
              }
            } else if (targetVar.type === "text") {
              const txt = targetVar.value.text || "";
              const t = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Text"] = txt;
                row["Intervention Total"] = t; // optional, if you want to store it
              } else if (format === "RStudio") {
                row.text = txt;
                row.total = t;
              } else if (format === "Stata") {
                row.text = txt;
                row.total = t;
              }
            } else if (targetVar.type === "population_size") {
              const pop = targetVar.value.population || "";
              if (format === "RevMan") {
                row["Population Size"] = pop;
              } else if (format === "RStudio") {
                row.population = pop;
              } else if (format === "Stata") {
                row.population = pop;
              }
            }
          }

          return row;
        }

// ============================================
// HELPER FUNCTIONS FOR NETWORK MODE EXPORT
// ============================================

/**
 * Sanitizes Study ID for MetaInsight format
 * Removes spaces, commas, "et al." → Example: "Smith, 2020" becomes "Smith2020"
 */
const sanitizeStudyId = (studyId) => {
  return studyId
    .replace(/et al\./gi, '')
    .replace(/,/g, '')
    .replace(/\s+/g, '')
    .trim();
};

/**
 * Sanitizes intervention name for MetaInsight format
 * Replaces spaces with underscores → Example: "Drug A" becomes "Drug_A"
 */
const sanitizeInterventionName = (interventionName) => {
  return interventionName
    .replace(/\s+/g, '_')
    .trim();
};

/**
 * Formats covariate name for MetaInsight format
 * Returns "covar.{name_without_spaces}" → Example: "Hospital Stay" becomes "covar.hospitalstay"
 */
const getCovariateName = (covarLabel) => {
  if (!covarLabel) return '';
  const sanitized = covarLabel
    .toLowerCase()
    .replace(/\s+/g, '')
    .replace(/[^a-z0-9]/gi, '');
  return `covar.${sanitized}`;
};

/**
 * Gets the covariate value for a specific study/intervention
 * Searches in both baseline and outcomes variables
 */
const getCovariateValue = (studyId, interventionName, covarLabel, baselineVars, outcomesVars) => {
  if (!covarLabel) return '';

  // Search in baseline first
  const baselineStudyVars = baselineVars[studyId] || [];
  let covarVar = baselineStudyVars.find(v =>
    v.label === covarLabel &&
    (!interventionName || v.interventionName === interventionName || !v.interventionName)
  );

  // If not found, search in outcomes
  if (!covarVar) {
    const outcomesStudyVars = outcomesVars[studyId] || [];
    covarVar = outcomesStudyVars.find(v =>
      v.label === covarLabel &&
      (!interventionName || v.interventionName === interventionName || !v.interventionName)
    );
  }

  if (!covarVar) return '';

  // Extract value based on type
  if (covarVar.type === 'dichotomous') {
    return covarVar.value.events || '';
  } else if (covarVar.type === 'continuous') {
    return covarVar.value.mean || '';
  } else if (covarVar.type === 'population_size') {
    return covarVar.value.population || '';
  } else if (covarVar.type === 'text') {
    return covarVar.value.text || covarVar.value || '';
  }

  return '';
};

/**
 * Counts the number of interventions per study for a given variable
 * Returns object: { studyId: interventionCount }
 */
const countInterventionsPerStudy = (variablesToUse, studyIds, targetLabel) => {
  const counts = {};

  studyIds.forEach(studyId => {
    const studyVars = variablesToUse[studyId] || [];
    const interventions = new Set();

    studyVars.forEach(variable => {
      if (variable.label === targetLabel && variable.interventionName) {
        interventions.add(variable.interventionName);
      }
    });

    counts[studyId] = interventions.size;
  });

  return counts;
};

/**
 * Builds a row for MetaInsight format (NETWORK mode only)
 * Format for continuous: Study | T | Mean | SD | N | covar.{name} (optional)
 * Format for dichotomous: Study | T | N | R | covar.{name} (optional)
 */
const buildMetaInsightRow = (studyId, targetVar, interventionName, selectedCovariate, baselineVars, outcomesVars) => {
  const row = {};

  // Sanitize Study ID and intervention name
  row['Study'] = sanitizeStudyId(studyId);
  row['T'] = sanitizeInterventionName(interventionName);

  // Build row based on variable type
  if (targetVar.type === 'dichotomous') {
    // Dichotomous: Study | T | N | R | covar
    row['N'] = targetVar.value.total || '';
    row['R'] = targetVar.value.events || '';
  } else if (targetVar.type === 'continuous') {
    // Continuous: Study | T | Mean | SD | N | covar
    row['Mean'] = targetVar.value.mean || '';
    row['SD'] = targetVar.value.sd || '';
    row['N'] = targetVar.value.total || '';
  } else {
    // Unsupported type for MetaInsight
    return null;
  }

  // Add covariate if selected
  if (selectedCovariate) {
    const covarName = getCovariateName(selectedCovariate);
    const covarValue = getCovariateValue(studyId, interventionName, selectedCovariate, baselineVars, outcomesVars);
    row[covarName] = covarValue;
  }

  return row;
};

/**
 * Builds a row for RStudio format in NETWORK mode (line per intervention)
 * Format for dichotomous: study | intervention | events | n
 * Format for continuous: study | intervention | mean | sd | n
 */
const buildRStudioNetworkRow = (studyId, targetVar, interventionName) => {
  const row = {};

  row['study'] = studyId;
  row['intervention'] = interventionName;

  if (targetVar.type === 'dichotomous') {
    row['events'] = targetVar.value.events || '';
    row['n'] = targetVar.value.total || '';
  } else if (targetVar.type === 'continuous') {
    row['mean'] = targetVar.value.mean || '';
    row['sd'] = targetVar.value.sd || '';
    row['n'] = targetVar.value.total || '';
  } else if (targetVar.type === 'population_size') {
    row['n'] = targetVar.value.population || '';
  } else {
    // Unsupported type for RStudio network
    return null;
  }

  return row;
};

const handleDownloadFolder = async () => {
  if (!selectedPopulationVariable) {
    alert("Please select a Population Size Variable.");
    return;
  }

  let groupPart;
  if (groupType === "intervention") {
    groupPart = groupNames.interventionName;
  } else if (groupType === "intervention_comparison") {
    groupPart = `${groupNames.interventionName}_x_${groupNames.comparisonName}`;
  } else {
    groupPart = "Data";
  }

  const zip = new JSZip();
  let createdAnyCSV = false;

  // ============================================
  // NETWORK MODE - New Logic
  // ============================================
  if (groupType === "network") {
    const processNetworkDataset = (datasetName, variablesToUse) => {
      let labels = getVariableLabelsFromDataset(variablesToUse);

      const variableCounts = {};
      labels.forEach(label => {
        let count = 0;
        studyIds.forEach(studyId => {
          if (variablesToUse[studyId]?.some(v => v.label === label)) count++;
        });
        variableCounts[label] = count;
      });

      if (previewOption === "recurrent") {
        labels = labels.filter(label => variableCounts[label] >= 2);
      }

      labels.forEach(label => {
        // Create arrays for different folder structures
        let allInterventionsRows = [];
        let twoOrMoreInterventionsRows = [];

        studyIds.forEach(studyId => {
          const localVars = variablesToUse[studyId] || [];
          const targetVars = localVars.filter(v => v.label === label && v.interventionName);

          targetVars.forEach(targetVar => {
            const interventionName = targetVar.interventionName;

            // Build row based on selected format
            let rowData;
            if (selectedFormat === "MetaInsight") {
              rowData = buildMetaInsightRow(studyId, targetVar, interventionName, selectedCovariate, baselineVariables, outcomesVariables);
            } else if (selectedFormat === "RStudio") {
              rowData = buildRStudioNetworkRow(studyId, targetVar, interventionName);
            }

            if (!rowData) return;

            // Check if row has complete data (if checkbox is checked)
            if (onlyCompleteStudies) {
              const hasEmptyValues = Object.values(rowData).some(val => val === '' || val === null || val === undefined);
              if (hasEmptyValues) return; // Skip incomplete rows

              // Check covariate if selected
              if (selectedCovariate && selectedFormat === "MetaInsight") {
                const covarName = getCovariateName(selectedCovariate);
                if (!rowData[covarName] || rowData[covarName] === '') return; // Skip if no covar data
              }
            }

            // Add to ALL_INTERVENTIONS
            allInterventionsRows.push({ ...rowData, studyId, interventionName });
          });
        });

        // Now process 2_OR_MORE_INTERVENTIONS
        // Count interventions per study in allInterventionsRows
        const studyInterventionCounts = {};
        allInterventionsRows.forEach(row => {
          if (!studyInterventionCounts[row.studyId]) {
            studyInterventionCounts[row.studyId] = new Set();
          }
          studyInterventionCounts[row.studyId].add(row.interventionName);
        });

        // Filter rows where study has >= 2 interventions
        twoOrMoreInterventionsRows = allInterventionsRows.filter(row => {
          return studyInterventionCounts[row.studyId].size >= 2;
        });

        // Remove temporary fields (studyId, interventionName) added for counting
        allInterventionsRows = allInterventionsRows.map(row => {
          const { studyId, interventionName, ...cleanRow } = row;
          return cleanRow;
        });
        twoOrMoreInterventionsRows = twoOrMoreInterventionsRows.map(row => {
          const { studyId, interventionName, ...cleanRow } = row;
          return cleanRow;
        });

        // Determine folder structure based on unique study count
        const uniqueStudiesAll = new Set(allInterventionsRows.map(r => r.Study || r.study)).size;
        const uniqueStudies2Plus = new Set(twoOrMoreInterventionsRows.map(r => r.Study || r.study)).size;

        const safeLabel = label.replace(/\//g, '_');

        // Create folder structure
        if (allInterventionsRows.length > 0) {
          const studyCountFolder = uniqueStudiesAll >= 3 ? "3_OR_MORE_STUDIES" : "LESS_THAN_3_STUDIES";
          const csvAll = generateCSVContent(allInterventionsRows, selectedFormat);
          zip.file(`${datasetName}/${studyCountFolder}/ALL_INTERVENTIONS/${safeLabel}.csv`, csvAll);
          createdAnyCSV = true;
        }

        if (twoOrMoreInterventionsRows.length > 0) {
          const studyCountFolder = uniqueStudies2Plus >= 3 ? "3_OR_MORE_STUDIES" : "LESS_THAN_3_STUDIES";
          const csv2Plus = generateCSVContent(twoOrMoreInterventionsRows, selectedFormat);
          zip.file(`${datasetName}/${studyCountFolder}/2_OR_MORE_INTERVENTIONS/${safeLabel}.csv`, csv2Plus);
          createdAnyCSV = true;
        }
      });
    };

    // Process baseline if applicable
    if (previewOption === "baseline" || previewOption === "both" || previewOption === "recurrent") {
      processNetworkDataset("BASELINE DATA", baselineVariables);
    }

    // Process outcomes if applicable
    if (previewOption === "outcomes" || previewOption === "both" || previewOption === "recurrent") {
      processNetworkDataset("OUTCOMES DATA", outcomesVariables);
    }
  }
  // ============================================
  // NON-NETWORK MODES - Original Logic
  // ============================================
  else {
    // Helper function to process a dataset (baseline or outcomes)
    const processDataset = (datasetName, variablesToUse) => {
      let labels = getVariableLabelsFromDataset(variablesToUse);

      const variableCounts = {};
      labels.forEach(label => {
        let count = 0;
        studyIds.forEach(studyId => {
          if (variablesToUse[studyId]?.some(v => v.label === label)) count++;
        });
        variableCounts[label] = count;
      });

      if (previewOption === "recurrent") {
        labels = labels.filter(label => variableCounts[label] >= 2);
      }

      labels.forEach(label => {
        const dataRows = [];
        studyIds.forEach(studyId => {
          const localVars = variablesToUse[studyId] || [];
          const targetVar = localVars.find(v => v.label === label);
          if (!targetVar) return;

          if (onlyCompleteStudies) {
            if (selectedPopulationVariable === "Total Patients") {
              if (!hasCompleteDoubleTotals(targetVar)) return;
            } else {
              let popVar = localVars.find(v => v.label === selectedPopulationVariable);
              if (!popVar) {
                // Look in the other dataset if not found
                const otherVariables = (datasetName === "BASELINE DATA" ? outcomesVariables : baselineVariables);
                popVar = (otherVariables[studyId] || []).find(v => v.label === selectedPopulationVariable);
              }
              if (!popVar || !hasCompleteData(targetVar, popVar)) return;
            }
          }

          let rowData;
          if (selectedPopulationVariable === "Total Patients") {
            rowData = buildRowUsingVariableTotals(studyId, targetVar, selectedFormat, groupNames, groupType);
          } else {
            let popVar = localVars.find(v => v.label === selectedPopulationVariable);
            if (!popVar) {
              const otherVariables = (datasetName === "BASELINE DATA" ? outcomesVariables : baselineVariables);
              popVar = (otherVariables[studyId] || []).find(v => v.label === selectedPopulationVariable);
            }
            if (!popVar) return;
            rowData = buildDataRow(studyId, targetVar, popVar, selectedFormat, groupNames, groupType);
          }

          if (rowData) dataRows.push(rowData);
        });

        if (dataRows.length === 0) return;

        const effectiveCount = dataRows.length;
        const subfolderName = effectiveCount < 3 ? "LESS THAN 3 STUDIES" : "3 OR MORE STUDIES";

        const csvContent = generateCSVContent(dataRows, selectedFormat);
        const safeLabel = label.replace(/\//g, '_');
        zip.file(`${datasetName}/${subfolderName}/${safeLabel}.csv`, csvContent);
        createdAnyCSV = true;
      });
    };

    // Process baseline if applicable
    if (previewOption === "baseline" || previewOption === "both" || previewOption === "recurrent") {
      processDataset("BASELINE DATA", baselineVariables);
    }

    // Process outcomes if applicable
    if (previewOption === "outcomes" || previewOption === "both" || previewOption === "recurrent") {
      processDataset("OUTCOMES DATA", outcomesVariables);
    }
  }

  // If we didn't produce any CSV
  if (!createdAnyCSV) {
    alert("No data available to download.");
    return;
  }

  // Generate and download the ZIP
  zip.generateAsync({ type: "blob" }).then((blob) => {
    const now = new Date();
    const fname = `Variables_${groupPart}_${now.toISOString().slice(0, 19).replace("T", "_").replace(/:/g, "-")}.zip`;
    saveAs(blob, fname);

    // Open "Variable Files" Google Drive links
    try {
      const storedData = JSON.parse(localStorage.getItem("driveLinks")) || {};
      const variableLinks = storedData["Variable Files"] || [];
      variableLinks.forEach((link) => {
        window.open(link, "_blank");
      });
    } catch (err) {
      console.error("Error opening Variable Files links:", err);
    }
  });

  // close the modal
  closeDownloadFolderModal();
};

        function buildDataRowUsingTotalsOnly(
          studyId,
          targetVar,
          format,
          groupNames,
          groupType
        ) {
          // The row object we'll eventually return
          const row = {};

          // Always store the Study ID in some form
          // For "RevMan", we'll keep "Study ID" as the header
          // For "RStudio" and "Stata", often we store it under "study"
          row["Study ID"] = studyId;

          // Distinguish by variable type first
          if (targetVar.type === "dichotomous") {
            if (
              groupType === "intervention_comparison" &&
              targetVar.armType === "double"
            ) {
              // DOUBLE-ARM DICHOTOMOUS
              const iEvents = targetVar.value.intervention || "";
              const iTotal = targetVar.value.interventionTotal || "";
              const cEvents = targetVar.value.comparison || "";
              const cTotal = targetVar.value.comparisonTotal || "";

              if (format === "RevMan") {
                row["Intervention Events"] = iEvents;
                row["Intervention Total"] = iTotal;
                row["Comparison Events"] = cEvents;
                row["Comparison Total"] = cTotal;
              } else if (format === "RStudio") {
                // Typically "study", "events_inter", "n_inter", "events_control", "n_control"
                // We'll also set row.study = studyId so it’s consistent with your usage
                row.study = studyId;
                row.events_control = cEvents;
                row.n_control = cTotal;
                row.events_inter = iEvents;
                row.n_inter = iTotal;
              } else if (format === "Stata") {
                // In Stata, you might store “yes_inter/no_inter” and “yes_control/no_control”
                row.study = studyId;

                const yes_inter = parseFloat(iEvents) || 0;
                const total_inter = parseFloat(iTotal) || 0;
                const no_inter = total_inter - yes_inter;

                const yes_control = parseFloat(cEvents) || 0;
                const total_control = parseFloat(cTotal) || 0;
                const no_control = total_control - yes_control;

                row["yes_inter"] = yes_inter;
                row["no_inter"] = no_inter;
                row["yes_control"] = yes_control;
                row["no_control"] = no_control;
              }
            } else {
              // SINGLE-ARM DICHOTOMOUS
              const events = targetVar.value.events || "";
              const total = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Events"] = events;
                row["Intervention Total"] = total;
              } else if (format === "RStudio") {
                row.study = studyId;
                row.events_inter = events;
                row.n_inter = total;
              } else if (format === "Stata") {
                row.study = studyId;
                const yes = parseFloat(events) || 0;
                const tot = parseFloat(total) || 0;
                const no = tot - yes;

                row["yes_inter"] = yes;
                row["no_inter"] = no;
                row["total_inter"] = tot;
              }
            }
          } else if (targetVar.type === "continuous") {
            if (
              groupType === "intervention_comparison" &&
              targetVar.armType === "double"
            ) {
              // DOUBLE-ARM CONTINUOUS
              const iMean = (targetVar.value.intervention || {}).mean || "";
              const iSd = (targetVar.value.intervention || {}).sd || "";
              const iTotal = targetVar.value.interventionTotal || "";

              const cMean = (targetVar.value.comparison || {}).mean || "";
              const cSd = (targetVar.value.comparison || {}).sd || "";
              const cTotal = targetVar.value.comparisonTotal || "";

              if (format === "RevMan") {
                // Example columns: "Intervention Mean", "Intervention SD", "Intervention Total" ...
                row["Intervention Mean"] = iMean;
                row["Intervention SD"] = iSd;
                row["Intervention Total"] = iTotal;
                row["Comparison Mean"] = cMean;
                row["Comparison SD"] = cSd;
                row["Comparison Total"] = cTotal;
              } else if (format === "RStudio") {
                // Example columns: "study", "mean_inter", "sd_inter", "n_inter", "mean_control", "sd_control", "n_control"
                row.study = studyId;
                row.mean_control = cMean;
                row.sd_control = cSd;
                row.n_control = cTotal;
                row.mean_inter = iMean;
                row.sd_inter = iSd;
                row.n_inter = iTotal;
              } else if (format === "Stata") {
                // Example columns for Stata: "n_inter", "mean_inter", "sd_inter", "n_control", "mean_control", "sd_control", etc.
                row.study = studyId;
                row.n_inter = iTotal;
                row.mean_inter = iMean;
                row.sd_inter = iSd;
                row.n_control = cTotal;
                row.mean_control = cMean;
                row.sd_control = cSd;
              }
            } else {
              // SINGLE-ARM CONTINUOUS
              const mean = targetVar.value.mean || "";
              const sd = targetVar.value.sd || "";
              const total = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Mean"] = mean;
                row["Intervention SD"] = sd;
                row["Intervention Total"] = total;
              } else if (format === "RStudio") {
                row.study = studyId;
                row.mean_inter = mean;
                row.sd_inter = sd;
                row.n_inter = total;
              } else if (format === "Stata") {
                row.study = studyId;
                row.n_inter = total;
                row.mean_inter = mean;
                row.sd_inter = sd;
              }
            }
          } else if (targetVar.type === "text") {
            if (
              groupType === "intervention_comparison" &&
              targetVar.armType === "double"
            ) {
              // DOUBLE-ARM TEXT
              const iText = targetVar.value.intervention || "";
              const iTotal = targetVar.value.interventionTotal || "";
              const cText = targetVar.value.comparison || "";
              const cTotal = targetVar.value.comparisonTotal || "";

              if (format === "RevMan") {
                row["Intervention Text"] = iText;
                row["Intervention Total"] = iTotal; // If you want to store it, depends on usage
                row["Comparison Text"] = cText;
                row["Comparison Total"] = cTotal; // Similarly optional
              } else if (format === "RStudio") {
                // Typically you'd not store text variables in the same place you store numeric columns,
                // but for completeness:
                row.study = studyId;
                row.intervention_text = iText;
                row.intervention_total = iTotal;
                row.comparison_text = cText;
                row.comparison_total = cTotal;
              } else if (format === "Stata") {
                // Same note about text fields in Stata
                row.study = studyId;
                row["intervention_text"] = iText;
                row["intervention_total"] = iTotal;
                row["comparison_text"] = cText;
                row["comparison_total"] = cTotal;
              }
            } else {
              // SINGLE-ARM TEXT
              const textValue = targetVar.value.text || "";
              const total = targetVar.value.total || "";

              if (format === "RevMan") {
                row["Intervention Text"] = textValue;
                row["Intervention Total"] = total; // If needed
              } else if (format === "RStudio") {
                row.study = studyId;
                row.text = textValue;
                row.total = total; // optional
              } else if (format === "Stata") {
                row.study = studyId;
                row.text = textValue;
                row.total = total; // optional
              }
            }
          } else if (targetVar.type === "population_size") {
            if (
              groupType === "intervention_comparison" &&
              targetVar.armType === "double"
            ) {
              // DOUBLE-ARM population_size
              const iPop = targetVar.value.interventionPop || "";
              const cPop = targetVar.value.comparisonPop || "";

              if (format === "RevMan") {
                row["Intervention Population Size"] = iPop;
                row["Comparison Population Size"] = cPop;
              } else if (format === "RStudio") {
                row.study = studyId;
                row.population_inter = iPop;
                row.population_control = cPop;
              } else if (format === "Stata") {
                row.study = studyId;
                row["population_inter"] = iPop;
                row["population_control"] = cPop;
              }
            } else {
              // SINGLE-ARM population_size
              const pop = targetVar.value.population || "";

              if (format === "RevMan") {
                row["Population Size"] = pop;
              } else if (format === "RStudio") {
                row.study = studyId;
                row.population = pop;
              } else if (format === "Stata") {
                row.study = studyId;
                row.population = pop;
              }
            }
          }

          return row;
        }

        function hasCompleteDoubleTotals(targetVar) {
          // 1) Check if double-arm or single-arm
          if (targetVar.armType === "double") {
            // DOUBLE-ARM variable
            if (targetVar.type === "dichotomous") {
              // Expect .value.intervention, .value.interventionTotal, .value.comparison, .value.comparisonTotal
              return (
                !!targetVar.value.intervention &&
                !!targetVar.value.interventionTotal &&
                !!targetVar.value.comparison &&
                !!targetVar.value.comparisonTotal
              );
            } else if (targetVar.type === "continuous") {
              // Expect .value.intervention.mean, .value.intervention.sd, .value.interventionTotal, etc.
              return (
                !!(
                  targetVar.value.intervention &&
                  targetVar.value.intervention.mean
                ) &&
                !!(
                  targetVar.value.intervention &&
                  targetVar.value.intervention.sd
                ) &&
                !!targetVar.value.interventionTotal &&
                !!(
                  targetVar.value.comparison && targetVar.value.comparison.mean
                ) &&
                !!(
                  targetVar.value.comparison && targetVar.value.comparison.sd
                ) &&
                !!targetVar.value.comparisonTotal
              );
            } else if (targetVar.type === "text") {
              // Possibly need .value.intervention, .value.interventionTotal, .value.comparison, .value.comparisonTotal
              return (
                !!targetVar.value.intervention &&
                !!targetVar.value.interventionTotal &&
                !!targetVar.value.comparison &&
                !!targetVar.value.comparisonTotal
              );
            } else if (targetVar.type === "population_size") {
              // Expect .value.interventionPop and .value.comparisonPop
              return (
                !!targetVar.value.interventionPop &&
                !!targetVar.value.comparisonPop
              );
            }

            // If we have an unexpected type, decide whether to treat as complete
            return false;
          } else {
            // SINGLE-ARM variable
            if (targetVar.type === "dichotomous") {
              // Expect .value.events and .value.total
              return !!targetVar.value.events && !!targetVar.value.total;
            } else if (targetVar.type === "continuous") {
              // Expect .value.mean, .value.sd, and .value.total
              return (
                !!targetVar.value.mean &&
                !!targetVar.value.sd &&
                !!targetVar.value.total
              );
            } else if (targetVar.type === "text") {
              // Possibly check .value.text, or consider 'complete' if text is present
              // Some might also want to see if .value.total is present
              return !!targetVar.value.text;
              // && !!targetVar.value.total  (optional check if needed)
            } else if (targetVar.type === "population_size") {
              // Expect .value.population
              return !!targetVar.value.population;
            }

            // If unexpected type
            return false;
          }
        }

        // Function to get variable labels from a dataset
        function getVariableLabelsFromDataset(variables) {
          const variableLabelsSet = new Set();

          Object.values(variables).forEach((studyVars) => {
            studyVars.forEach((variable) => {
              variableLabelsSet.add(variable.label);
            });
          });

          return Array.from(variableLabelsSet);
        }

        // Function to count occurrences of each variable label
        function getVariableCounts(variableLabels) {
          const counts = {};
          variableLabels.forEach((label) => {
            counts[label] = (counts[label] || 0) + 1;
          });
          return counts;
        }

        // Helper functions
        function hasCompleteData(targetVar, populationVar) {
          // Check if all required fields are present
          if (targetVar.type === "dichotomous") {
            if (
              groupType === "intervention_comparison" &&
              targetVar.armType === "double"
            ) {
              return (
                targetVar.value.intervention &&
                targetVar.value.comparison &&
                populationVar.value.intervention &&
                populationVar.value.comparison
              );
            } else {
              return targetVar.value && populationVar.value;
            }
          } else if (targetVar.type === "continuous") {
            if (
              groupType === "intervention_comparison" &&
              targetVar.armType === "double"
            ) {
              return (
                targetVar.value.intervention.mean &&
                targetVar.value.intervention.sd &&
                targetVar.value.comparison.mean &&
                targetVar.value.comparison.sd &&
                populationVar.value.intervention &&
                populationVar.value.comparison
              );
            } else {
              return (
                targetVar.value.mean &&
                targetVar.value.sd &&
                populationVar.value
              );
            }
          }
          return false;
        }

        function buildDataRow(
          studyId,
          targetVar,
          populationVar,
          format,
          groupNames,
          groupType
        ) {
          let row = {};

          if (format === "RevMan") {
            row["Study ID"] = studyId; // Include Study ID

            if (targetVar.type === "dichotomous") {
              if (
                groupType === "intervention_comparison" &&
                targetVar.armType === "double"
              ) {
                row = {
                  ...row,
                  "Intervention Events": targetVar.value.intervention,
                  "Intervention Total": populationVar.value.interventionPop, // Updated
                  "Comparison Events": targetVar.value.comparison,
                  "Comparison Total": populationVar.value.comparisonPop, // Updated
                };
              } else {
                row = {
                  ...row,
                  "Intervention Events": targetVar.value,
                  "Intervention Total":
                    populationVar.value.interventionPop || getMissingValue(), // Updated
                };
              }
            } else if (targetVar.type === "continuous") {
              if (
                groupType === "intervention_comparison" &&
                targetVar.armType === "double"
              ) {
                row = {
                  ...row,
                  "Intervention Mean": targetVar.value.intervention.mean,
                  "Intervention SD": targetVar.value.intervention.sd,
                  "Intervention Total": populationVar.value.interventionPop, // Updated
                  "Comparison Mean": targetVar.value.comparison.mean,
                  "Comparison SD": targetVar.value.comparison.sd,
                  "Comparison Total": populationVar.value.comparisonPop, // Updated
                };
              } else {
                row = {
                  ...row,
                  "Intervention Mean": targetVar.value.mean,
                  "Intervention SD": targetVar.value.sd,
                  "Intervention Total":
                    populationVar.value.interventionPop || getMissingValue(), // Updated
                };
              }
            } else if (targetVar.type === "population_size") {
              if (groupType === "intervention_comparison") {
                if (
                  populationVar.value.interventionPop !== undefined &&
                  populationVar.value.comparisonPop !== undefined
                ) {
                  row = {
                    ...row,
                    "Intervention Population Size":
                      populationVar.value.interventionPop, // Updated
                    "Comparison Population Size":
                      populationVar.value.comparisonPop, // Updated
                  };
                }
              } else {
                row = {
                  ...row,
                  "Population Size":
                    populationVar.value.population || getMissingValue(), // Ensure correct property
                };
              }
            }

            // Handle additional types if necessary (e.g., 'text')
            // Add similar blocks here if 'text' type requires population size
          } else if (format === "RStudio") {
            if (targetVar.type === "dichotomous") {
              if (
                groupType === "intervention_comparison" &&
                targetVar.armType === "double"
              ) {
                row = {
                  study: studyId,
                  events_control: targetVar.value.comparison,
                  n_control: populationVar.value.comparisonPop, // Updated
                  events_inter: targetVar.value.intervention,
                  n_inter: populationVar.value.interventionPop, // Updated
                };
              } else {
                row = {
                  study: studyId,
                  events_inter: targetVar.value,
                  n_inter:
                    populationVar.value.interventionPop || getMissingValue(), // Updated
                };
              }
            } else if (targetVar.type === "continuous") {
              if (
                groupType === "intervention_comparison" &&
                targetVar.armType === "double"
              ) {
                row = {
                  study: studyId,
                  mean_control: targetVar.value.comparison.mean,
                  sd_control: targetVar.value.comparison.sd,
                  n_control: populationVar.value.comparisonPop, // Updated
                  mean_inter: targetVar.value.intervention.mean,
                  sd_inter: targetVar.value.intervention.sd,
                  n_inter: populationVar.value.interventionPop, // Updated
                };
              } else {
                row = {
                  study: studyId,
                  mean_inter: targetVar.value.mean,
                  sd_inter: targetVar.value.sd,
                  n_inter:
                    populationVar.value.interventionPop || getMissingValue(), // Updated
                };
              }
            } else if (targetVar.type === "population_size") {
              if (groupType === "intervention_comparison") {
                row = {
                  study: studyId,
                  population_inter: populationVar.value.interventionPop, // Updated
                  population_control: populationVar.value.comparisonPop, // Updated
                };
              } else {
                row = {
                  study: studyId,
                  population:
                    populationVar.value.population || getMissingValue(), // Ensure correct property
                };
              }
            }

            // Handle additional types if necessary (e.g., 'text')
            // Add similar blocks here if 'text' type requires population size
          } else if (format === "Stata") {
            // Stata format: dichotomous = Yes/No instead of Events/Total
            // Continuous similar to RStudio
            row["study"] = studyId;

            if (targetVar.type === "dichotomous") {
              if (
                groupType === "intervention_comparison" &&
                targetVar.armType === "double"
              ) {
                const interYes = parseFloat(targetVar.value.intervention) || 0;
                const interTotal =
                  parseFloat(populationVar.value.interventionPop) || 0;
                const interNo = interTotal - interYes;

                const compYes = parseFloat(targetVar.value.comparison) || 0;
                const compTotal =
                  parseFloat(populationVar.value.comparisonPop) || 0;
                const compNo = compTotal - compYes;

                row["yes_inter"] = interYes;
                row["no_inter"] = interNo;
                row["yes_control"] = compYes;
                row["no_control"] = compNo;
              } else {
                const yes = parseFloat(targetVar.value) || 0;
                const total =
                  parseFloat(populationVar.value.interventionPop) || 0;
                const no = total - yes;

                // Single-arm data in Stata format
                row["yes_inter"] = yes;
                row["no_inter"] = no;
                row["total_inter"] = total;
              }
            } else if (targetVar.type === "continuous") {
              if (
                groupType === "intervention_comparison" &&
                targetVar.armType === "double"
              ) {
                row = {
                  ...row,
                  n_inter: populationVar.value.interventionPop, // Updated
                  mean_inter: targetVar.value.intervention.mean,
                  sd_inter: targetVar.value.intervention.sd,
                  n_control: populationVar.value.comparisonPop, // Updated
                  mean_control: targetVar.value.comparison.mean,
                  sd_control: targetVar.value.comparison.sd,
                };
              } else {
                row = {
                  ...row,
                  n_inter: populationVar.value.interventionPop, // Updated
                  mean_inter: targetVar.value.mean,
                  sd_inter: targetVar.value.sd,
                };
              }
            } else if (targetVar.type === "population_size") {
              if (groupType === "intervention_comparison") {
                row["population_inter"] = populationVar.value.interventionPop; // Updated
                row["population_control"] = populationVar.value.comparisonPop; // Updated
              } else {
                row["population"] =
                  populationVar.value.population || getMissingValue(); // Ensure correct property
              }
            }

            // Handle additional types if necessary (e.g., 'text')
            // Add similar blocks here if 'text' type requires population size
          }

          return row;
        }

        function generateCSVContent(dataRows, format) {
          if (!dataRows || dataRows.length === 0) return "";

          let csv = "";

          if (format === "RevMan") {
            const headers = Object.keys(dataRows[0]);
            csv += headers.join(";") + "\n";
            dataRows.forEach((row) => {
              const values = headers.map((header) => row[header]);
              csv += values.join(";") + "\n";
            });
          } else if (format === "RStudio") {
            const headers = Object.keys(dataRows[0]);
            csv += headers.join(";") + "\n";
            dataRows.forEach((row) => {
              const values = headers.map((header) => row[header]);
              csv += values.join(";") + "\n";
            });
          } else if (format === "Stata") {
            const headers = Object.keys(dataRows[0]);
            csv += headers.join(";") + "\n";
            dataRows.forEach((row) => {
              const values = headers.map((header) => row[header]);
              csv += values.join(";") + "\n";
            });
          } else if (format === "MetaInsight") {
            const headers = Object.keys(dataRows[0]);
            csv += headers.join(";") + "\n";
            dataRows.forEach((row) => {
              const values = headers.map((header) => row[header]);
              csv += values.join(";") + "\n";
            });
          }

          return "\uFEFF" + csv;
        }
        return (
          <div className="space-y-6">
            <h1 className="text-2xl font-bold">Preview Dataset</h1>
            <div className="flex space-x-4">
              <button
                onClick={() => setPreviewOption("baseline")}
                className={`font-semibold py-2 px-4 rounded-lg transition duration-300 ${
                  previewOption === "baseline"
                    ? "bg-blue-600"
                    : "bg-gray-700 hover:bg-gray-600"
                }`}
              >
                Baseline Data
              </button>
              <button
                onClick={() => setPreviewOption("outcomes")}
                className={`font-semibold py-2 px-4 rounded-lg transition duration-300 ${
                  previewOption === "outcomes"
                    ? "bg-blue-600"
                    : "bg-gray-700 hover:bg-gray-600"
                }`}
              >
                Outcomes Data
              </button>
              <button
                onClick={() => setPreviewOption("both")}
                className={`font-semibold py-2 px-4 rounded-lg transition duration-300 ${
                  previewOption === "both"
                    ? "bg-blue-600"
                    : "bg-gray-700 hover:bg-gray-600"
                }`}
              >
                Both
              </button>
              <button
                onClick={() => setPreviewOption("recurrent")}
                className={`font-semibold py-2 px-4 rounded-lg transition duration-300 ${
                  previewOption === "recurrent"
                    ? "bg-blue-600"
                    : "bg-gray-700 hover:bg-gray-600"
                }`}
              >
                Recurrent
              </button>
              <button
                onClick={copyDataAsList}
                className="font-semibold py-2 px-4 rounded-lg transition duration-300 bg-green-600 hover:bg-green-700 flex items-center space-x-2"
                title="Copy data as structured list for AI analysis"
              >
                <i className="fas fa-clipboard-list"></i>
                <span>Copy as List</span>
              </button>
            </div>
            <div className="mt-4 flex flex-col md:flex-row md:items-center md:space-x-4">
              <div className="flex items-center space-x-4">
                <label className="font-semibold">
                  Missing Data Representation:
                </label>
                <select
                  value={missingDataRepresentation}
                  onChange={(e) => setMissingDataRepresentation(e.target.value)}
                  className="p-2 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="">Empty</option>
                  <option value="NA">NA</option>
                  <option value="N/A">N/A</option>
                  <option value=".">.</option>
                  <option value="-">-</option>
                  <option value="custom">Custom</option>
                </select>
                {missingDataRepresentation === "custom" && (
                  <input
                    type="text"
                    value={customMissingValue}
                    onChange={(e) => setCustomMissingValue(e.target.value)}
                    className="p-2 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="Enter custom value"
                  />
                )}
              </div>

              <div className="mt-4 md:mt-0 flex items-center space-x-4 relative">
                <label className="font-semibold">Weight Variable:</label>
                <button
                  onClick={() => setIsWeightOpen(!isWeightOpen)}
                  className="p-2 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 flex items-center justify-between w-48"
                >
                  {weightVariable || "None"}
                  <i className="fas fa-chevron-down ml-2"></i>
                </button>
                {isWeightOpen && (
                  <div className="absolute top-full left-0 mt-2 w-48 bg-gray-800 border border-gray-700 rounded-lg max-h-48 overflow-y-auto z-10">
                    <ul>
                      <li
                        onClick={() => {
                          setWeightVariable("");
                          setIsWeightOpen(false);
                        }}
                        className="p-2 hover:bg-gray-700 cursor-pointer"
                      >
                        None
                      </li>
                      {getWeightVariableOptions().map((label) => (
                        <li
                          key={label}
                          onClick={() => {
                            setWeightVariable(label);
                            setIsWeightOpen(false);
                          }}
                          className="p-2 hover:bg-gray-700 cursor-pointer"
                        >
                          {label}
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>

              <div className="mt-4 md:mt-0 flex items-center space-x-4">
                <label className="font-semibold">Order By:</label>
                <select
                  value={sortOrder}
                  onChange={(e) => setSortOrder(e.target.value)}
                  className="p-2 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="addition">Order of Addition</option>
                  <option value="alphabetical">Alphabetical</option>
                  <option value="fixed_alphabetical">
                    PICO + Alphabetical
                  </option>
                </select>
              </div>
            </div>
            {(() => {
              let dataRowsToRender = [];
              let variableColumns = [];
              let dataset = null;

              // Decide which dataset(s) to show
              if (previewOption === "both" || previewOption === "recurrent") {
                dataRowsToRender = combinedDataRows;
                variableColumns = [
                  ...baselineDataset.allVariableColumns,
                  ...outcomesDataset.allVariableColumns,
                ];
              } else if (previewOption === "baseline" && baselineDataset) {
                dataRowsToRender = baselineDataset.dataRows;
                variableColumns = baselineDataset.allVariableColumns;
                dataset = baselineDataset;
              } else if (previewOption === "outcomes" && outcomesDataset) {
                dataRowsToRender = outcomesDataset.dataRows;
                variableColumns = outcomesDataset.allVariableColumns;
                dataset = outcomesDataset;
              }

              // ---------------------------------------------
              // Remove "comparison" columns if single-arm
              // i.e., groupType === 'intervention'
              // ---------------------------------------------
              if (groupType === "intervention") {
                variableColumns = variableColumns.filter(
                  (col) => !col.toLowerCase().includes("comparison")
                );
              }

              if (dataRowsToRender.length > 0) {
                return (
                  <div className="overflow-x-auto mt-6">
                    <table className="w-full table-auto border-collapse">
                      <thead>
                        <tr>
                          <th
                            className="border-b-2 border-gray-700 px-4 py-2 text-left"
                            rowSpan="3"
                          >
                            Study ID
                          </th>
                          {groupType === "network" && (
                            <th
                              className="border-b-2 border-gray-700 px-4 py-2 text-left"
                              rowSpan="3"
                            >
                              Intervention
                            </th>
                          )}
                          {(() => {
                            // For "both" or "recurrent": show BASELINE and OUTCOMES spanned headers
                            if (
                              previewOption === "both" ||
                              previewOption === "recurrent"
                            ) {
                              // Filter out "comparison" columns if single-arm
                              const baselineColSpan =
                                baselineDataset.allVariableColumns.filter(
                                  (col) =>
                                    groupType === "intervention_comparison" ||
                                    !col.toLowerCase().includes("comparison")
                                ).length;
                              const outcomesColSpan =
                                outcomesDataset.allVariableColumns.filter(
                                  (col) =>
                                    groupType === "intervention_comparison" ||
                                    !col.toLowerCase().includes("comparison")
                                ).length;
                              return (
                                <>
                                  {baselineColSpan > 0 && (
                                    <th
                                      className="border-b-2 border-gray-700 px-4 py-2 text-center"
                                      colSpan={baselineColSpan}
                                    >
                                      BASELINE
                                    </th>
                                  )}
                                  {outcomesColSpan > 0 && (
                                    <th
                                      className="border-b-2 border-gray-700 px-4 py-2 text-center"
                                      colSpan={outcomesColSpan}
                                    >
                                      OUTCOMES
                                    </th>
                                  )}
                                </>
                              );
                            }
                            // For just one dataset (baseline or outcomes)
                            else if (dataset) {
                              const totalColSpan =
                                dataset.allVariableColumns.filter(
                                  (col) =>
                                    groupType === "intervention_comparison" ||
                                    !col.toLowerCase().includes("comparison")
                                ).length;
                              return (
                                <th
                                  className="border-b-2 border-gray-700 px-4 py-2 text-center"
                                  colSpan={totalColSpan}
                                >
                                  {previewOption.toUpperCase()}
                                </th>
                              );
                            }
                          })()}
                        </tr>

                        {/* Second header row: each variable label (again ignoring "comparison" if single-arm) */}
                        <tr>
                          {(() => {
                            const labelHeaders = [];
                            if (
                              previewOption === "both" ||
                              previewOption === "recurrent"
                            ) {
                              // Baseline labels
                              baselineDataset.allVariableLabels.forEach(
                                (label) => {
                                  const colspan =
                                    baselineDataset.variableSubgroups[
                                      label
                                    ].filter(
                                      (sub) =>
                                        groupType ===
                                          "intervention_comparison" ||
                                        !sub
                                          .toLowerCase()
                                          .includes("comparison")
                                    ).length || 1;
                                  if (colspan > 0) {
                                    labelHeaders.push(
                                      <th
                                        key={`baseline_${label}`}
                                        className="border-b-2 border-gray-700 px-4 py-2 text-center"
                                        colSpan={colspan}
                                      >
                                        {label}
                                      </th>
                                    );
                                  }
                                }
                              );
                              // Outcomes labels
                              outcomesDataset.allVariableLabels.forEach(
                                (label) => {
                                  const colspan =
                                    outcomesDataset.variableSubgroups[
                                      label
                                    ].filter(
                                      (sub) =>
                                        groupType ===
                                          "intervention_comparison" ||
                                        !sub
                                          .toLowerCase()
                                          .includes("comparison")
                                    ).length || 1;
                                  if (colspan > 0) {
                                    labelHeaders.push(
                                      <th
                                        key={`outcomes_${label}`}
                                        className="border-b-2 border-gray-700 px-4 py-2 text-center"
                                        colSpan={colspan}
                                      >
                                        {label}
                                      </th>
                                    );
                                  }
                                }
                              );
                            } else if (dataset) {
                              // Just baseline or just outcomes
                              dataset.allVariableLabels.forEach((label) => {
                                const colspan =
                                  dataset.variableSubgroups[label].filter(
                                    (sub) =>
                                      groupType === "intervention_comparison" ||
                                      !sub.toLowerCase().includes("comparison")
                                  ).length || 1;
                                if (colspan > 0) {
                                  labelHeaders.push(
                                    <th
                                      key={label}
                                      className="border-b-2 border-gray-700 px-4 py-2 text-center"
                                      colSpan={colspan}
                                    >
                                      {label}
                                    </th>
                                  );
                                }
                              });
                            }
                            return labelHeaders;
                          })()}
                        </tr>

                        {/* Third header row: subgroups (again filtering if single-arm) */}
                        <tr>
                          {variableColumns.map((columnName) => (
                            <th
                              key={columnName}
                              className="border-b-2 border-gray-700 px-4 py-2 text-left"
                            >
                              {(() => {
                                const parts = columnName.split("_");
                                // If there's only one part, we show a blank heading;
                                // otherwise show everything after the first underscore
                                return parts.slice(1).join("_") || "\u00A0";
                              })()}
                            </th>
                          ))}
                        </tr>
                      </thead>

                      <tbody>
                        {dataRowsToRender.map((row, index) => (
                          <tr
                            key={index}
                            className={`hover:bg-gray-800 ${
                              index % 2 === 0 ? "bg-gray-900" : "bg-gray-800"
                            }`}
                          >
                            <td className="px-4 py-2">{row.studyId}</td>
                            {groupType === "network" && (
                              <td className="px-4 py-2">{row.intervention || "-"}</td>
                            )}
                            {variableColumns.map((columnName) => {
                              const cellValue =
                                row.variables[columnName] || getMissingValue();
                              return (
                                <td key={columnName} className="px-4 py-2">
                                  {cellValue}
                                </td>
                              );
                            })}
                          </tr>
                        ))}

                        {/* Weighted averages row (if any) */}
                        {Object.keys(weightedAverages).length > 0 && (
                          <tr className="bg-gray-700">
                            <td className="px-4 py-2 font-semibold">
                              Weighted Averages
                            </td>
                            {groupType === "network" && (
                              <td className="px-4 py-2"></td>
                            )}
                            {variableColumns.map((columnName) => {
                              const avgValue = weightedAverages[columnName];
                              return (
                                <td key={columnName} className="px-4 py-2">
                                  {avgValue !== undefined &&
                                  avgValue !== getMissingValue()
                                    ? avgValue.toFixed(2)
                                    : getMissingValue()}
                                </td>
                              );
                            })}
                          </tr>
                        )}
                      </tbody>
                    </table>
                  </div>
                );
              } else {
                return (
                  <p className="text-gray-400">
                    No data available for preview.
                  </p>
                );
              }
            })()}

            <div className="flex flex-col md:flex-row md:justify-between mt-8 space-y-4 md:space-y-0 md:space-x-4">
              <button
                onClick={onBack}
                className="flex items-center justify-center bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
              >
                <i className="fas fa-arrow-left mr-2"></i> Back
              </button>
              <div className="flex flex-col md:flex-row md:space-x-4 space-y-4 md:space-y-0">
                <button
                  onClick={onBackupDownload}
                  className="flex items-center justify-center bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
                >
                  <i className="fas fa-save mr-2"></i> Save Backup
                </button>
                <button
  onClick={handlePicoDownload}
  className="flex items-center justify-center bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
>
  <i className="fas fa-table mr-2"></i> PICO TABLE
</button>
                <button
                  onClick={handleSave}
                  className="flex items-center justify-center bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
                >
                  <i className="fas fa-download mr-2"></i> Save Spreadsheet
                </button>
                <button
                  onClick={openDownloadFolderModal}
                  className="flex items-center justify-center bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
                >
                  <i className="fas fa-folder-open mr-2"></i> Download Folder
                </button>
                <button
                  onClick={openDriveModal}
                  className="flex items-center justify-center bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300"
                >
                  <i className="fas fa-cloud mr-2"></i> Google Drive
                </button>
              </div>
            </div>

            {/* Download Folder Modal */}
            {isDownloadModalOpen && (
              <div className="fixed inset-0 flex items-end justify-center z-50 pb-8 overflow-y-auto">
                <div className="absolute inset-0 bg-black opacity-50"></div>
                <div className="bg-gray-900 text-gray-100 p-6 rounded-lg z-50 w-11/12 md:w-2/3 lg:w-1/2">
                  <h2 className="text-xl font-bold mb-4">
                    Download Folder with Variables
                  </h2>
                  <div className="mt-4">
                    <label className="block font-semibold mb-2">
                      Select Format
                    </label>
                    <select
                      value={selectedFormat}
                      onChange={(e) => setSelectedFormat(e.target.value)}
                      className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                      {groupType === "network" ? (
                        <>
                          <option value="RStudio">RStudio</option>
                          <option value="MetaInsight">MetaInsight</option>
                        </>
                      ) : (
                        <>
                          <option value="RevMan">RevMan</option>
                          <option value="RStudio">RStudio</option>
                          <option value="Stata">Stata</option>
                        </>
                      )}
                    </select>
                  </div>
                  <div className="mt-4">
                    <label className="block font-semibold mb-2">
                      Select Population Size Variable
                    </label>
                    <select
                      value={selectedPopulationVariable}
                      onChange={(e) =>
                        setSelectedPopulationVariable(e.target.value)
                      }
                      className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                      {getPopulationVariableOptions().map((label) => (
                        <option key={label} value={label}>
                          {label}
                        </option>
                      ))}
                    </select>
                  </div>
                  {groupType === "network" && (
                    <div className="mt-4">
                      <label className="block font-semibold mb-2">
                        Select Covariate (Optional - for MetaInsight)
                      </label>
                      <select
                        value={selectedCovariate}
                        onChange={(e) => setSelectedCovariate(e.target.value)}
                        className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                      >
                        <option value="">None</option>
                        {getPopulationVariableOptions().filter(label => label !== "Total Patients").map((label) => (
                          <option key={label} value={label}>
                            {label}
                          </option>
                        ))}
                      </select>
                    </div>
                  )}
                  <div className="mt-4 flex items-center">
                    <input
                      type="checkbox"
                      checked={onlyCompleteStudies}
                      onChange={(e) => setOnlyCompleteStudies(e.target.checked)}
                      className="form-checkbox h-5 w-5 text-blue-600"
                    />
                    <label className="ml-2 font-semibold">
                      Just studies with all the Variable data
                    </label>
                  </div>
                  <div className="mt-6 flex justify-end space-x-4">
                    <button
                      onClick={closeDownloadFolderModal}
                      className="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
                    >
                      Close
                    </button>
                    <button
                      onClick={handleDownloadFolder}
                      className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg transition duration-300 flex items-center"
                    >
                      <i className="fas fa-folder-open mr-2"></i> Download
                      Folder
                    </button>
                  </div>
                </div>
              </div>
            )}
            {isDriveModalOpen && (
              <div className="fixed inset-0 flex items-end justify-center z-50 pb-8 overflow-y-auto">
                <div className="absolute inset-0 bg-black opacity-50"></div>
                <div
                  className="relative bg-gray-900 text-gray-100 p-6 rounded-lg w-11/12 md:w-2/3 lg:w-1/2 max-h-96 overflow-y-auto"
                  style={{
                    border: "1px solid #4A4A4A",
                    boxShadow: "0 0 20px #00FFD1",
                  }}
                >
                  <h2 className="text-2xl font-bold mb-4 text-indigo-300">
                    Google Drive Links
                  </h2>
                  <p className="mb-4 text-gray-400">
                    Add your Google Drive folder links here. This will help open
                    related pages after downloads.
                  </p>

                  <div className="mb-4">
                    <label className="block font-semibold mb-2 text-indigo-200">
                      Select Folder Category
                    </label>
                    <select
                      value={selectedDriveCategory}
                      onChange={(e) => setSelectedDriveCategory(e.target.value)}
                      className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
                    >
                      <option value="Backup Files">Backup Files</option>
                      <option value="Spreadsheet Files">
                        Spreadsheet Files
                      </option>
                      <option value="Variable Files">Variable Files</option>
                    </select>
                  </div>

                  <div className="mb-4">
                    <label className="block font-semibold mb-2 text-indigo-200">
                      New Link
                    </label>
                    <input
                      type="text"
                      value={newDriveLink}
                      onChange={(e) => setNewDriveLink(e.target.value)}
                      placeholder="Paste your Google Drive link here..."
                      className="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
                    />
                    <button
                      onClick={handleAddDriveLink}
                      className="mt-2 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
                    >
                      Add New Link
                    </button>
                  </div>

                  <div>
                    <h3 className="text-xl font-semibold text-indigo-300 mb-2">
                      Your Links
                    </h3>
                    {Object.keys(driveLinks).map((category) => (
                      <div key={category} className="mb-4">
                        <h4 className="font-semibold text-indigo-200 mb-2">
                          {category}
                        </h4>
                        {driveLinks[category].length > 0 ? (
                          <ul className="space-y-1 text-gray-300">
                            {driveLinks[category].map((link, index) => (
                              <li
                                key={index}
                                className="flex justify-between items-center bg-gray-800 p-2 rounded"
                              >
                                <a
                                  href={link}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="underline hover:text-indigo-400 truncate"
                                  style={{ maxWidth: "85%" }}
                                >
                                  {link}
                                </a>
                                {/* Delete Button */}
                                <button
                                  onClick={() =>
                                    removeDriveLink(category, index)
                                  }
                                  className="text-red-500 hover:text-red-700 p-1 ml-2"
                                >
                                  <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    viewBox="0 0 448 512"
                                    className="w-4 h-4 fill-current"
                                  >
                                    <path d="M135.2 17.7L128 32 32 32C14.3 32 0 46.3 0 64S14.3 96 32 96l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0-7.2-14.3C307.4 6.8 296.3 0 284.2 0L163.8 0c-12.1 0-23.2 6.8-28.6 17.7zM416 128L32 128 53.2 467c1.6 25.3 22.6 45 47.9 45l245.8 0c25.3 0 46.3-19.7 47.9-45L416 128z" />
                                  </svg>
                                </button>
                              </li>
                            ))}
                          </ul>
                        ) : (
                          <p className="text-gray-500 text-sm">
                            No links added yet.
                          </p>
                        )}
                      </div>
                    ))}
                  </div>

                  <div className="mt-6 flex justify-end space-x-4">
                    <button
                      onClick={closeDriveModal}
                      className="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-300"
                    >
                      Close
                    </button>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      ReactDOM.render(<App />, document.getElementById("root"));
    </script>
  </body>
</html>
